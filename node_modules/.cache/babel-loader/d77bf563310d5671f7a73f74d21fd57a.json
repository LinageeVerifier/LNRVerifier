{"ast":null,"code":"import _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"refetchPage\"];\nimport { shallowEqualObjects, noop, isServer, isValidTimeout, timeUntilStale, replaceData } from './utils.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { Subscribable } from './subscribable.mjs';\nimport { canFetch, isCancelledError } from './retryer.mjs';\n\nvar QueryObserver = /*#__PURE__*/function (_Subscribable) {\n  _inherits(QueryObserver, _Subscribable);\n\n  var _super = _createSuper(QueryObserver);\n\n  function QueryObserver(client, options) {\n    var _this;\n\n    _classCallCheck(this, QueryObserver);\n\n    _this = _super.call(this);\n    _this.client = client;\n    _this.options = options;\n    _this.trackedProps = new Set();\n    _this.selectError = null;\n\n    _this.bindMethods();\n\n    _this.setOptions(options);\n\n    return _this;\n  }\n\n  _createClass(QueryObserver, [{\n    key: \"bindMethods\",\n    value: function bindMethods() {\n      this.remove = this.remove.bind(this);\n      this.refetch = this.refetch.bind(this);\n    }\n  }, {\n    key: \"onSubscribe\",\n    value: function onSubscribe() {\n      if (this.listeners.length === 1) {\n        this.currentQuery.addObserver(this);\n\n        if (shouldFetchOnMount(this.currentQuery, this.options)) {\n          this.executeFetch();\n        }\n\n        this.updateTimers();\n      }\n    }\n  }, {\n    key: \"onUnsubscribe\",\n    value: function onUnsubscribe() {\n      if (!this.listeners.length) {\n        this.destroy();\n      }\n    }\n  }, {\n    key: \"shouldFetchOnReconnect\",\n    value: function shouldFetchOnReconnect() {\n      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);\n    }\n  }, {\n    key: \"shouldFetchOnWindowFocus\",\n    value: function shouldFetchOnWindowFocus() {\n      return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.listeners = [];\n      this.clearStaleTimeout();\n      this.clearRefetchInterval();\n      this.currentQuery.removeObserver(this);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, notifyOptions) {\n      var prevOptions = this.options;\n      var prevQuery = this.currentQuery;\n      this.options = this.client.defaultQueryOptions(options);\n\n      if (!shallowEqualObjects(prevOptions, this.options)) {\n        this.client.getQueryCache().notify({\n          type: 'observerOptionsUpdated',\n          query: this.currentQuery,\n          observer: this\n        });\n      }\n\n      if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {\n        throw new Error('Expected enabled to be a boolean');\n      } // Keep previous query key if the user does not supply one\n\n\n      if (!this.options.queryKey) {\n        this.options.queryKey = prevOptions.queryKey;\n      }\n\n      this.updateQuery();\n      var mounted = this.hasListeners(); // Fetch if there are subscribers\n\n      if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {\n        this.executeFetch();\n      } // Update result\n\n\n      this.updateResult(notifyOptions); // Update stale interval if needed\n\n      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {\n        this.updateStaleTimeout();\n      }\n\n      var nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed\n\n      if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {\n        this.updateRefetchInterval(nextRefetchInterval);\n      }\n    }\n  }, {\n    key: \"getOptimisticResult\",\n    value: function getOptimisticResult(options) {\n      var query = this.client.getQueryCache().build(this.client, options);\n      return this.createResult(query, options);\n    }\n  }, {\n    key: \"getCurrentResult\",\n    value: function getCurrentResult() {\n      return this.currentResult;\n    }\n  }, {\n    key: \"trackResult\",\n    value: function trackResult(result) {\n      var _this2 = this;\n\n      var trackedResult = {};\n      Object.keys(result).forEach(function (key) {\n        Object.defineProperty(trackedResult, key, {\n          configurable: false,\n          enumerable: true,\n          get: function get() {\n            _this2.trackedProps.add(key);\n\n            return result[key];\n          }\n        });\n      });\n      return trackedResult;\n    }\n  }, {\n    key: \"getCurrentQuery\",\n    value: function getCurrentQuery() {\n      return this.currentQuery;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.client.getQueryCache().remove(this.currentQuery);\n    }\n  }, {\n    key: \"refetch\",\n    value: function refetch() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          refetchPage = _ref.refetchPage,\n          options = _objectWithoutProperties(_ref, _excluded);\n\n      return this.fetch(_objectSpread(_objectSpread({}, options), {}, {\n        meta: {\n          refetchPage: refetchPage\n        }\n      }));\n    }\n  }, {\n    key: \"fetchOptimistic\",\n    value: function fetchOptimistic(options) {\n      var _this3 = this;\n\n      var defaultedOptions = this.client.defaultQueryOptions(options);\n      var query = this.client.getQueryCache().build(this.client, defaultedOptions);\n      query.isFetchingOptimistic = true;\n      return query.fetch().then(function () {\n        return _this3.createResult(query, defaultedOptions);\n      });\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      var _this4 = this;\n\n      var _fetchOptions$cancelR;\n\n      return this.executeFetch(_objectSpread(_objectSpread({}, fetchOptions), {}, {\n        cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true\n      })).then(function () {\n        _this4.updateResult();\n\n        return _this4.currentResult;\n      });\n    }\n  }, {\n    key: \"executeFetch\",\n    value: function executeFetch(fetchOptions) {\n      // Make sure we reference the latest query as the current one might have been removed\n      this.updateQuery(); // Fetch\n\n      var promise = this.currentQuery.fetch(this.options, fetchOptions);\n\n      if (!(fetchOptions != null && fetchOptions.throwOnError)) {\n        promise = promise.catch(noop);\n      }\n\n      return promise;\n    }\n  }, {\n    key: \"updateStaleTimeout\",\n    value: function updateStaleTimeout() {\n      var _this5 = this;\n\n      this.clearStaleTimeout();\n\n      if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {\n        return;\n      }\n\n      var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.\n      // To mitigate this issue we always add 1 ms to the timeout.\n\n      var timeout = time + 1;\n      this.staleTimeoutId = setTimeout(function () {\n        if (!_this5.currentResult.isStale) {\n          _this5.updateResult();\n        }\n      }, timeout);\n    }\n  }, {\n    key: \"computeRefetchInterval\",\n    value: function computeRefetchInterval() {\n      var _this$options$refetch;\n\n      return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;\n    }\n  }, {\n    key: \"updateRefetchInterval\",\n    value: function updateRefetchInterval(nextInterval) {\n      var _this6 = this;\n\n      this.clearRefetchInterval();\n      this.currentRefetchInterval = nextInterval;\n\n      if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {\n        return;\n      }\n\n      this.refetchIntervalId = setInterval(function () {\n        if (_this6.options.refetchIntervalInBackground || focusManager.isFocused()) {\n          _this6.executeFetch();\n        }\n      }, this.currentRefetchInterval);\n    }\n  }, {\n    key: \"updateTimers\",\n    value: function updateTimers() {\n      this.updateStaleTimeout();\n      this.updateRefetchInterval(this.computeRefetchInterval());\n    }\n  }, {\n    key: \"clearStaleTimeout\",\n    value: function clearStaleTimeout() {\n      if (this.staleTimeoutId) {\n        clearTimeout(this.staleTimeoutId);\n        this.staleTimeoutId = undefined;\n      }\n    }\n  }, {\n    key: \"clearRefetchInterval\",\n    value: function clearRefetchInterval() {\n      if (this.refetchIntervalId) {\n        clearInterval(this.refetchIntervalId);\n        this.refetchIntervalId = undefined;\n      }\n    }\n  }, {\n    key: \"createResult\",\n    value: function createResult(query, options) {\n      var prevQuery = this.currentQuery;\n      var prevOptions = this.options;\n      var prevResult = this.currentResult;\n      var prevResultState = this.currentResultState;\n      var prevResultOptions = this.currentResultOptions;\n      var queryChange = query !== prevQuery;\n      var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;\n      var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;\n      var state = query.state;\n      var dataUpdatedAt = state.dataUpdatedAt,\n          error = state.error,\n          errorUpdatedAt = state.errorUpdatedAt,\n          fetchStatus = state.fetchStatus,\n          status = state.status;\n      var isPreviousData = false;\n      var isPlaceholderData = false;\n      var data; // Optimistically set result in fetching state if needed\n\n      if (options._optimisticResults) {\n        var mounted = this.hasListeners();\n        var fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n        var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n\n        if (fetchOnMount || fetchOptionally) {\n          fetchStatus = canFetch(query.options.networkMode) ? 'fetching' : 'paused';\n\n          if (!dataUpdatedAt) {\n            status = 'loading';\n          }\n        }\n\n        if (options._optimisticResults === 'isRestoring') {\n          fetchStatus = 'idle';\n        }\n      } // Keep previous data if needed\n\n\n      if (options.keepPreviousData && !state.dataUpdateCount && prevQueryResult != null && prevQueryResult.isSuccess && status !== 'error') {\n        data = prevQueryResult.data;\n        dataUpdatedAt = prevQueryResult.dataUpdatedAt;\n        status = prevQueryResult.status;\n        isPreviousData = true;\n      } // Select data if needed\n      else if (options.select && typeof state.data !== 'undefined') {\n        // Memoize select result\n        if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {\n          data = this.selectResult;\n        } else {\n          try {\n            this.selectFn = options.select;\n            data = options.select(state.data);\n            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);\n            this.selectResult = data;\n            this.selectError = null;\n          } catch (selectError) {\n            if (process.env.NODE_ENV !== 'production') {\n              this.client.getLogger().error(selectError);\n            }\n\n            this.selectError = selectError;\n          }\n        }\n      } // Use query data\n      else {\n        data = state.data;\n      } // Show placeholder data if needed\n\n\n      if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && status === 'loading') {\n        var placeholderData; // Memoize placeholder data\n\n        if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {\n          placeholderData = prevResult.data;\n        } else {\n          placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;\n\n          if (options.select && typeof placeholderData !== 'undefined') {\n            try {\n              placeholderData = options.select(placeholderData);\n              placeholderData = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);\n              this.selectError = null;\n            } catch (selectError) {\n              if (process.env.NODE_ENV !== 'production') {\n                this.client.getLogger().error(selectError);\n              }\n\n              this.selectError = selectError;\n            }\n          }\n        }\n\n        if (typeof placeholderData !== 'undefined') {\n          status = 'success';\n          data = placeholderData;\n          isPlaceholderData = true;\n        }\n      }\n\n      if (this.selectError) {\n        error = this.selectError;\n        data = this.selectResult;\n        errorUpdatedAt = Date.now();\n        status = 'error';\n      }\n\n      var isFetching = fetchStatus === 'fetching';\n      var isLoading = status === 'loading';\n      var isError = status === 'error';\n      var result = {\n        status: status,\n        fetchStatus: fetchStatus,\n        isLoading: isLoading,\n        isSuccess: status === 'success',\n        isError: isError,\n        isInitialLoading: isLoading && isFetching,\n        data: data,\n        dataUpdatedAt: dataUpdatedAt,\n        error: error,\n        errorUpdatedAt: errorUpdatedAt,\n        failureCount: state.fetchFailureCount,\n        errorUpdateCount: state.errorUpdateCount,\n        isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n        isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,\n        isFetching: isFetching,\n        isRefetching: isFetching && !isLoading,\n        isLoadingError: isError && state.dataUpdatedAt === 0,\n        isPaused: fetchStatus === 'paused',\n        isPlaceholderData: isPlaceholderData,\n        isPreviousData: isPreviousData,\n        isRefetchError: isError && state.dataUpdatedAt !== 0,\n        isStale: isStale(query, options),\n        refetch: this.refetch,\n        remove: this.remove\n      };\n      return result;\n    }\n  }, {\n    key: \"updateResult\",\n    value: function updateResult(notifyOptions) {\n      var _this7 = this;\n\n      var prevResult = this.currentResult;\n      var nextResult = this.createResult(this.currentQuery, this.options);\n      this.currentResultState = this.currentQuery.state;\n      this.currentResultOptions = this.options; // Only notify and update result if something has changed\n\n      if (shallowEqualObjects(nextResult, prevResult)) {\n        return;\n      }\n\n      this.currentResult = nextResult; // Determine which callbacks to trigger\n\n      var defaultNotifyOptions = {\n        cache: true\n      };\n\n      var shouldNotifyListeners = function shouldNotifyListeners() {\n        if (!prevResult) {\n          return true;\n        }\n\n        var notifyOnChangeProps = _this7.options.notifyOnChangeProps;\n\n        if (notifyOnChangeProps === 'all' || !notifyOnChangeProps && !_this7.trackedProps.size) {\n          return true;\n        }\n\n        var includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : _this7.trackedProps);\n\n        if (_this7.options.useErrorBoundary) {\n          includedProps.add('error');\n        }\n\n        return Object.keys(_this7.currentResult).some(function (key) {\n          var typedKey = key;\n          var changed = _this7.currentResult[typedKey] !== prevResult[typedKey];\n          return changed && includedProps.has(typedKey);\n        });\n      };\n\n      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {\n        defaultNotifyOptions.listeners = true;\n      }\n\n      this.notify(_objectSpread(_objectSpread({}, defaultNotifyOptions), notifyOptions));\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery() {\n      var query = this.client.getQueryCache().build(this.client, this.options);\n\n      if (query === this.currentQuery) {\n        return;\n      }\n\n      var prevQuery = this.currentQuery;\n      this.currentQuery = query;\n      this.currentQueryInitialState = query.state;\n      this.previousQueryResult = this.currentResult;\n\n      if (this.hasListeners()) {\n        prevQuery == null ? void 0 : prevQuery.removeObserver(this);\n        query.addObserver(this);\n      }\n    }\n  }, {\n    key: \"onQueryUpdate\",\n    value: function onQueryUpdate(action) {\n      var notifyOptions = {};\n\n      if (action.type === 'success') {\n        notifyOptions.onSuccess = !action.manual;\n      } else if (action.type === 'error' && !isCancelledError(action.error)) {\n        notifyOptions.onError = true;\n      }\n\n      this.updateResult(notifyOptions);\n\n      if (this.hasListeners()) {\n        this.updateTimers();\n      }\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(notifyOptions) {\n      var _this8 = this;\n\n      notifyManager.batch(function () {\n        // First trigger the configuration callbacks\n        if (notifyOptions.onSuccess) {\n          var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;\n\n          (_this$options$onSucce = (_this$options = _this8.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, _this8.currentResult.data);\n          (_this$options$onSettl = (_this$options2 = _this8.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, _this8.currentResult.data, null);\n        } else if (notifyOptions.onError) {\n          var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;\n\n          (_this$options$onError = (_this$options3 = _this8.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, _this8.currentResult.error);\n          (_this$options$onSettl2 = (_this$options4 = _this8.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, undefined, _this8.currentResult.error);\n        } // Then trigger the listeners\n\n\n        if (notifyOptions.listeners) {\n          _this8.listeners.forEach(function (listener) {\n            listener(_this8.currentResult);\n          });\n        } // Then the cache listeners\n\n\n        if (notifyOptions.cache) {\n          _this8.client.getQueryCache().notify({\n            query: _this8.currentQuery,\n            type: 'observerResultsUpdated'\n          });\n        }\n      });\n    }\n  }]);\n\n  return QueryObserver;\n}(Subscribable);\n\nfunction shouldLoadOnMount(query, options) {\n  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);\n}\n\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\n\nfunction shouldFetchOn(query, options, field) {\n  if (options.enabled !== false) {\n    var value = typeof field === 'function' ? field(query) : field;\n    return value === 'always' || value !== false && isStale(query, options);\n  }\n\n  return false;\n}\n\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);\n}\n\nfunction isStale(query, options) {\n  return query.isStaleByTime(options.staleTime);\n}\n\nexport { QueryObserver }; //# sourceMappingURL=queryObserver.mjs.map","map":null,"metadata":{},"sourceType":"module"}