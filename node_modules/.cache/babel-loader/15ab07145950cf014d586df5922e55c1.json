{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectWithoutProperties from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _defineProperty from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"queryClient\", \"persister\"];\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister';\nimport { useQueryClient, useIsRestoring, useQueryErrorResetBoundary, notifyManager, InfiniteQueryObserver, QueryObserver, QueryClient, QueryClientProvider, useMutation } from '@tanstack/react-query';\nimport { persistQueryClient } from '@tanstack/react-query-persist-client';\nimport { watchProvider, getProvider, watchWebSocketProvider, getWebSocketProvider, fetchBlockNumber, fetchFeeData, deepEqual, watchSigner, fetchSigner, createClient as createClient$1, getAccount, watchAccount, fetchBalance, connect, disconnect, getNetwork, watchNetwork, signMessage, signTypedData, switchNetwork, getContract, readContracts, parseContractResult, readContract, writeContract, deprecatedWriteContract, prepareWriteContract, fetchToken, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, deprecatedSendTransaction, prepareSendTransaction, sendTransaction, fetchTransaction, waitForTransaction } from '@wagmi/core';\nexport { AddChainError, ChainDoesNotSupportMulticallError, ChainMismatchError, ChainNotConfiguredError, Client, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, ContractMethodDoesNotExistError, ContractMethodNoResultError, ContractMethodRevertedError, ContractResultDecodeError, ProviderChainsNotFound, ProviderRpcError, ResourceUnavailableError, RpcError, SwitchChainError, SwitchChainNotSupportedError, UserRejectedRequestError, alchemyRpcUrls, allChains, chain, chainId, configureChains, createStorage, deepEqual, defaultChains, defaultL2Chains, erc20ABI, erc721ABI, etherscanBlockExplorers, infuraRpcUrls, publicRpcUrls, readContracts } from '@wagmi/core';\nimport * as React from 'react';\nimport * as pkg from 'use-sync-external-store/shim/index.js';\nimport { BigNumber } from 'ethers/lib/ethers';\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js';\nimport { debounce } from '@wagmi/core/internal';\nvar useSyncExternalStore = pkg.useSyncExternalStore;\n\nfunction isQueryKey(value) {\n  return Array.isArray(value);\n}\n\nfunction parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return _objectSpread(_objectSpread({}, arg3), {}, {\n      queryKey: arg1,\n      queryFn: arg2\n    });\n  }\n\n  return _objectSpread(_objectSpread({}, arg2), {}, {\n    queryKey: arg1\n  });\n}\n\nfunction shouldThrowError(_useErrorBoundary, params) {\n  // Allow useErrorBoundary function to override throwing behavior on a per-error basis\n  if (typeof _useErrorBoundary === 'function') {\n    return _useErrorBoundary.apply(void 0, _toConsumableArray(params));\n  }\n\n  return !!_useErrorBoundary;\n}\n\nfunction trackResult(result, observer) {\n  var trackedResult = {};\n  Object.keys(result).forEach(function (key) {\n    Object.defineProperty(trackedResult, key, {\n      configurable: false,\n      enumerable: true,\n      get: function get() {\n        // @ts-expect-error â€“ aware we are mutating private `trackedProps` property.\n        observer.trackedProps.add(key);\n        return result[key];\n      }\n    });\n  });\n  return trackedResult;\n}\n\nfunction useBaseQuery(options, Observer) {\n  var queryClient = useQueryClient({\n    context: options.context\n  });\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  var _React$useState = React.useState(function () {\n    return new Observer(queryClient, defaultedOptions);\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 1),\n      observer = _React$useState2[0];\n\n  var result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return undefined;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var _defaultedOptions$onS, _defaultedOptions$onS2;\n\n      var data = _ref.data;\n      (_defaultedOptions$onS = defaultedOptions.onSuccess) === null || _defaultedOptions$onS === void 0 ? void 0 : _defaultedOptions$onS.call(defaultedOptions, data);\n      (_defaultedOptions$onS2 = defaultedOptions.onSettled) === null || _defaultedOptions$onS2 === void 0 ? void 0 : _defaultedOptions$onS2.call(defaultedOptions, data, null);\n    }).catch(function (error) {\n      var _defaultedOptions$onE, _defaultedOptions$onS3;\n\n      errorResetBoundary.clearReset();\n      (_defaultedOptions$onE = defaultedOptions.onError) === null || _defaultedOptions$onE === void 0 ? void 0 : _defaultedOptions$onE.call(defaultedOptions, error);\n      (_defaultedOptions$onS3 = defaultedOptions.onSettled) === null || _defaultedOptions$onS3 === void 0 ? void 0 : _defaultedOptions$onS3.call(defaultedOptions, undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  }\n\n  var status = result.status === 'loading' && result.fetchStatus === 'idle' ? 'idle' : result.status;\n  var isIdle = status === 'idle';\n  var isLoading = status === 'loading' && result.fetchStatus === 'fetching';\n  return _objectSpread(_objectSpread({}, result), {}, {\n    defaultedOptions: defaultedOptions,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    observer: observer,\n    status: status\n  });\n}\n\nfunction useInfiniteQuery(arg1, arg2, arg3) {\n  var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  var baseQuery = useBaseQuery(parsedOptions, InfiniteQueryObserver);\n  var result = {\n    data: baseQuery.data,\n    error: baseQuery.error,\n    fetchNextPage: baseQuery.fetchNextPage,\n    fetchStatus: baseQuery.fetchStatus,\n    hasNextPage: baseQuery.hasNextPage,\n    isError: baseQuery.isError,\n    isFetched: baseQuery.isFetched,\n    isFetching: baseQuery.isFetching,\n    isFetchingNextPage: baseQuery.isFetchingNextPage,\n    isIdle: baseQuery.isIdle,\n    isLoading: baseQuery.isLoading,\n    isRefetching: baseQuery.isRefetching,\n    isSuccess: baseQuery.isSuccess,\n    refetch: baseQuery.refetch,\n    status: baseQuery.status,\n    internal: {\n      dataUpdatedAt: baseQuery.dataUpdatedAt,\n      errorUpdatedAt: baseQuery.errorUpdatedAt,\n      failureCount: baseQuery.failureCount,\n      isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n      isLoadingError: baseQuery.isLoadingError,\n      isPaused: baseQuery.isPaused,\n      isPlaceholderData: baseQuery.isPlaceholderData,\n      isPreviousData: baseQuery.isPreviousData,\n      isRefetchError: baseQuery.isRefetchError,\n      isStale: baseQuery.isStale,\n      remove: baseQuery.remove\n    }\n  }; // Handle result property usage tracking\n\n  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;\n}\n\nfunction useQuery(arg1, arg2, arg3) {\n  var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n  var baseQuery = useBaseQuery(parsedOptions, QueryObserver);\n  var result = {\n    data: baseQuery.data,\n    error: baseQuery.error,\n    fetchStatus: baseQuery.fetchStatus,\n    isError: baseQuery.isError,\n    isFetched: baseQuery.isFetched,\n    isFetching: baseQuery.isFetching,\n    isIdle: baseQuery.isIdle,\n    isLoading: baseQuery.isLoading,\n    isRefetching: baseQuery.isRefetching,\n    isSuccess: baseQuery.isSuccess,\n    refetch: baseQuery.refetch,\n    status: baseQuery.status,\n    internal: {\n      dataUpdatedAt: baseQuery.dataUpdatedAt,\n      errorUpdatedAt: baseQuery.errorUpdatedAt,\n      failureCount: baseQuery.failureCount,\n      isFetchedAfterMount: baseQuery.isFetchedAfterMount,\n      isLoadingError: baseQuery.isLoadingError,\n      isPaused: baseQuery.isPaused,\n      isPlaceholderData: baseQuery.isPlaceholderData,\n      isPreviousData: baseQuery.isPreviousData,\n      isRefetchError: baseQuery.isRefetchError,\n      isStale: baseQuery.isStale,\n      remove: baseQuery.remove\n    }\n  }; // Handle result property usage tracking\n\n  return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;\n}\n\nfunction useProvider() {\n  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref7.chainId;\n\n  return useSyncExternalStoreWithSelector(function (cb) {\n    return watchProvider({\n      chainId: chainId\n    }, cb);\n  }, function () {\n    return getProvider({\n      chainId: chainId\n    });\n  }, function () {\n    return getProvider({\n      chainId: chainId\n    });\n  }, function (x) {\n    return x;\n  }, function (a, b) {\n    return a.network.chainId === b.network.chainId;\n  });\n}\n\nfunction useWebSocketProvider() {\n  var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref8.chainId;\n\n  return useSyncExternalStoreWithSelector(function (cb) {\n    return watchWebSocketProvider({\n      chainId: chainId\n    }, cb);\n  }, function () {\n    return getWebSocketProvider({\n      chainId: chainId\n    });\n  }, function () {\n    return getWebSocketProvider({\n      chainId: chainId\n    });\n  }, function (x) {\n    return x;\n  }, function (a, b) {\n    return (a === null || a === void 0 ? void 0 : a.network.chainId) === (b === null || b === void 0 ? void 0 : b.network.chainId);\n  });\n}\n\nfunction useChainId() {\n  var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref9.chainId;\n\n  var provider = useProvider({\n    chainId: chainId\n  });\n  return provider.network.chainId;\n}\n\nfunction useForceUpdate() {\n  var _React$useReducer = React.useReducer(function (x) {\n    return x + 1;\n  }, 0),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      forceUpdate = _React$useReducer2[1];\n\n  return forceUpdate;\n}\n\nvar queryKey$f = function queryKey$f(_ref) {\n  var chainId = _ref.chainId;\n  return [{\n    entity: 'blockNumber',\n    chainId: chainId\n  }];\n};\n\nvar queryFn$f = function queryFn$f(_ref2) {\n  var _ref2$queryKey = _slicedToArray(_ref2.queryKey, 1),\n      chainId = _ref2$queryKey[0].chainId;\n\n  return fetchBlockNumber({\n    chainId: chainId\n  });\n};\n\nfunction useBlockNumber() {\n  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref10$cacheTime = _ref10.cacheTime,\n      cacheTime = _ref10$cacheTime === void 0 ? 0 : _ref10$cacheTime,\n      chainId_ = _ref10.chainId,\n      _ref10$enabled = _ref10.enabled,\n      enabled = _ref10$enabled === void 0 ? true : _ref10$enabled,\n      staleTime = _ref10.staleTime,\n      suspense = _ref10.suspense,\n      _ref10$watch = _ref10.watch,\n      watch = _ref10$watch === void 0 ? false : _ref10$watch,\n      onBlock = _ref10.onBlock,\n      onError = _ref10.onError,\n      onSettled = _ref10.onSettled,\n      onSuccess = _ref10.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  var provider = useProvider({\n    chainId: chainId\n  });\n  var webSocketProvider = useWebSocketProvider({\n    chainId: chainId\n  });\n  var queryClient = useQueryClient();\n  React.useEffect(function () {\n    if (!watch && !onBlock) return; // We need to debounce the listener as we want to opt-out\n    // of the behavior where ethers emits a \"block\" event for\n    // every block that was missed in between the `pollingInterval`.\n    // We are setting a wait time of 1 as emitting an event in\n    // ethers takes ~0.1ms.\n\n    var listener = debounce(function (blockNumber) {\n      // Just to be safe in case the provider implementation\n      // calls the event callback after .off() has been called\n      if (watch) queryClient.setQueryData(queryKey$f({\n        chainId: chainId\n      }), blockNumber);\n      if (onBlock) onBlock(blockNumber);\n    }, 1);\n    var provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n    provider_.on('block', listener);\n    return function () {\n      provider_.off('block', listener);\n    };\n  }, [chainId, onBlock, provider, queryClient, watch, webSocketProvider]);\n  return useQuery(queryKey$f({\n    chainId: chainId\n  }), queryFn$f, {\n    cacheTime: cacheTime,\n    enabled: enabled,\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$e = function queryKey$e(_ref) {\n  var chainId = _ref.chainId,\n      formatUnits = _ref.formatUnits;\n  return [{\n    entity: 'feeData',\n    chainId: chainId,\n    formatUnits: formatUnits\n  }];\n};\n\nvar queryFn$e = function queryFn$e(_ref2) {\n  var _ref2$queryKey2 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey2$ = _ref2$queryKey2[0],\n      chainId = _ref2$queryKey2$.chainId,\n      formatUnits = _ref2$queryKey2$.formatUnits;\n\n  return fetchFeeData({\n    chainId: chainId,\n    formatUnits: formatUnits\n  });\n};\n\nfunction useFeeData() {\n  var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      cacheTime = _ref11.cacheTime,\n      chainId_ = _ref11.chainId,\n      _ref11$enabled = _ref11.enabled,\n      enabled = _ref11$enabled === void 0 ? true : _ref11$enabled,\n      _ref11$formatUnits = _ref11.formatUnits,\n      formatUnits = _ref11$formatUnits === void 0 ? 'wei' : _ref11$formatUnits,\n      staleTime = _ref11.staleTime,\n      suspense = _ref11.suspense,\n      watch = _ref11.watch,\n      onError = _ref11.onError,\n      onSettled = _ref11.onSettled,\n      onSuccess = _ref11.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  var feeDataQuery = useQuery(queryKey$e({\n    chainId: chainId,\n    formatUnits: formatUnits\n  }), queryFn$e, {\n    cacheTime: cacheTime,\n    enabled: enabled,\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n\n  var _useBlockNumber = useBlockNumber({\n    chainId: chainId,\n    watch: watch\n  }),\n      blockNumber = _useBlockNumber.data;\n\n  React.useEffect(function () {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    feeDataQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return feeDataQuery;\n}\n\nfunction useInvalidateOnBlock(_ref) {\n  var chainId = _ref.chainId,\n      enabled = _ref.enabled,\n      queryKey = _ref.queryKey;\n  var queryClient = useQueryClient();\n  useBlockNumber({\n    chainId: chainId,\n    onBlock: enabled ? function () {\n      return queryClient.invalidateQueries(queryKey);\n    } : undefined\n  });\n}\n\nvar isPlainObject = function isPlainObject(obj) {\n  return typeof obj === 'object' && !Array.isArray(obj);\n};\n\nfunction useSyncExternalStoreWithTracked(subscribe, getSnapshot) {\n  var getServerSnapshot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getSnapshot;\n  var isEqual = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (a, b) {\n    return deepEqual(a, b);\n  };\n  var trackedKeys = React.useRef([]);\n  var result = useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, function (x) {\n    return x;\n  }, function (a, b) {\n    if (isPlainObject(a) && isPlainObject(b)) {\n      var _iterator = _createForOfIteratorHelper(trackedKeys.current),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          var equal = isEqual(a[key], b[key]);\n          if (!equal) return false;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n\n    return isEqual(a, b);\n  });\n\n  if (isPlainObject(result)) {\n    var trackedResult = _objectSpread({}, result);\n\n    Object.defineProperties(trackedResult, Object.entries(trackedResult).reduce(function (res, _ref) {\n      var _ref12 = _slicedToArray(_ref, 2),\n          key = _ref12[0],\n          value = _ref12[1];\n\n      return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, key, {\n        configurable: false,\n        enumerable: true,\n        get: function get() {\n          if (!trackedKeys.current.includes(key)) {\n            trackedKeys.current.push(key);\n          }\n\n          return value;\n        }\n      }));\n    }, {}));\n    return trackedResult;\n  }\n\n  return result;\n}\n\nvar queryKey$d = function queryKey$d() {\n  return [{\n    entity: 'signer'\n  }];\n};\n\nvar queryFn$d = function queryFn$d() {\n  return fetchSigner();\n};\n\nfunction useSigner() {\n  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      suspense = _ref13.suspense,\n      onError = _ref13.onError,\n      onSettled = _ref13.onSettled,\n      onSuccess = _ref13.onSuccess;\n\n  var signerQuery = useQuery(queryKey$d(), queryFn$d, {\n    cacheTime: 0,\n    staleTime: 0,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n  var queryClient = useQueryClient();\n  React.useEffect(function () {\n    var unwatch = watchSigner(function (signer) {\n      return queryClient.setQueryData(queryKey$d(), signer);\n    });\n    return unwatch;\n  }, [queryClient]);\n  return signerQuery;\n}\n\nvar findAndReplace = function findAndReplace(cacheRef, _ref) {\n  var find = _ref.find,\n      replace = _ref.replace;\n\n  if (cacheRef && find(cacheRef)) {\n    return replace(cacheRef);\n  }\n\n  if (typeof cacheRef !== 'object') {\n    return cacheRef;\n  }\n\n  if (Array.isArray(cacheRef)) {\n    return cacheRef.map(function (item) {\n      return findAndReplace(item, {\n        find: find,\n        replace: replace\n      });\n    });\n  }\n\n  if (cacheRef instanceof Object) {\n    return Object.entries(cacheRef).reduce(function (curr, _ref2) {\n      var _ref14 = _slicedToArray(_ref2, 2),\n          key = _ref14[0],\n          value = _ref14[1];\n\n      return _objectSpread(_objectSpread({}, curr), {}, _defineProperty({}, key, findAndReplace(value, {\n        find: find,\n        replace: replace\n      })));\n    }, {});\n  }\n\n  return cacheRef;\n};\n\nfunction deserialize(cachedString) {\n  var cache = JSON.parse(cachedString);\n  var deserializedCacheWithBigNumbers = findAndReplace(cache, {\n    find: function find(data) {\n      return data.type === 'BigNumber';\n    },\n    replace: function replace(data) {\n      return BigNumber.from(data.hex);\n    }\n  });\n  return deserializedCacheWithBigNumbers;\n}\n/**\n * @function getReferenceKey\n *\n * @description\n * get the reference key for the circular value\n *\n * @param keys the keys to build the reference key from\n * @param cutoff the maximum number of keys to include\n * @returns the reference key\n */\n\n\nfunction getReferenceKey(keys, cutoff) {\n  return keys.slice(0, cutoff).join('.') || '.';\n}\n/**\n * @function getCutoff\n *\n * @description\n * faster `Array.prototype.indexOf` implementation build for slicing / splicing\n *\n * @param array the array to match the value in\n * @param value the value to match\n * @returns the matching index, or -1\n */\n\n\nfunction getCutoff(array, value) {\n  var length = array.length;\n\n  for (var index = 0; index < length; ++index) {\n    if (array[index] === value) {\n      return index + 1;\n    }\n  }\n\n  return 0;\n}\n/**\n * @function createReplacer\n *\n * @description\n * create a replacer method that handles circular values\n *\n * @param [replacer] a custom replacer to use for non-circular values\n * @param [circularReplacer] a custom replacer to use for circular methods\n * @returns the value to stringify\n */\n\n\nfunction createReplacer(replacer, circularReplacer) {\n  var hasReplacer = typeof replacer === 'function';\n  var hasCircularReplacer = typeof circularReplacer === 'function';\n  var cache = [];\n  var keys = [];\n  return function replace(key, value) {\n    if (typeof value === 'object') {\n      if (cache.length) {\n        var thisCutoff = getCutoff(cache, this);\n\n        if (thisCutoff === 0) {\n          cache[cache.length] = this;\n        } else {\n          cache.splice(thisCutoff);\n          keys.splice(thisCutoff);\n        }\n\n        keys[keys.length] = key;\n        var valueCutoff = getCutoff(cache, value);\n\n        if (valueCutoff !== 0) {\n          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : \"[ref=\".concat(getReferenceKey(keys, valueCutoff), \"]\");\n        }\n      } else {\n        cache[0] = value;\n        keys[0] = key;\n      }\n    }\n\n    return hasReplacer ? replacer.call(this, key, value) : value;\n  };\n}\n/**\n * @function stringify\n *\n * @description\n * stringifier that handles circular values\n * Forked from https://github.com/planttheidea/fast-stringify\n *\n * @param value to stringify\n * @param [replacer] a custom replacer function for handling standard values\n * @param [indent] the number of spaces to indent the output by\n * @param [circularReplacer] a custom replacer function for handling circular values\n * @returns the stringified output\n */\n\n\nfunction serialize(value, replacer, indent, circularReplacer) {\n  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent !== null && indent !== void 0 ? indent : undefined);\n}\n\nfunction createClient(_ref) {\n  var _ref$queryClient = _ref.queryClient,\n      queryClient = _ref$queryClient === void 0 ? new QueryClient({\n    defaultOptions: {\n      queries: {\n        cacheTime: 1000 * 60 * 60 * 24,\n        // 24 hours\n        networkMode: 'offlineFirst',\n        refetchOnWindowFocus: false,\n        retry: 0\n      },\n      mutations: {\n        networkMode: 'offlineFirst'\n      }\n    }\n  }) : _ref$queryClient,\n      _ref$persister = _ref.persister,\n      persister = _ref$persister === void 0 ? typeof window !== 'undefined' ? createSyncStoragePersister({\n    key: 'wagmi.cache',\n    storage: window.localStorage,\n    serialize: serialize,\n    deserialize: deserialize\n  }) : undefined : _ref$persister,\n      config = _objectWithoutProperties(_ref, _excluded);\n\n  var client = createClient$1(config);\n  if (persister) persistQueryClient({\n    queryClient: queryClient,\n    persister: persister,\n    dehydrateOptions: {\n      shouldDehydrateQuery: function shouldDehydrateQuery(query) {\n        return query.cacheTime !== 0 && query.queryHash !== JSON.stringify(queryKey$d());\n      }\n    }\n  });\n  return Object.assign(client, {\n    queryClient: queryClient\n  });\n}\n\nvar Context = /*#__PURE__*/React.createContext(undefined);\n\nfunction WagmiConfig(_ref) {\n  var children = _ref.children,\n      client = _ref.client;\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: client\n  }, /*#__PURE__*/React.createElement(QueryClientProvider, {\n    client: client.queryClient\n  }, children));\n}\n\nfunction useClient() {\n  var client = React.useContext(Context);\n  if (!client) throw new Error(['`useClient` must be used within `WagmiConfig`.\\n', 'Read more: https://wagmi.sh/docs/WagmiConfig'].join('\\n'));\n  return client;\n}\n\nfunction useAccount() {\n  var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      onConnect = _ref15.onConnect,\n      onDisconnect = _ref15.onDisconnect;\n\n  var account = useSyncExternalStoreWithTracked(watchAccount, getAccount);\n\n  var _useClient = useClient(),\n      subscribe = _useClient.subscribe;\n\n  React.useEffect(function () {\n    // No need to subscribe if these callbacks aren't defined\n    if (!onConnect && !onDisconnect) return; // Trigger update when status changes\n\n    var unsubscribe = subscribe(function (state) {\n      return state.status;\n    }, function (status, prevStatus) {\n      if (!!onConnect && status === 'connected') {\n        var _getAccount = getAccount(),\n            address = _getAccount.address,\n            connector = _getAccount.connector;\n\n        onConnect({\n          address: address,\n          connector: connector,\n          isReconnected: prevStatus === 'reconnecting'\n        });\n      }\n\n      if (!!onDisconnect && prevStatus !== 'connecting' && status === 'disconnected') onDisconnect();\n    });\n    return unsubscribe;\n  }, [onConnect, onDisconnect, subscribe]);\n  return account;\n}\n\nvar queryKey$c = function queryKey$c(_ref) {\n  var addressOrName = _ref.addressOrName,\n      chainId = _ref.chainId,\n      formatUnits = _ref.formatUnits,\n      token = _ref.token;\n  return [{\n    entity: 'balance',\n    addressOrName: addressOrName,\n    chainId: chainId,\n    formatUnits: formatUnits,\n    token: token\n  }];\n};\n\nvar queryFn$c = function queryFn$c(_ref2) {\n  var _ref2$queryKey3 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey3$ = _ref2$queryKey3[0],\n      addressOrName = _ref2$queryKey3$.addressOrName,\n      chainId = _ref2$queryKey3$.chainId,\n      formatUnits = _ref2$queryKey3$.formatUnits,\n      token = _ref2$queryKey3$.token;\n\n  if (!addressOrName) throw new Error('address is required');\n  return fetchBalance({\n    addressOrName: addressOrName,\n    chainId: chainId,\n    formatUnits: formatUnits,\n    token: token\n  });\n};\n\nfunction useBalance() {\n  var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      addressOrName = _ref16.addressOrName,\n      cacheTime = _ref16.cacheTime,\n      chainId_ = _ref16.chainId,\n      _ref16$enabled = _ref16.enabled,\n      enabled = _ref16$enabled === void 0 ? true : _ref16$enabled,\n      formatUnits = _ref16.formatUnits,\n      staleTime = _ref16.staleTime,\n      suspense = _ref16.suspense,\n      token = _ref16.token,\n      watch = _ref16.watch,\n      onError = _ref16.onError,\n      onSettled = _ref16.onSettled,\n      onSuccess = _ref16.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  var balanceQuery = useQuery(queryKey$c({\n    addressOrName: addressOrName,\n    chainId: chainId,\n    formatUnits: formatUnits,\n    token: token\n  }), queryFn$c, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && addressOrName),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n\n  var _useBlockNumber2 = useBlockNumber({\n    chainId: chainId,\n    watch: watch\n  }),\n      blockNumber = _useBlockNumber2.data;\n\n  React.useEffect(function () {\n    if (!enabled) return;\n    if (!watch) return;\n    if (!blockNumber) return;\n    if (!addressOrName) return;\n    balanceQuery.refetch(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [blockNumber]);\n  return balanceQuery;\n}\n\nvar mutationKey$8 = function mutationKey$8(args) {\n  return [_objectSpread({\n    entity: 'connect'\n  }, args)];\n};\n\nvar mutationFn$7 = function mutationFn$7(args) {\n  var connector = args.connector,\n      chainId = args.chainId;\n  if (!connector) throw new Error('connector is required');\n  return connect({\n    connector: connector,\n    chainId: chainId\n  });\n};\n\nfunction useConnect() {\n  var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref17.chainId,\n      connector = _ref17.connector,\n      onError = _ref17.onError,\n      onMutate = _ref17.onMutate,\n      onSettled = _ref17.onSettled,\n      onSuccess = _ref17.onSuccess;\n\n  var client = useClient();\n\n  var _useMutation = useMutation(mutationKey$8({\n    connector: connector,\n    chainId: chainId\n  }), mutationFn$7, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation.data,\n      error = _useMutation.error,\n      isError = _useMutation.isError,\n      isIdle = _useMutation.isIdle,\n      isLoading = _useMutation.isLoading,\n      isSuccess = _useMutation.isSuccess,\n      mutate = _useMutation.mutate,\n      mutateAsync = _useMutation.mutateAsync,\n      reset = _useMutation.reset,\n      status = _useMutation.status,\n      variables = _useMutation.variables;\n\n  var connect = React.useCallback(function (args) {\n    var _args$chainId, _args$connector;\n\n    return mutate({\n      chainId: (_args$chainId = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId !== void 0 ? _args$chainId : chainId,\n      connector: (_args$connector = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector !== void 0 ? _args$connector : connector\n    });\n  }, [chainId, connector, mutate]);\n  var connectAsync = React.useCallback(function (args) {\n    var _args$chainId2, _args$connector2;\n\n    return mutateAsync({\n      chainId: (_args$chainId2 = args === null || args === void 0 ? void 0 : args.chainId) !== null && _args$chainId2 !== void 0 ? _args$chainId2 : chainId,\n      connector: (_args$connector2 = args === null || args === void 0 ? void 0 : args.connector) !== null && _args$connector2 !== void 0 ? _args$connector2 : connector\n    });\n  }, [chainId, connector, mutateAsync]);\n  return {\n    connect: connect,\n    connectAsync: connectAsync,\n    connectors: client.connectors,\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    pendingConnector: variables === null || variables === void 0 ? void 0 : variables.connector,\n    reset: reset,\n    status: status,\n    variables: variables\n  };\n}\n\nvar mutationKey$7 = [{\n  entity: 'disconnect'\n}];\n\nvar mutationFn$6 = function mutationFn$6() {\n  return disconnect();\n};\n\nfunction useDisconnect() {\n  var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _onError = _ref18.onError,\n      onMutate = _ref18.onMutate,\n      _onSettled = _ref18.onSettled,\n      _onSuccess = _ref18.onSuccess;\n\n  var _useMutation2 = useMutation(mutationKey$7, mutationFn$6, _objectSpread(_objectSpread(_objectSpread({}, _onError ? {\n    onError: function onError(error, _variables, context) {\n      _onError(error, context);\n    }\n  } : {}), {}, {\n    onMutate: onMutate\n  }, _onSettled ? {\n    onSettled: function onSettled(_data, error, _variables, context) {\n      _onSettled(error, context);\n    }\n  } : {}), _onSuccess ? {\n    onSuccess: function onSuccess(_data, _variables, context) {\n      _onSuccess(context);\n    }\n  } : {})),\n      error = _useMutation2.error,\n      isError = _useMutation2.isError,\n      isIdle = _useMutation2.isIdle,\n      isLoading = _useMutation2.isLoading,\n      isSuccess = _useMutation2.isSuccess,\n      disconnect = _useMutation2.mutate,\n      disconnectAsync = _useMutation2.mutateAsync,\n      reset = _useMutation2.reset,\n      status = _useMutation2.status;\n\n  return {\n    disconnect: disconnect,\n    disconnectAsync: disconnectAsync,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    status: status\n  };\n}\n\nfunction useNetwork() {\n  return useSyncExternalStoreWithTracked(watchNetwork, getNetwork);\n}\n\nvar mutationKey$6 = function mutationKey$6(args) {\n  return [_objectSpread({\n    entity: 'signMessage'\n  }, args)];\n};\n\nvar mutationFn$5 = function mutationFn$5(args) {\n  var message = args.message;\n  if (!message) throw new Error('message is required');\n  return signMessage({\n    message: message\n  });\n};\n\nfunction useSignMessage() {\n  var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      message = _ref19.message,\n      onError = _ref19.onError,\n      onMutate = _ref19.onMutate,\n      onSettled = _ref19.onSettled,\n      onSuccess = _ref19.onSuccess;\n\n  var _useMutation3 = useMutation(mutationKey$6({\n    message: message\n  }), mutationFn$5, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation3.data,\n      error = _useMutation3.error,\n      isError = _useMutation3.isError,\n      isIdle = _useMutation3.isIdle,\n      isLoading = _useMutation3.isLoading,\n      isSuccess = _useMutation3.isSuccess,\n      mutate = _useMutation3.mutate,\n      mutateAsync = _useMutation3.mutateAsync,\n      reset = _useMutation3.reset,\n      status = _useMutation3.status,\n      variables = _useMutation3.variables;\n\n  var signMessage = React.useCallback(function (args) {\n    return mutate(args || {\n      message: message\n    });\n  }, [message, mutate]);\n  var signMessageAsync = React.useCallback(function (args) {\n    return mutateAsync(args || {\n      message: message\n    });\n  }, [message, mutateAsync]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    signMessage: signMessage,\n    signMessageAsync: signMessageAsync,\n    status: status,\n    variables: variables\n  };\n}\n\nvar mutationKey$5 = function mutationKey$5(args) {\n  return [_objectSpread({\n    entity: 'signTypedData'\n  }, args)];\n};\n\nvar mutationFn$4 = function mutationFn$4(args) {\n  var domain = args.domain,\n      types = args.types,\n      value = args.value;\n  if (!domain || !types || !value) throw new Error('domain, types, and value are all required');\n  return signTypedData({\n    domain: domain,\n    types: types,\n    value: value\n  });\n};\n\nfunction useSignTypedData() {\n  var _ref20 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      domain = _ref20.domain,\n      types = _ref20.types,\n      value = _ref20.value,\n      onError = _ref20.onError,\n      onMutate = _ref20.onMutate,\n      onSettled = _ref20.onSettled,\n      onSuccess = _ref20.onSuccess;\n\n  var _useMutation4 = useMutation(mutationKey$5({\n    domain: domain,\n    types: types,\n    value: value\n  }), mutationFn$4, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation4.data,\n      error = _useMutation4.error,\n      isError = _useMutation4.isError,\n      isIdle = _useMutation4.isIdle,\n      isLoading = _useMutation4.isLoading,\n      isSuccess = _useMutation4.isSuccess,\n      mutate = _useMutation4.mutate,\n      mutateAsync = _useMutation4.mutateAsync,\n      reset = _useMutation4.reset,\n      status = _useMutation4.status,\n      variables = _useMutation4.variables;\n\n  var signTypedData = React.useCallback(function (args) {\n    return mutate(args || {\n      domain: domain,\n      types: types,\n      value: value\n    });\n  }, [domain, types, value, mutate]);\n  var signTypedDataAsync = React.useCallback(function (args) {\n    return mutateAsync(args || {\n      domain: domain,\n      types: types,\n      value: value\n    });\n  }, [domain, types, value, mutateAsync]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    signTypedData: signTypedData,\n    signTypedDataAsync: signTypedDataAsync,\n    status: status,\n    variables: variables\n  };\n}\n\nvar mutationKey$4 = function mutationKey$4(args) {\n  return [_objectSpread({\n    entity: 'switchNetwork'\n  }, args)];\n};\n\nvar mutationFn$3 = function mutationFn$3(args) {\n  var chainId = args.chainId;\n  if (!chainId) throw new Error('chainId is required');\n  return switchNetwork({\n    chainId: chainId\n  });\n};\n\nfunction useSwitchNetwork() {\n  var _client$connector, _client$chains;\n\n  var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref21.chainId,\n      throwForSwitchChainNotSupported = _ref21.throwForSwitchChainNotSupported,\n      onError = _ref21.onError,\n      onMutate = _ref21.onMutate,\n      onSettled = _ref21.onSettled,\n      onSuccess = _ref21.onSuccess;\n\n  var client = useClient();\n  var forceUpdate = useForceUpdate();\n\n  var _useMutation5 = useMutation(mutationKey$4({\n    chainId: chainId\n  }), mutationFn$3, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation5.data,\n      error = _useMutation5.error,\n      isError = _useMutation5.isError,\n      isIdle = _useMutation5.isIdle,\n      isLoading = _useMutation5.isLoading,\n      isSuccess = _useMutation5.isSuccess,\n      mutate = _useMutation5.mutate,\n      mutateAsync = _useMutation5.mutateAsync,\n      reset = _useMutation5.reset,\n      status = _useMutation5.status,\n      variables = _useMutation5.variables;\n\n  var switchNetwork_ = React.useCallback(function (chainId_) {\n    return mutate({\n      chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n    });\n  }, [chainId, mutate]);\n  var switchNetworkAsync_ = React.useCallback(function (chainId_) {\n    return mutateAsync({\n      chainId: chainId_ !== null && chainId_ !== void 0 ? chainId_ : chainId\n    });\n  }, [chainId, mutateAsync]); // Trigger update when connector changes since not all connectors support chain switching\n\n  React.useEffect(function () {\n    var unwatch = client.subscribe(function (_ref) {\n      var chains = _ref.chains,\n          connector = _ref.connector;\n      return {\n        chains: chains,\n        connector: connector\n      };\n    }, forceUpdate);\n    return unwatch;\n  }, [client, forceUpdate]);\n  var switchNetwork;\n  var switchNetworkAsync;\n  var supportsSwitchChain = !!((_client$connector = client.connector) !== null && _client$connector !== void 0 && _client$connector.switchChain);\n\n  if (throwForSwitchChainNotSupported || supportsSwitchChain) {\n    switchNetwork = switchNetwork_;\n    switchNetworkAsync = switchNetworkAsync_;\n  }\n\n  return {\n    chains: (_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [],\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    pendingChainId: variables === null || variables === void 0 ? void 0 : variables.chainId,\n    reset: reset,\n    status: status,\n    switchNetwork: switchNetwork,\n    switchNetworkAsync: switchNetworkAsync,\n    variables: variables\n  };\n}\n\nvar useContract = function useContract(_ref) {\n  var addressOrName = _ref.addressOrName,\n      contractInterface = _ref.contractInterface,\n      signerOrProvider = _ref.signerOrProvider;\n  return React.useMemo(function () {\n    return getContract({\n      addressOrName: addressOrName,\n      contractInterface: contractInterface,\n      signerOrProvider: signerOrProvider\n    });\n  }, [addressOrName, contractInterface, signerOrProvider]);\n};\n\nvar useContractEvent = function useContractEvent(_ref) {\n  var _ref2;\n\n  var addressOrName = _ref.addressOrName,\n      chainId = _ref.chainId,\n      contractInterface = _ref.contractInterface,\n      listener = _ref.listener,\n      eventName = _ref.eventName,\n      signerOrProvider = _ref.signerOrProvider,\n      once = _ref.once;\n  var provider = useProvider({\n    chainId: chainId\n  });\n  var webSocketProvider = useWebSocketProvider({\n    chainId: chainId\n  });\n  var contract = useContract({\n    addressOrName: addressOrName,\n    contractInterface: contractInterface,\n    signerOrProvider: (_ref2 = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider) !== null && _ref2 !== void 0 ? _ref2 : signerOrProvider\n  });\n  var listenerRef = React.useRef(listener);\n  listenerRef.current = listener;\n  React.useEffect(function () {\n    var handler = function handler() {\n      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {\n        event[_key] = arguments[_key];\n      }\n\n      return listenerRef.current(event);\n    };\n\n    var contract_ = contract;\n    if (once) contract_.once(eventName, handler);else contract_.on(eventName, handler);\n    return function () {\n      contract_.off(eventName, handler);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contract, eventName]);\n};\n\nvar paginatedIndexesConfig = function paginatedIndexesConfig(fn, _ref) {\n  var perPage = _ref.perPage,\n      start = _ref.start,\n      direction = _ref.direction;\n  return {\n    getNextPageParam: function getNextPageParam(lastPage, pages) {\n      return (lastPage === null || lastPage === void 0 ? void 0 : lastPage.length) === perPage ? pages.length : undefined;\n    },\n    contracts: function contracts() {\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return _toConsumableArray(Array(perPage).keys()).map(function (index) {\n        return direction === 'increment' ? start + index + page * perPage : start - index - page * perPage;\n      }).filter(function (index) {\n        return index >= 0;\n      }).map(fn);\n    }\n  };\n};\n\nvar queryKey$b = function queryKey$b(_ref2) {\n  var _ref22 = _slicedToArray(_ref2, 1),\n      _ref22$ = _ref22[0],\n      cacheKey = _ref22$.cacheKey,\n      overrides = _ref22$.overrides;\n\n  return [{\n    entity: 'readContractsInfinite',\n    cacheKey: cacheKey,\n    overrides: overrides\n  }];\n};\n\nvar queryFn$b = function queryFn$b(_ref3) {\n  var contracts = _ref3.contracts;\n  return function (_ref4) {\n    var _ref4$queryKey = _slicedToArray(_ref4.queryKey, 1),\n        overrides = _ref4$queryKey[0].overrides,\n        pageParam = _ref4.pageParam;\n\n    return readContracts({\n      contracts: contracts(pageParam || undefined),\n      overrides: overrides\n    });\n  };\n};\n\nfunction useContractInfiniteReads(_ref5) {\n  var cacheKey = _ref5.cacheKey,\n      cacheTime = _ref5.cacheTime,\n      contracts = _ref5.contracts,\n      _ref5$enabled = _ref5.enabled,\n      enabled_ = _ref5$enabled === void 0 ? true : _ref5$enabled,\n      getNextPageParam = _ref5.getNextPageParam,\n      _ref5$isDataEqual = _ref5.isDataEqual,\n      isDataEqual = _ref5$isDataEqual === void 0 ? deepEqual : _ref5$isDataEqual,\n      keepPreviousData = _ref5.keepPreviousData,\n      onError = _ref5.onError,\n      onSettled = _ref5.onSettled,\n      onSuccess = _ref5.onSuccess,\n      overrides = _ref5.overrides,\n      select = _ref5.select,\n      staleTime = _ref5.staleTime,\n      suspense = _ref5.suspense;\n  var queryKey_ = React.useMemo(function () {\n    return queryKey$b([{\n      cacheKey: cacheKey,\n      overrides: overrides\n    }]);\n  }, [cacheKey, overrides]);\n  var enabled = React.useMemo(function () {\n    var enabled = Boolean(enabled_ && contracts);\n    return enabled;\n  }, [contracts, enabled_]);\n  return useInfiniteQuery(queryKey_, queryFn$b({\n    contracts: contracts\n  }), {\n    cacheTime: cacheTime,\n    enabled: enabled,\n    getNextPageParam: getNextPageParam,\n    isDataEqual: isDataEqual,\n    keepPreviousData: keepPreviousData,\n    select: select,\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$a = function queryKey$a(_ref) {\n  var _ref23 = _slicedToArray(_ref, 2),\n      _ref23$ = _ref23[0],\n      addressOrName = _ref23$.addressOrName,\n      args = _ref23$.args,\n      chainId = _ref23$.chainId,\n      functionName = _ref23$.functionName,\n      overrides = _ref23$.overrides,\n      blockNumber = _ref23[1].blockNumber;\n\n  return [{\n    entity: 'readContract',\n    addressOrName: addressOrName,\n    args: args,\n    blockNumber: blockNumber,\n    chainId: chainId,\n    functionName: functionName,\n    overrides: overrides\n  }];\n};\n\nvar queryFn$a = function queryFn$a(_ref2) {\n  var contractInterface = _ref2.contractInterface;\n  return /*#__PURE__*/function () {\n    var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref3) {\n      var _await$readContract, _ref3$queryKey, _ref3$queryKey$, addressOrName, args, chainId, functionName, overrides;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref3$queryKey = _slicedToArray(_ref3.queryKey, 1), _ref3$queryKey$ = _ref3$queryKey[0], addressOrName = _ref3$queryKey$.addressOrName, args = _ref3$queryKey$.args, chainId = _ref3$queryKey$.chainId, functionName = _ref3$queryKey$.functionName, overrides = _ref3$queryKey$.overrides;\n              _context.next = 3;\n              return readContract({\n                addressOrName: addressOrName,\n                args: args,\n                chainId: chainId,\n                contractInterface: contractInterface,\n                functionName: functionName,\n                overrides: overrides\n              });\n\n            case 3:\n              _context.t1 = _await$readContract = _context.sent;\n              _context.t0 = _context.t1 !== null;\n\n              if (!_context.t0) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.t0 = _await$readContract !== void 0;\n\n            case 7:\n              if (!_context.t0) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.t2 = _await$readContract;\n              _context.next = 12;\n              break;\n\n            case 11:\n              _context.t2 = null;\n\n            case 12:\n              return _context.abrupt(\"return\", _context.t2);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref24.apply(this, arguments);\n    };\n  }();\n};\n\nfunction useContractRead(_ref4) {\n  var addressOrName = _ref4.addressOrName,\n      contractInterface = _ref4.contractInterface,\n      functionName = _ref4.functionName,\n      args = _ref4.args,\n      chainId_ = _ref4.chainId,\n      overrides = _ref4.overrides,\n      _ref4$cacheOnBlock = _ref4.cacheOnBlock,\n      cacheOnBlock = _ref4$cacheOnBlock === void 0 ? false : _ref4$cacheOnBlock,\n      cacheTime = _ref4.cacheTime,\n      _ref4$enabled = _ref4.enabled,\n      enabled_ = _ref4$enabled === void 0 ? true : _ref4$enabled,\n      _ref4$isDataEqual = _ref4.isDataEqual,\n      isDataEqual = _ref4$isDataEqual === void 0 ? deepEqual : _ref4$isDataEqual,\n      _select = _ref4.select,\n      staleTime = _ref4.staleTime,\n      suspense = _ref4.suspense,\n      watch = _ref4.watch,\n      onError = _ref4.onError,\n      onSettled = _ref4.onSettled,\n      onSuccess = _ref4.onSuccess;\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n\n  var _useBlockNumber3 = useBlockNumber({\n    chainId: chainId,\n    enabled: watch || cacheOnBlock,\n    watch: watch\n  }),\n      blockNumber = _useBlockNumber3.data;\n\n  var queryKey_ = React.useMemo(function () {\n    return queryKey$a([{\n      addressOrName: addressOrName,\n      args: args,\n      chainId: chainId,\n      functionName: functionName,\n      overrides: overrides\n    }, {\n      blockNumber: cacheOnBlock ? blockNumber : undefined\n    }]);\n  }, [addressOrName, args, blockNumber, cacheOnBlock, chainId, functionName, overrides]);\n  var enabled = React.useMemo(function () {\n    var enabled = Boolean(enabled_ && addressOrName && functionName);\n    if (cacheOnBlock) enabled = Boolean(enabled && blockNumber);\n    return enabled;\n  }, [addressOrName, blockNumber, cacheOnBlock, enabled_, functionName]);\n  useInvalidateOnBlock({\n    chainId: chainId,\n    enabled: watch && !cacheOnBlock,\n    queryKey: queryKey_\n  });\n  return useQuery(queryKey_, queryFn$a({\n    contractInterface: contractInterface\n  }), {\n    cacheTime: cacheTime,\n    enabled: enabled,\n    isDataEqual: isDataEqual,\n    select: function select(data) {\n      var result = parseContractResult({\n        contractInterface: contractInterface,\n        data: data,\n        functionName: functionName\n      });\n      return _select ? _select(result) : result;\n    },\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$9 = function queryKey$9(_ref) {\n  var _ref25 = _slicedToArray(_ref, 2),\n      _ref25$ = _ref25[0],\n      allowFailure = _ref25$.allowFailure,\n      contracts = _ref25$.contracts,\n      overrides = _ref25$.overrides,\n      _ref25$2 = _ref25[1],\n      blockNumber = _ref25$2.blockNumber,\n      chainId = _ref25$2.chainId;\n\n  return [{\n    entity: 'readContracts',\n    allowFailure: allowFailure,\n    blockNumber: blockNumber,\n    chainId: chainId,\n    contracts: contracts.map(function (_ref2) {\n      var addressOrName = _ref2.addressOrName,\n          args = _ref2.args,\n          chainId = _ref2.chainId,\n          functionName = _ref2.functionName;\n      return {\n        addressOrName: addressOrName,\n        args: args,\n        chainId: chainId,\n        functionName: functionName\n      };\n    }),\n    overrides: overrides\n  }];\n};\n\nvar queryFn$9 = function queryFn$9(_ref3) {\n  var contractInterfaces = _ref3.contractInterfaces;\n  return function (_ref4) {\n    var _ref4$queryKey2 = _slicedToArray(_ref4.queryKey, 1),\n        _ref4$queryKey2$ = _ref4$queryKey2[0],\n        allowFailure = _ref4$queryKey2$.allowFailure,\n        contracts_ = _ref4$queryKey2$.contracts,\n        overrides = _ref4$queryKey2$.overrides;\n\n    var contracts = contracts_.map(function (contract, i) {\n      return _objectSpread(_objectSpread({}, contract), {}, {\n        contractInterface: contractInterfaces[i]\n      });\n    });\n    return readContracts({\n      allowFailure: allowFailure,\n      contracts: contracts,\n      overrides: overrides\n    });\n  };\n};\n\nfunction useContractReads(_ref5) {\n  var _ref5$allowFailure = _ref5.allowFailure,\n      allowFailure = _ref5$allowFailure === void 0 ? true : _ref5$allowFailure,\n      _ref5$cacheOnBlock = _ref5.cacheOnBlock,\n      cacheOnBlock = _ref5$cacheOnBlock === void 0 ? false : _ref5$cacheOnBlock,\n      cacheTime = _ref5.cacheTime,\n      contracts = _ref5.contracts,\n      overrides = _ref5.overrides,\n      _ref5$enabled2 = _ref5.enabled,\n      enabled_ = _ref5$enabled2 === void 0 ? true : _ref5$enabled2,\n      _ref5$isDataEqual2 = _ref5.isDataEqual,\n      isDataEqual = _ref5$isDataEqual2 === void 0 ? deepEqual : _ref5$isDataEqual2,\n      keepPreviousData = _ref5.keepPreviousData,\n      onError = _ref5.onError,\n      onSettled = _ref5.onSettled,\n      onSuccess = _ref5.onSuccess,\n      _select2 = _ref5.select,\n      staleTime = _ref5.staleTime,\n      suspense = _ref5.suspense,\n      watch = _ref5.watch;\n\n  var _useBlockNumber4 = useBlockNumber({\n    enabled: watch || cacheOnBlock,\n    watch: watch\n  }),\n      blockNumber = _useBlockNumber4.data;\n\n  var chainId = useChainId();\n  var queryKey_ = React.useMemo(function () {\n    return queryKey$9([{\n      allowFailure: allowFailure,\n      contracts: contracts,\n      overrides: overrides\n    }, {\n      blockNumber: cacheOnBlock ? blockNumber : undefined,\n      chainId: chainId\n    }]);\n  }, [allowFailure, blockNumber, cacheOnBlock, chainId, contracts, overrides]);\n  var contractInterfaces = contracts.map(function (_ref6) {\n    var contractInterface = _ref6.contractInterface;\n    return contractInterface;\n  });\n  var enabled = React.useMemo(function () {\n    var enabled = Boolean(enabled_ && contracts.length > 0);\n    if (cacheOnBlock) enabled = Boolean(enabled && blockNumber);\n    return enabled;\n  }, [blockNumber, cacheOnBlock, contracts, enabled_]);\n  useInvalidateOnBlock({\n    enabled: watch && !cacheOnBlock,\n    queryKey: queryKey_\n  });\n  return useQuery(queryKey_, queryFn$9({\n    contractInterfaces: contractInterfaces\n  }), {\n    cacheTime: cacheTime,\n    enabled: enabled,\n    isDataEqual: isDataEqual,\n    keepPreviousData: keepPreviousData,\n    staleTime: staleTime,\n    select: function select(data) {\n      var result = data.map(function (data, i) {\n        var _contracts$i, _contracts$i2;\n\n        return contracts[i] ? parseContractResult({\n          contractInterface: (_contracts$i = contracts[i]) === null || _contracts$i === void 0 ? void 0 : _contracts$i.contractInterface,\n          functionName: (_contracts$i2 = contracts[i]) === null || _contracts$i2 === void 0 ? void 0 : _contracts$i2.functionName,\n          data: data\n        }) : data;\n      });\n      return _select2 ? _select2(result) : result;\n    },\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar mutationKey$3 = function mutationKey$3(_ref) {\n  var _ref26 = _slicedToArray(_ref, 1),\n      _ref26$ = _ref26[0],\n      addressOrName = _ref26$.addressOrName,\n      args = _ref26$.args,\n      chainId = _ref26$.chainId,\n      contractInterface = _ref26$.contractInterface,\n      functionName = _ref26$.functionName,\n      overrides = _ref26$.overrides,\n      request = _ref26$.request;\n\n  return [{\n    entity: 'writeContract',\n    addressOrName: addressOrName,\n    args: args,\n    chainId: chainId,\n    contractInterface: contractInterface,\n    functionName: functionName,\n    overrides: overrides,\n    request: request\n  }];\n};\n\nvar mutationFn$2 = function mutationFn$2(_ref2) {\n  var addressOrName = _ref2.addressOrName,\n      args = _ref2.args,\n      chainId = _ref2.chainId,\n      contractInterface = _ref2.contractInterface,\n      functionName = _ref2.functionName,\n      mode = _ref2.mode,\n      overrides = _ref2.overrides,\n      request = _ref2.request;\n  return writeContract({\n    addressOrName: addressOrName,\n    args: args,\n    chainId: chainId,\n    contractInterface: contractInterface,\n    functionName: functionName,\n    mode: mode,\n    overrides: overrides,\n    request: request\n  });\n};\n/**\n * @description Hook for calling an ethers Contract [write](https://docs.ethers.io/v5/api/contract/contract/#Contract--write)\n * method.\n *\n * It is highly recommended to pair this with the [`usePrepareContractWrite` hook](/docs/prepare-hooks/usePrepareContractWrite)\n * to [avoid UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { useContractWrite, usePrepareContractWrite } from 'wagmi'\n *\n * const { config } = usePrepareContractWrite({\n *  addressOrName: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',\n *  contractInterface: wagmigotchiABI,\n *  functionName: 'feed',\n * })\n * const { data, isLoading, isSuccess, write } = useContractWrite(config)\n *\n */\n\n\nfunction useContractWrite(_ref3) {\n  var addressOrName = _ref3.addressOrName,\n      args = _ref3.args,\n      chainId = _ref3.chainId,\n      contractInterface = _ref3.contractInterface,\n      functionName = _ref3.functionName,\n      mode = _ref3.mode,\n      overrides = _ref3.overrides,\n      request = _ref3.request,\n      onError = _ref3.onError,\n      onMutate = _ref3.onMutate,\n      onSettled = _ref3.onSettled,\n      onSuccess = _ref3.onSuccess;\n\n  var _useMutation6 = useMutation(mutationKey$3([{\n    addressOrName: addressOrName,\n    contractInterface: contractInterface,\n    functionName: functionName,\n    args: args,\n    chainId: chainId,\n    mode: mode,\n    overrides: overrides,\n    request: request\n  }]), mutationFn$2, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation6.data,\n      error = _useMutation6.error,\n      isError = _useMutation6.isError,\n      isIdle = _useMutation6.isIdle,\n      isLoading = _useMutation6.isLoading,\n      isSuccess = _useMutation6.isSuccess,\n      mutate = _useMutation6.mutate,\n      mutateAsync = _useMutation6.mutateAsync,\n      reset = _useMutation6.reset,\n      status = _useMutation6.status,\n      variables = _useMutation6.variables;\n\n  var write = React.useCallback(function (overrideConfig) {\n    var _overrideConfig$reckl, _overrideConfig$reckl2;\n\n    return mutate({\n      addressOrName: addressOrName,\n      args: (_overrideConfig$reckl = overrideConfig === null || overrideConfig === void 0 ? void 0 : overrideConfig.recklesslySetUnpreparedArgs) !== null && _overrideConfig$reckl !== void 0 ? _overrideConfig$reckl : args,\n      chainId: chainId,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      mode: overrideConfig ? 'recklesslyUnprepared' : mode,\n      overrides: (_overrideConfig$reckl2 = overrideConfig === null || overrideConfig === void 0 ? void 0 : overrideConfig.recklesslySetUnpreparedOverrides) !== null && _overrideConfig$reckl2 !== void 0 ? _overrideConfig$reckl2 : overrides,\n      request: request\n    });\n  }, [addressOrName, args, chainId, contractInterface, functionName, mode, mutate, overrides, request]);\n  var writeAsync = React.useCallback(function (overrideConfig) {\n    var _overrideConfig$reckl3, _overrideConfig$reckl4;\n\n    return mutateAsync({\n      addressOrName: addressOrName,\n      args: (_overrideConfig$reckl3 = overrideConfig === null || overrideConfig === void 0 ? void 0 : overrideConfig.recklesslySetUnpreparedArgs) !== null && _overrideConfig$reckl3 !== void 0 ? _overrideConfig$reckl3 : args,\n      chainId: chainId,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      mode: overrideConfig ? 'recklesslyUnprepared' : mode,\n      overrides: (_overrideConfig$reckl4 = overrideConfig === null || overrideConfig === void 0 ? void 0 : overrideConfig.recklesslySetUnpreparedOverrides) !== null && _overrideConfig$reckl4 !== void 0 ? _overrideConfig$reckl4 : overrides,\n      request: request\n    });\n  }, [addressOrName, args, chainId, contractInterface, functionName, mode, mutateAsync, overrides, request]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    status: status,\n    variables: variables,\n    write: mode === 'prepared' && !request ? undefined : write,\n    writeAsync: mode === 'prepared' && !request ? undefined : writeAsync\n  };\n}\n\nvar mutationKey$2 = function mutationKey$2(_ref) {\n  var _ref27 = _slicedToArray(_ref, 1),\n      _ref27$ = _ref27[0],\n      addressOrName = _ref27$.addressOrName,\n      args = _ref27$.args,\n      chainId = _ref27$.chainId,\n      contractInterface = _ref27$.contractInterface,\n      overrides = _ref27$.overrides;\n\n  return [{\n    entity: 'writeContract',\n    addressOrName: addressOrName,\n    args: args,\n    chainId: chainId,\n    contractInterface: contractInterface,\n    overrides: overrides\n  }];\n};\n/** @deprecated */\n\n\nfunction useDeprecatedContractWrite(_ref2) {\n  var addressOrName = _ref2.addressOrName,\n      args = _ref2.args,\n      chainId = _ref2.chainId,\n      contractInterface = _ref2.contractInterface,\n      functionName = _ref2.functionName,\n      overrides = _ref2.overrides,\n      signerOrProvider = _ref2.signerOrProvider,\n      onError = _ref2.onError,\n      onMutate = _ref2.onMutate,\n      onSettled = _ref2.onSettled,\n      onSuccess = _ref2.onSuccess;\n\n  var _useMutation7 = useMutation(mutationKey$2([{\n    addressOrName: addressOrName,\n    args: args,\n    chainId: chainId,\n    contractInterface: contractInterface,\n    functionName: functionName,\n    overrides: overrides\n  }]), function (_ref3) {\n    var args = _ref3.args,\n        overrides = _ref3.overrides;\n    return deprecatedWriteContract({\n      addressOrName: addressOrName,\n      args: args,\n      chainId: chainId,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      overrides: overrides,\n      signerOrProvider: signerOrProvider\n    });\n  }, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation7.data,\n      error = _useMutation7.error,\n      isError = _useMutation7.isError,\n      isIdle = _useMutation7.isIdle,\n      isLoading = _useMutation7.isLoading,\n      isSuccess = _useMutation7.isSuccess,\n      mutate = _useMutation7.mutate,\n      mutateAsync = _useMutation7.mutateAsync,\n      reset = _useMutation7.reset,\n      status = _useMutation7.status,\n      variables = _useMutation7.variables;\n\n  var write = React.useCallback(function (overrideConfig) {\n    return mutate(_objectSpread({\n      addressOrName: addressOrName,\n      chainId: chainId,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      signerOrProvider: signerOrProvider\n    }, overrideConfig || {\n      args: args,\n      overrides: overrides\n    }));\n  }, [addressOrName, args, chainId, contractInterface, functionName, mutate, overrides, signerOrProvider]);\n  var writeAsync = React.useCallback(function (overrideConfig) {\n    return mutateAsync(_objectSpread({\n      addressOrName: addressOrName,\n      chainId: chainId,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      signerOrProvider: signerOrProvider\n    }, overrideConfig || {\n      args: args,\n      overrides: overrides\n    }));\n  }, [addressOrName, args, chainId, contractInterface, functionName, mutateAsync, overrides, signerOrProvider]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    status: status,\n    variables: variables,\n    write: write,\n    writeAsync: writeAsync\n  };\n}\n\nvar queryKey$8 = function queryKey$8(_ref, _ref2) {\n  var args = _ref.args,\n      addressOrName = _ref.addressOrName,\n      functionName = _ref.functionName,\n      overrides = _ref.overrides;\n  var chainId = _ref2.chainId,\n      signerAddress = _ref2.signerAddress;\n  return [{\n    entity: 'prepareContractTransaction',\n    addressOrName: addressOrName,\n    args: args,\n    chainId: chainId,\n    functionName: functionName,\n    overrides: overrides,\n    signerAddress: signerAddress\n  }];\n};\n\nvar queryFn$8 = function queryFn$8(_ref3) {\n  var contractInterface = _ref3.contractInterface,\n      signer = _ref3.signer;\n  return function (_ref4) {\n    var _ref4$queryKey3 = _slicedToArray(_ref4.queryKey, 1),\n        _ref4$queryKey3$ = _ref4$queryKey3[0],\n        args = _ref4$queryKey3$.args,\n        addressOrName = _ref4$queryKey3$.addressOrName,\n        functionName = _ref4$queryKey3$.functionName,\n        overrides = _ref4$queryKey3$.overrides;\n\n    return prepareWriteContract({\n      args: args,\n      addressOrName: addressOrName,\n      contractInterface: contractInterface,\n      functionName: functionName,\n      overrides: overrides,\n      signer: signer\n    });\n  };\n};\n/**\n * @description Hook for preparing a contract write to be sent via [`useContractWrite`](/docs/hooks/useContractWrite).\n *\n * Eagerly fetches the parameters required for sending a contract write transaction such as the gas estimate.\n *\n * @example\n * import { useContractWrite, usePrepareContractWrite } from 'wagmi'\n *\n * const { config } = usePrepareContractWrite({\n *  addressOrName: '0xecb504d39723b0be0e3a9aa33d646642d1051ee1',\n *  contractInterface: wagmigotchiABI,\n *  functionName: 'feed',\n * })\n * const { data, isLoading, isSuccess, write } = useContractWrite(config)\n *\n */\n\n\nfunction usePrepareContractWrite(_ref5) {\n  var addressOrName = _ref5.addressOrName,\n      contractInterface = _ref5.contractInterface,\n      functionName = _ref5.functionName,\n      args = _ref5.args,\n      overrides = _ref5.overrides,\n      cacheTime = _ref5.cacheTime,\n      _ref5$enabled3 = _ref5.enabled,\n      enabled = _ref5$enabled3 === void 0 ? true : _ref5$enabled3,\n      staleTime = _ref5.staleTime,\n      suspense = _ref5.suspense,\n      onError = _ref5.onError,\n      onSettled = _ref5.onSettled,\n      onSuccess = _ref5.onSuccess;\n  var chainId = useChainId();\n\n  var _useSigner = useSigner(),\n      signer = _useSigner.data;\n\n  var prepareContractWriteQuery = useQuery(queryKey$8({\n    addressOrName: addressOrName,\n    functionName: functionName,\n    args: args,\n    overrides: overrides\n  }, {\n    chainId: chainId,\n    signerAddress: signer === null || signer === void 0 ? void 0 : signer._address\n  }), queryFn$8({\n    contractInterface: contractInterface,\n    signer: signer\n  }), {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && signer),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n  return Object.assign(prepareContractWriteQuery, {\n    config: _objectSpread({\n      addressOrName: addressOrName,\n      args: args,\n      contractInterface: contractInterface,\n      overrides: overrides,\n      functionName: functionName,\n      request: undefined,\n      mode: 'prepared'\n    }, prepareContractWriteQuery.data)\n  });\n}\n\nvar queryKey$7 = function queryKey$7(_ref) {\n  var address = _ref.address,\n      chainId = _ref.chainId,\n      formatUnits = _ref.formatUnits;\n  return [{\n    entity: 'token',\n    address: address,\n    chainId: chainId,\n    formatUnits: formatUnits\n  }];\n};\n\nvar queryFn$7 = function queryFn$7(_ref2) {\n  var _ref2$queryKey4 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey4$ = _ref2$queryKey4[0],\n      address = _ref2$queryKey4$.address,\n      chainId = _ref2$queryKey4$.chainId,\n      formatUnits = _ref2$queryKey4$.formatUnits;\n\n  if (!address) throw new Error('address is required');\n  return fetchToken({\n    address: address,\n    chainId: chainId,\n    formatUnits: formatUnits\n  });\n};\n\nfunction useToken() {\n  var _ref28 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      address = _ref28.address,\n      chainId_ = _ref28.chainId,\n      _ref28$formatUnits = _ref28.formatUnits,\n      formatUnits = _ref28$formatUnits === void 0 ? 'ether' : _ref28$formatUnits,\n      cacheTime = _ref28.cacheTime,\n      _ref28$enabled = _ref28.enabled,\n      enabled = _ref28$enabled === void 0 ? true : _ref28$enabled,\n      _ref28$staleTime = _ref28.staleTime,\n      staleTime = _ref28$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref28$staleTime,\n      suspense = _ref28.suspense,\n      onError = _ref28.onError,\n      onSettled = _ref28.onSettled,\n      onSuccess = _ref28.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$7({\n    address: address,\n    chainId: chainId,\n    formatUnits: formatUnits\n  }), queryFn$7, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && address),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$6 = function queryKey$6(_ref) {\n  var chainId = _ref.chainId,\n      name = _ref.name;\n  return [{\n    entity: 'ensAddress',\n    chainId: chainId,\n    name: name\n  }];\n};\n\nvar queryFn$6 = function queryFn$6(_ref2) {\n  var _ref2$queryKey5 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey5$ = _ref2$queryKey5[0],\n      chainId = _ref2$queryKey5$.chainId,\n      name = _ref2$queryKey5$.name;\n\n  if (!name) throw new Error('name is required');\n  return fetchEnsAddress({\n    chainId: chainId,\n    name: name\n  });\n};\n\nfunction useEnsAddress() {\n  var _ref29 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      cacheTime = _ref29.cacheTime,\n      chainId_ = _ref29.chainId,\n      _ref29$enabled = _ref29.enabled,\n      enabled = _ref29$enabled === void 0 ? true : _ref29$enabled,\n      name = _ref29.name,\n      _ref29$staleTime = _ref29.staleTime,\n      staleTime = _ref29$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref29$staleTime,\n      suspense = _ref29.suspense,\n      onError = _ref29.onError,\n      onSettled = _ref29.onSettled,\n      onSuccess = _ref29.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$6({\n    chainId: chainId,\n    name: name\n  }), queryFn$6, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$5 = function queryKey$5(_ref) {\n  var addressOrName = _ref.addressOrName,\n      chainId = _ref.chainId;\n  return [{\n    entity: 'ensAvatar',\n    addressOrName: addressOrName,\n    chainId: chainId\n  }];\n};\n\nvar queryFn$5 = function queryFn$5(_ref2) {\n  var _ref2$queryKey6 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey6$ = _ref2$queryKey6[0],\n      addressOrName = _ref2$queryKey6$.addressOrName,\n      chainId = _ref2$queryKey6$.chainId;\n\n  if (!addressOrName) throw new Error('addressOrName is required');\n  return fetchEnsAvatar({\n    addressOrName: addressOrName,\n    chainId: chainId\n  });\n};\n\nfunction useEnsAvatar() {\n  var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      addressOrName = _ref30.addressOrName,\n      cacheTime = _ref30.cacheTime,\n      chainId_ = _ref30.chainId,\n      _ref30$enabled = _ref30.enabled,\n      enabled = _ref30$enabled === void 0 ? true : _ref30$enabled,\n      _ref30$staleTime = _ref30.staleTime,\n      staleTime = _ref30$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref30$staleTime,\n      suspense = _ref30.suspense,\n      onError = _ref30.onError,\n      onSettled = _ref30.onSettled,\n      onSuccess = _ref30.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$5({\n    addressOrName: addressOrName,\n    chainId: chainId\n  }), queryFn$5, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && addressOrName && chainId),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$4 = function queryKey$4(_ref) {\n  var address = _ref.address,\n      chainId = _ref.chainId;\n  return [{\n    entity: 'ensName',\n    address: address,\n    chainId: chainId\n  }];\n};\n\nvar queryFn$4 = function queryFn$4(_ref2) {\n  var _ref2$queryKey7 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey7$ = _ref2$queryKey7[0],\n      address = _ref2$queryKey7$.address,\n      chainId = _ref2$queryKey7$.chainId;\n\n  if (!address) throw new Error('address is required');\n  return fetchEnsName({\n    address: address,\n    chainId: chainId\n  });\n};\n\nfunction useEnsName() {\n  var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      address = _ref31.address,\n      cacheTime = _ref31.cacheTime,\n      chainId_ = _ref31.chainId,\n      _ref31$enabled = _ref31.enabled,\n      enabled = _ref31$enabled === void 0 ? true : _ref31$enabled,\n      _ref31$staleTime = _ref31.staleTime,\n      staleTime = _ref31$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref31$staleTime,\n      suspense = _ref31.suspense,\n      onError = _ref31.onError,\n      onSettled = _ref31.onSettled,\n      onSuccess = _ref31.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$4({\n    address: address,\n    chainId: chainId\n  }), queryFn$4, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && address && chainId),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey$3 = function queryKey$3(_ref) {\n  var chainId = _ref.chainId,\n      name = _ref.name;\n  return [{\n    entity: 'ensResolver',\n    chainId: chainId,\n    name: name\n  }];\n};\n\nvar queryFn$3 = function queryFn$3(_ref2) {\n  var _ref2$queryKey8 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey8$ = _ref2$queryKey8[0],\n      chainId = _ref2$queryKey8$.chainId,\n      name = _ref2$queryKey8$.name;\n\n  if (!name) throw new Error('name is required');\n  return fetchEnsResolver({\n    chainId: chainId,\n    name: name\n  });\n};\n\nfunction useEnsResolver() {\n  var _ref32 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      cacheTime = _ref32.cacheTime,\n      chainId_ = _ref32.chainId,\n      _ref32$enabled = _ref32.enabled,\n      enabled = _ref32$enabled === void 0 ? true : _ref32$enabled,\n      name = _ref32.name,\n      _ref32$staleTime = _ref32.staleTime,\n      staleTime = _ref32$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref32$staleTime,\n      suspense = _ref32.suspense,\n      onError = _ref32.onError,\n      onSettled = _ref32.onSettled,\n      onSuccess = _ref32.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$3({\n    chainId: chainId,\n    name: name\n  }), queryFn$3, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && chainId && name),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar mutationKey$1 = function mutationKey$1(args) {\n  return [_objectSpread({\n    entity: 'sendTransaction'\n  }, args)];\n};\n\nvar mutationFn$1 = function mutationFn$1(args) {\n  var chainId = args.chainId,\n      request = args.request;\n  if (!request) throw new Error('request is required');\n  return deprecatedSendTransaction({\n    chainId: chainId,\n    request: request\n  });\n};\n/** @deprecated */\n\n\nfunction useDeprecatedSendTransaction() {\n  var _ref33 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref33.chainId,\n      request = _ref33.request,\n      onError = _ref33.onError,\n      onMutate = _ref33.onMutate,\n      onSettled = _ref33.onSettled,\n      onSuccess = _ref33.onSuccess;\n\n  var _useMutation8 = useMutation(mutationKey$1({\n    chainId: chainId,\n    request: request\n  }), mutationFn$1, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation8.data,\n      error = _useMutation8.error,\n      isError = _useMutation8.isError,\n      isIdle = _useMutation8.isIdle,\n      isLoading = _useMutation8.isLoading,\n      isSuccess = _useMutation8.isSuccess,\n      mutate = _useMutation8.mutate,\n      mutateAsync = _useMutation8.mutateAsync,\n      reset = _useMutation8.reset,\n      status = _useMutation8.status,\n      variables = _useMutation8.variables;\n\n  var sendTransaction = React.useCallback(function (args) {\n    return mutate(_objectSpread({\n      chainId: chainId,\n      request: request\n    }, args !== null && args !== void 0 ? args : {}));\n  }, [chainId, mutate, request]);\n  var sendTransactionAsync = React.useCallback(function (args) {\n    return mutateAsync(_objectSpread({\n      chainId: chainId,\n      request: request\n    }, args !== null && args !== void 0 ? args : {}));\n  }, [chainId, mutateAsync, request]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    sendTransaction: sendTransaction,\n    sendTransactionAsync: sendTransactionAsync,\n    status: status,\n    variables: variables\n  };\n}\n\nvar queryKey$2 = function queryKey$2(_ref) {\n  var chainId = _ref.chainId,\n      request = _ref.request;\n  return [{\n    entity: 'prepareSendTransaction',\n    chainId: chainId,\n    request: request\n  }];\n};\n\nvar queryFn$2 = function queryFn$2(_ref2) {\n  var _ref2$queryKey9 = _slicedToArray(_ref2.queryKey, 1),\n      request = _ref2$queryKey9[0].request;\n\n  if (!request.to) throw new Error('request.to is required');\n  return prepareSendTransaction({\n    request: _objectSpread(_objectSpread({}, request), {}, {\n      to: request.to\n    })\n  });\n};\n/**\n * @description Hook for preparing a transaction to be sent via [`useSendTransaction`](/docs/hooks/useSendTransaction).\n *\n * Eagerly fetches the parameters required for sending a transaction such as the gas estimate and resolving an ENS address (if required).\n *\n * @example\n * import { useSendTransaction, usePrepareSendTransaction } from 'wagmi'\n *\n * const config = usePrepareSendTransaction({\n *   to: 'moxey.eth',\n *   value: parseEther('1'),\n * })\n * const result = useSendTransaction(config)\n */\n\n\nfunction usePrepareSendTransaction(_ref3) {\n  var request = _ref3.request,\n      cacheTime = _ref3.cacheTime,\n      _ref3$enabled = _ref3.enabled,\n      enabled = _ref3$enabled === void 0 ? true : _ref3$enabled,\n      _ref3$staleTime = _ref3.staleTime,\n      staleTime = _ref3$staleTime === void 0 ? 1000 * 60 * 60 * 24 : _ref3$staleTime,\n      suspense = _ref3.suspense,\n      onError = _ref3.onError,\n      onSettled = _ref3.onSettled,\n      onSuccess = _ref3.onSuccess;\n  var chainId = useChainId();\n  var provider = useProvider();\n  var prepareSendTransactionQuery = useQuery(queryKey$2({\n    request: request,\n    chainId: chainId\n  }), queryFn$2, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && provider && request.to),\n    isDataEqual: deepEqual,\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n  return Object.assign(prepareSendTransactionQuery, {\n    config: _objectSpread({\n      request: undefined,\n      mode: 'prepared'\n    }, prepareSendTransactionQuery.data)\n  });\n}\n\nvar mutationKey = function mutationKey(args) {\n  return [_objectSpread({\n    entity: 'sendTransaction'\n  }, args)];\n};\n\nvar mutationFn = function mutationFn(_ref) {\n  var chainId = _ref.chainId,\n      mode = _ref.mode,\n      request = _ref.request;\n  return sendTransaction({\n    chainId: chainId,\n    mode: mode,\n    request: request\n  });\n};\n/**\n * @description Hook for sending a transaction.\n *\n * It is recommended to pair this with the [`usePrepareSendTransaction` hook](/docs/prepare-hooks/usePrepareSendTransaction)\n * to [avoid UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { useSendTransaction, usePrepareSendTransaction } from 'wagmi'\n *\n * const config = usePrepareSendTransaction({\n *   request: {\n *     to: 'moxey.eth',\n *     value: parseEther('1'),\n *   }\n * })\n * const result = useSendTransaction(config)\n */\n\n\nfunction useSendTransaction(_ref2) {\n  var chainId = _ref2.chainId,\n      mode = _ref2.mode,\n      request = _ref2.request,\n      onError = _ref2.onError,\n      onMutate = _ref2.onMutate,\n      onSettled = _ref2.onSettled,\n      onSuccess = _ref2.onSuccess;\n\n  var _useMutation9 = useMutation(mutationKey({\n    chainId: chainId,\n    mode: mode,\n    request: request\n  }), mutationFn, {\n    onError: onError,\n    onMutate: onMutate,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  }),\n      data = _useMutation9.data,\n      error = _useMutation9.error,\n      isError = _useMutation9.isError,\n      isIdle = _useMutation9.isIdle,\n      isLoading = _useMutation9.isLoading,\n      isSuccess = _useMutation9.isSuccess,\n      mutate = _useMutation9.mutate,\n      mutateAsync = _useMutation9.mutateAsync,\n      reset = _useMutation9.reset,\n      status = _useMutation9.status,\n      variables = _useMutation9.variables;\n\n  var sendTransaction = React.useCallback(function (args) {\n    var _args$recklesslySetUn;\n\n    return mutate({\n      chainId: chainId,\n      mode: mode,\n      request: (_args$recklesslySetUn = args === null || args === void 0 ? void 0 : args.recklesslySetUnpreparedRequest) !== null && _args$recklesslySetUn !== void 0 ? _args$recklesslySetUn : request\n    });\n  }, [chainId, mode, mutate, request]);\n  var sendTransactionAsync = React.useCallback(function (args) {\n    var _args$recklesslySetUn2;\n\n    return mutateAsync({\n      chainId: chainId,\n      mode: mode,\n      request: (_args$recklesslySetUn2 = args === null || args === void 0 ? void 0 : args.recklesslySetUnpreparedRequest) !== null && _args$recklesslySetUn2 !== void 0 ? _args$recklesslySetUn2 : request\n    });\n  }, [chainId, mode, mutateAsync, request]);\n  return {\n    data: data,\n    error: error,\n    isError: isError,\n    isIdle: isIdle,\n    isLoading: isLoading,\n    isSuccess: isSuccess,\n    reset: reset,\n    sendTransaction: mode === 'prepared' && !request ? undefined : sendTransaction,\n    sendTransactionAsync: mode === 'prepared' && !request ? undefined : sendTransactionAsync,\n    status: status,\n    variables: variables\n  };\n}\n\nvar queryKey$1 = function queryKey$1(_ref) {\n  var chainId = _ref.chainId,\n      hash = _ref.hash;\n  return [{\n    entity: 'transaction',\n    chainId: chainId,\n    hash: hash\n  }];\n};\n\nvar queryFn$1 = function queryFn$1(_ref2) {\n  var _ref2$queryKey10 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey10$ = _ref2$queryKey10[0],\n      chainId = _ref2$queryKey10$.chainId,\n      hash = _ref2$queryKey10$.hash;\n\n  if (!hash) throw new Error('hash is required');\n  return fetchTransaction({\n    chainId: chainId,\n    hash: hash\n  });\n};\n/**\n * @description Fetches transaction for hash\n *\n * @example\n * import { useTransaction } from 'wagmi'\n *\n * const result = useTransaction({\n *  chainId: 1,\n *  hash: '0x...',\n * })\n */\n\n\nfunction useTransaction() {\n  var _ref34 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref34$cacheTime = _ref34.cacheTime,\n      cacheTime = _ref34$cacheTime === void 0 ? 0 : _ref34$cacheTime,\n      chainId_ = _ref34.chainId,\n      _ref34$enabled = _ref34.enabled,\n      enabled = _ref34$enabled === void 0 ? true : _ref34$enabled,\n      hash = _ref34.hash,\n      staleTime = _ref34.staleTime,\n      suspense = _ref34.suspense,\n      onError = _ref34.onError,\n      onSettled = _ref34.onSettled,\n      onSuccess = _ref34.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey$1({\n    chainId: chainId,\n    hash: hash\n  }), queryFn$1, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && hash),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nvar queryKey = function queryKey(_ref) {\n  var confirmations = _ref.confirmations,\n      chainId = _ref.chainId,\n      hash = _ref.hash,\n      timeout = _ref.timeout,\n      wait = _ref.wait;\n  return [{\n    entity: 'waitForTransaction',\n    confirmations: confirmations,\n    chainId: chainId,\n    hash: hash,\n    timeout: timeout,\n    wait: wait\n  }];\n};\n\nvar queryFn = function queryFn(_ref2) {\n  var _ref2$queryKey11 = _slicedToArray(_ref2.queryKey, 1),\n      _ref2$queryKey11$ = _ref2$queryKey11[0],\n      chainId = _ref2$queryKey11$.chainId,\n      confirmations = _ref2$queryKey11$.confirmations,\n      hash = _ref2$queryKey11$.hash,\n      timeout = _ref2$queryKey11$.timeout,\n      wait = _ref2$queryKey11$.wait;\n\n  return waitForTransaction({\n    chainId: chainId,\n    confirmations: confirmations,\n    hash: hash,\n    timeout: timeout,\n    wait: wait\n  });\n};\n\nfunction useWaitForTransaction() {\n  var _ref35 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId_ = _ref35.chainId,\n      confirmations = _ref35.confirmations,\n      hash = _ref35.hash,\n      timeout = _ref35.timeout,\n      wait = _ref35.wait,\n      cacheTime = _ref35.cacheTime,\n      _ref35$enabled = _ref35.enabled,\n      enabled = _ref35$enabled === void 0 ? true : _ref35$enabled,\n      staleTime = _ref35.staleTime,\n      suspense = _ref35.suspense,\n      onError = _ref35.onError,\n      onSettled = _ref35.onSettled,\n      onSuccess = _ref35.onSuccess;\n\n  var chainId = useChainId({\n    chainId: chainId_\n  });\n  return useQuery(queryKey({\n    chainId: chainId,\n    confirmations: confirmations,\n    hash: hash,\n    timeout: timeout,\n    wait: wait\n  }), queryFn, {\n    cacheTime: cacheTime,\n    enabled: Boolean(enabled && (hash || wait)),\n    staleTime: staleTime,\n    suspense: suspense,\n    onError: onError,\n    onSettled: onSettled,\n    onSuccess: onSuccess\n  });\n}\n\nexport { Context, WagmiConfig, createClient, deserialize, paginatedIndexesConfig, serialize, useAccount, useBalance, useBlockNumber, useClient, useConnect, useContract, useContractEvent, useContractInfiniteReads, useContractRead, useContractReads, useContractWrite, useDeprecatedContractWrite, useDeprecatedSendTransaction, useDisconnect, useEnsAddress, useEnsAvatar, useEnsName, useEnsResolver, useFeeData, useInfiniteQuery, useNetwork, usePrepareContractWrite, usePrepareSendTransaction, useProvider, useQuery, useSendTransaction, useSignMessage, useSignTypedData, useSigner, useSwitchNetwork, useToken, useTransaction, useWaitForTransaction, useWebSocketProvider };","map":null,"metadata":{},"sourceType":"module"}