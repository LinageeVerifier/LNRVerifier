{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { Removable } from './removable.mjs';\nimport { createRetryer, canFetch } from './retryer.mjs'; // CLASS\n\nvar Mutation = /*#__PURE__*/function (_Removable) {\n  _inherits(Mutation, _Removable);\n\n  var _super = _createSuper(Mutation);\n\n  function Mutation(config) {\n    var _this;\n\n    _classCallCheck(this, Mutation);\n\n    _this = _super.call(this);\n    _this.options = _objectSpread(_objectSpread({}, config.defaultOptions), config.options);\n    _this.mutationId = config.mutationId;\n    _this.mutationCache = config.mutationCache;\n    _this.logger = config.logger || defaultLogger;\n    _this.observers = [];\n    _this.state = config.state || getDefaultState();\n    _this.meta = config.meta;\n\n    _this.updateCacheTime(_this.options.cacheTime);\n\n    _this.scheduleGc();\n\n    return _this;\n  }\n\n  _createClass(Mutation, [{\n    key: \"setState\",\n    value: function setState(state) {\n      this.dispatch({\n        type: 'setState',\n        state: state\n      });\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      if (this.observers.indexOf(observer) === -1) {\n        this.observers.push(observer); // Stop the mutation from being garbage collected\n\n        this.clearGcTimeout();\n        this.mutationCache.notify({\n          type: 'observerAdded',\n          mutation: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      this.observers = this.observers.filter(function (x) {\n        return x !== observer;\n      });\n      this.scheduleGc();\n      this.mutationCache.notify({\n        type: 'observerRemoved',\n        mutation: this,\n        observer: observer\n      });\n    }\n  }, {\n    key: \"optionalRemove\",\n    value: function optionalRemove() {\n      if (!this.observers.length) {\n        if (this.state.status === 'loading') {\n          this.scheduleGc();\n        } else {\n          this.mutationCache.remove(this);\n        }\n      }\n    }\n  }, {\n    key: \"continue\",\n    value: function _continue() {\n      if (this.retryer) {\n        this.retryer.continue();\n        return this.retryer.promise;\n      }\n\n      return this.execute();\n    }\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var executeMutation, restored, _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$options$onSettl, _this$options3, _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options, context, data, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onError, _this$options4, _this$options$onSettl2, _this$options5;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                executeMutation = function executeMutation() {\n                  var _this$options$retry;\n\n                  _this2.retryer = createRetryer({\n                    fn: function fn() {\n                      if (!_this2.options.mutationFn) {\n                        return Promise.reject('No mutationFn found');\n                      }\n\n                      return _this2.options.mutationFn(_this2.state.variables);\n                    },\n                    onFail: function onFail() {\n                      _this2.dispatch({\n                        type: 'failed'\n                      });\n                    },\n                    onPause: function onPause() {\n                      _this2.dispatch({\n                        type: 'pause'\n                      });\n                    },\n                    onContinue: function onContinue() {\n                      _this2.dispatch({\n                        type: 'continue'\n                      });\n                    },\n                    retry: (_this$options$retry = _this2.options.retry) != null ? _this$options$retry : 0,\n                    retryDelay: _this2.options.retryDelay,\n                    networkMode: _this2.options.networkMode\n                  });\n                  return _this2.retryer.promise;\n                };\n\n                restored = this.state.status === 'loading';\n                _context.prev = 2;\n\n                if (restored) {\n                  _context.next = 10;\n                  break;\n                }\n\n                this.dispatch({\n                  type: 'loading',\n                  variables: this.options.variables\n                }); // Notify cache callback\n\n                (_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this);\n                _context.next = 8;\n                return (_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables);\n\n              case 8:\n                context = _context.sent;\n\n                if (context !== this.state.context) {\n                  this.dispatch({\n                    type: 'loading',\n                    context: context,\n                    variables: this.state.variables\n                  });\n                }\n\n              case 10:\n                _context.next = 12;\n                return executeMutation();\n\n              case 12:\n                data = _context.sent;\n                // Notify cache callback\n                (_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this);\n                _context.next = 16;\n                return (_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context);\n\n              case 16:\n                _context.next = 18;\n                return (_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context);\n\n              case 18:\n                this.dispatch({\n                  type: 'success',\n                  data: data\n                });\n                return _context.abrupt(\"return\", data);\n\n              case 22:\n                _context.prev = 22;\n                _context.t0 = _context[\"catch\"](2);\n                _context.prev = 24;\n                // Notify cache callback\n                (_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, _context.t0, this.state.variables, this.state.context, this);\n\n                if (process.env.NODE_ENV !== 'production') {\n                  this.logger.error(_context.t0);\n                }\n\n                _context.next = 29;\n                return (_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, _context.t0, this.state.variables, this.state.context);\n\n              case 29:\n                _context.next = 31;\n                return (_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, undefined, _context.t0, this.state.variables, this.state.context);\n\n              case 31:\n                throw _context.t0;\n\n              case 32:\n                _context.prev = 32;\n                this.dispatch({\n                  type: 'error',\n                  error: _context.t0\n                });\n                return _context.finish(32);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 22], [24,, 32, 35]]);\n      }));\n\n      function execute() {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      var _this3 = this;\n\n      var reducer = function reducer(state) {\n        switch (action.type) {\n          case 'failed':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              failureCount: state.failureCount + 1\n            });\n\n          case 'pause':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isPaused: true\n            });\n\n          case 'continue':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isPaused: false\n            });\n\n          case 'loading':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              context: action.context,\n              data: undefined,\n              error: null,\n              isPaused: !canFetch(_this3.options.networkMode),\n              status: 'loading',\n              variables: action.variables\n            });\n\n          case 'success':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              data: action.data,\n              error: null,\n              status: 'success',\n              isPaused: false\n            });\n\n          case 'error':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              data: undefined,\n              error: action.error,\n              failureCount: state.failureCount + 1,\n              isPaused: false,\n              status: 'error'\n            });\n\n          case 'setState':\n            return _objectSpread(_objectSpread({}, state), action.state);\n        }\n      };\n\n      this.state = reducer(this.state);\n      notifyManager.batch(function () {\n        _this3.observers.forEach(function (observer) {\n          observer.onMutationUpdate(action);\n        });\n\n        _this3.mutationCache.notify({\n          mutation: _this3,\n          type: 'updated',\n          action: action\n        });\n      });\n    }\n  }]);\n\n  return Mutation;\n}(Removable);\n\nfunction getDefaultState() {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined\n  };\n}\n\nexport { Mutation, getDefaultState }; //# sourceMappingURL=mutation.mjs.map","map":null,"metadata":{},"sourceType":"module"}