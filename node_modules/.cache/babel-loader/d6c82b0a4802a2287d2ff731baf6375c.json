{"ast":null,"code":"import _defineProperty from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectWithoutProperties from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _toConsumableArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar _excluded = [\"addressOrName\", \"contractInterface\", \"functionName\"];\nimport { g as getClient, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, b as ChainMismatchError, U as UserRejectedRequestError, c as ContractMethodDoesNotExistError, d as getProvider, P as ProviderChainsNotFound, e as ChainDoesNotSupportMulticallError, f as ContractMethodRevertedError, h as ContractMethodNoResultError, i as ContractResultDecodeError, n as normalizeChainId, S as SwitchChainNotSupportedError } from './getProvider-f1dfc7e3.esm.js';\nexport { A as AddChainError, e as ChainDoesNotSupportMulticallError, b as ChainMismatchError, m as ChainNotConfiguredError, k as Client, l as Connector, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, c as ContractMethodDoesNotExistError, h as ContractMethodNoResultError, f as ContractMethodRevertedError, i as ContractResultDecodeError, I as InjectedConnector, P as ProviderChainsNotFound, o as ProviderRpcError, R as ResourceUnavailableError, p as RpcError, q as SwitchChainError, S as SwitchChainNotSupportedError, U as UserRejectedRequestError, j as createClient, r as createStorage, d as getProvider, s as noopStorage, n as normalizeChainId } from './getProvider-f1dfc7e3.esm.js';\nimport { providers, Contract as Contract$1 } from 'ethers';\nimport { Contract, logger } from 'ethers/lib/ethers';\nimport { FormatTypes, formatUnits, getAddress, isAddress, Logger } from 'ethers/lib/utils';\nimport { m as mainnet } from './chains-8c76af1b.esm.js';\nexport { a as allChains, c as chain, b as chainId, d as defaultChains, e as defaultL2Chains, f as etherscanBlockExplorers } from './chains-8c76af1b.esm.js';\nimport shallow from 'zustand/shallow';\nimport { d as debounce } from './debounce-0862bf88.esm.js';\nexport { a as alchemyRpcUrls, i as infuraRpcUrls, p as publicRpcUrls } from './rpcs-8d636858.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\n\nfunction configureChains(defaultChains, providers) {\n  var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref5$minQuorum = _ref5.minQuorum,\n      minQuorum = _ref5$minQuorum === void 0 ? 1 : _ref5$minQuorum,\n      _ref5$pollingInterval = _ref5.pollingInterval,\n      pollingInterval = _ref5$pollingInterval === void 0 ? 4000 : _ref5$pollingInterval,\n      _ref5$targetQuorum = _ref5.targetQuorum,\n      targetQuorum = _ref5$targetQuorum === void 0 ? 1 : _ref5$targetQuorum,\n      stallTimeout = _ref5.stallTimeout;\n\n  if (!defaultChains.length) throw new Error('must have at least one chain');\n  if (targetQuorum < minQuorum) throw new Error('quorum cannot be lower than minQuorum');\n  var chains = [];\n  var providers_ = {};\n  var webSocketProviders_ = {};\n\n  var _iterator = _createForOfIteratorHelper(defaultChains),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var chain = _step.value;\n      var configExists = false;\n\n      var _iterator2 = _createForOfIteratorHelper(providers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var provider = _step2.value;\n          var apiConfig = provider(chain); // If no API configuration was found (ie. no RPC URL) for\n          // this provider, then we skip and check the next one.\n\n          if (!apiConfig) continue;\n          configExists = true;\n\n          if (!chains.some(function (_ref) {\n            var id = _ref.id;\n            return id === chain.id;\n          })) {\n            chains = [].concat(_toConsumableArray(chains), [apiConfig.chain]);\n          }\n\n          providers_[chain.id] = [].concat(_toConsumableArray(providers_[chain.id] || []), [apiConfig.provider]);\n\n          if (apiConfig.webSocketProvider) {\n            webSocketProviders_[chain.id] = [].concat(_toConsumableArray(webSocketProviders_[chain.id] || []), [apiConfig.webSocketProvider]);\n          }\n        } // If no API configuration was found across the providers\n        // then we throw an error to the consumer.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (!configExists) {\n        throw new Error([\"Could not find valid provider configuration for chain \\\"\".concat(chain.name, \"\\\".\\n\"), \"You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.\", 'Read more: https://wagmi.sh/docs/providers/jsonRpc'].join('\\n'));\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    chains: chains,\n    provider: function provider(_ref2) {\n      var _defaultChains$;\n\n      var chainId = _ref2.chainId;\n      var activeChainId = chainId && chains.some(function (x) {\n        return x.id === chainId;\n      }) ? chainId : (_defaultChains$ = defaultChains[0]) === null || _defaultChains$ === void 0 ? void 0 : _defaultChains$.id;\n      var chainProviders = providers_[activeChainId];\n      if (!chainProviders || !chainProviders[0]) throw new Error(\"No providers configured for chain \\\"\".concat(activeChainId, \"\\\"\"));\n\n      if (chainProviders.length === 1) {\n        return Object.assign(chainProviders[0](), {\n          chains: chains,\n          pollingInterval: pollingInterval\n        });\n      }\n\n      return Object.assign(fallbackProvider(targetQuorum, minQuorum, chainProviders, {\n        stallTimeout: stallTimeout\n      }), {\n        chains: chains,\n        pollingInterval: pollingInterval\n      });\n    },\n    webSocketProvider: function webSocketProvider(_ref3) {\n      var _defaultChains$2, _chainWebSocketProvid;\n\n      var chainId = _ref3.chainId;\n      var activeChainId = chainId && chains.some(function (x) {\n        return x.id === chainId;\n      }) ? chainId : (_defaultChains$2 = defaultChains[0]) === null || _defaultChains$2 === void 0 ? void 0 : _defaultChains$2.id;\n      var chainWebSocketProviders = webSocketProviders_[activeChainId];\n      if (!chainWebSocketProviders) return undefined; // WebSockets do not work with `fallbackProvider`\n      // Default to first available\n\n      return Object.assign(((_chainWebSocketProvid = chainWebSocketProviders[0]) === null || _chainWebSocketProvid === void 0 ? void 0 : _chainWebSocketProvid.call(chainWebSocketProviders)) || {}, {\n        chains: chains\n      });\n    }\n  };\n}\n\nfunction fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {\n  var stallTimeout = _ref4.stallTimeout;\n\n  try {\n    return new providers.FallbackProvider(providers_.map(function (chainProvider, index) {\n      var _provider$priority, _provider$stallTimeou;\n\n      var provider = chainProvider();\n      return {\n        provider: provider,\n        priority: (_provider$priority = provider.priority) !== null && _provider$priority !== void 0 ? _provider$priority : index,\n        stallTimeout: (_provider$stallTimeou = provider.stallTimeout) !== null && _provider$stallTimeou !== void 0 ? _provider$stallTimeou : stallTimeout,\n        weight: provider.weight\n      };\n    }), targetQuorum);\n  } catch (error) {\n    var _error$message;\n\n    if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('quorum will always fail; larger than total weight')) {\n      if (targetQuorum === minQuorum) throw error;\n      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {\n        stallTimeout: stallTimeout\n      });\n    }\n\n    throw error;\n  }\n}\n/** Forked from https://github.com/epoberezkin/fast-deep-equal */\n\n\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length;\n    var i;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    var keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n\n\n  return a !== a && b !== b;\n}\n\nfunction logWarn(message) {\n  var _getClient, _getClient$config$log, _getClient$config$log2;\n\n  (_getClient = getClient()) === null || _getClient === void 0 ? void 0 : (_getClient$config$log = _getClient.config.logger) === null || _getClient$config$log === void 0 ? void 0 : (_getClient$config$log2 = _getClient$config$log.warn) === null || _getClient$config$log2 === void 0 ? void 0 : _getClient$config$log2.call(_getClient$config$log, message);\n}\n\nfunction minimizeContractInterface(_ref) {\n  var contractInterface = _ref.contractInterface,\n      functionName = _ref.functionName;\n  var abi = Contract.getInterface(contractInterface).format(FormatTypes.full);\n  var minimizedInterface = Array.isArray(abi) ? abi : [abi];\n  return minimizedInterface.filter(function (i) {\n    return i.includes(functionName);\n  });\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\n\nfunction parseContractResult(_ref) {\n  var contractInterface = _ref.contractInterface,\n      data = _ref.data,\n      functionName = _ref.functionName;\n\n  if (data && isPlainArray(data)) {\n    var _fragment$outputs;\n\n    var iface = Contract.getInterface(contractInterface);\n    var fragment = iface.getFunction(functionName);\n    var isTuple = (((_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : _fragment$outputs.length) || 0) > 1;\n    var data_ = isTuple ? data : [data];\n    var encodedResult = iface.encodeFunctionResult(functionName, data_);\n    var decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isTuple ? decodedResult : decodedResult[0];\n  }\n\n  return data;\n} // https://ethereum.org/en/developers/docs/standards/tokens/erc-20\n\n\nvar erc20ABI = ['event Approval(address indexed _owner, address indexed _spender, uint256 _value)', 'event Transfer(address indexed _from, address indexed _to, uint256 _value)', 'function allowance(address _owner, address _spender) public view returns (uint256 remaining)', 'function approve(address _spender, uint256 _value) public returns (bool success)', 'function balanceOf(address _owner) public view returns (uint256 balance)', 'function decimals() public view returns (uint8)', 'function name() public view returns (string)', 'function symbol() public view returns (string)', 'function totalSupply() public view returns (uint256)', 'function transfer(address _to, uint256 _value) public returns (bool success)', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)']; // https://ethereum.org/en/developers/docs/standards/tokens/erc-721\n\nvar erc721ABI = ['event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId)', 'event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)', 'event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)', 'function approve(address _approved, uint256 _tokenId) external payable', 'function balanceOf(address _owner) external view returns (uint256)', 'function getApproved(uint256 _tokenId) external view returns (address)', 'function isApprovedForAll(address _owner, address _operator) external view returns (bool)', 'function name() view returns (string memory)', 'function ownerOf(uint256 _tokenId) external view returns (address)', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable', 'function setApprovalForAll(address _operator, bool _approved) external', 'function symbol() view returns (string memory)', 'function tokenByIndex(uint256 _index) view returns (uint256)', 'function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256 tokenId)', 'function tokenURI(uint256 _tokenId) view returns (string memory)', 'function totalSupply() view returns (uint256)', 'function transferFrom(address _from, address _to, uint256 _tokenId) external payable'];\nvar multicallInterface = [{\n  inputs: [{\n    components: [{\n      internalType: 'address',\n      name: 'target',\n      type: 'address'\n    }, {\n      internalType: 'bool',\n      name: 'allowFailure',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'callData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Call3[]',\n    name: 'calls',\n    type: 'tuple[]'\n  }],\n  name: 'aggregate3',\n  outputs: [{\n    components: [{\n      internalType: 'bool',\n      name: 'success',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'returnData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Result[]',\n    name: 'returnData',\n    type: 'tuple[]'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}]; // https://github.com/ethers-io/ethers.js/blob/master/packages/units/src.ts/index.ts#L10-L18\n\nvar units = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];\n\nfunction connect(_x) {\n  return _connect.apply(this, arguments);\n}\n\nfunction _connect() {\n  _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_ref) {\n    var chainId, connector, client, activeConnector, data;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            chainId = _ref.chainId, connector = _ref.connector;\n            client = getClient();\n            activeConnector = client.connector;\n\n            if (!(connector.id === (activeConnector === null || activeConnector === void 0 ? void 0 : activeConnector.id))) {\n              _context8.next = 5;\n              break;\n            }\n\n            throw new ConnectorAlreadyConnectedError();\n\n          case 5:\n            _context8.prev = 5;\n            client.setState(function (x) {\n              return _objectSpread(_objectSpread({}, x), {}, {\n                status: 'connecting'\n              });\n            });\n            _context8.next = 9;\n            return connector.connect({\n              chainId: chainId\n            });\n\n          case 9:\n            data = _context8.sent;\n            client.setLastUsedConnector(connector.id);\n            client.setState(function (x) {\n              return _objectSpread(_objectSpread({}, x), {}, {\n                connector: connector,\n                chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n                data: data,\n                status: 'connected'\n              });\n            });\n            client.storage.setItem('connected', true);\n            return _context8.abrupt(\"return\", _objectSpread(_objectSpread({}, data), {}, {\n              connector: connector\n            }));\n\n          case 16:\n            _context8.prev = 16;\n            _context8.t0 = _context8[\"catch\"](5);\n            client.setState(function (x) {\n              return _objectSpread(_objectSpread({}, x), {}, {\n                // Keep existing connector connected in case of error\n                status: x.connector ? 'connected' : 'disconnected'\n              });\n            });\n            throw _context8.t0;\n\n          case 20:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[5, 16]]);\n  }));\n  return _connect.apply(this, arguments);\n}\n\nfunction disconnect() {\n  return _disconnect.apply(this, arguments);\n}\n\nfunction _disconnect() {\n  _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n    var client;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            client = getClient();\n\n            if (!client.connector) {\n              _context9.next = 4;\n              break;\n            }\n\n            _context9.next = 4;\n            return client.connector.disconnect();\n\n          case 4:\n            client.clearState();\n            client.storage.removeItem('connected');\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _disconnect.apply(this, arguments);\n}\n\nfunction getContract(_ref) {\n  var addressOrName = _ref.addressOrName,\n      contractInterface = _ref.contractInterface,\n      signerOrProvider = _ref.signerOrProvider;\n  return new Contract$1(addressOrName, contractInterface, signerOrProvider);\n}\n\nfunction deprecatedWriteContract(_x2) {\n  return _deprecatedWriteContract.apply(this, arguments);\n}\n\nfunction _deprecatedWriteContract() {\n  _deprecatedWriteContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref) {\n    var addressOrName, args, chainId, contractInterface, functionName, overrides, signerOrProvider, _getClient3, connector, params, _chain, chain, activeChainId, _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4, signer, contract, contractWithSigner, contractFunction;\n\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, args = _ref.args, chainId = _ref.chainId, contractInterface = _ref.contractInterface, functionName = _ref.functionName, overrides = _ref.overrides, signerOrProvider = _ref.signerOrProvider;\n            _getClient3 = getClient(), connector = _getClient3.connector;\n\n            if (connector) {\n              _context10.next = 4;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 4:\n            params = [].concat(_toConsumableArray(Array.isArray(args) ? args : args ? [args] : []), _toConsumableArray(overrides ? [overrides] : []));\n            _context10.prev = 5;\n\n            if (!chainId) {\n              _context10.next = 18;\n              break;\n            }\n\n            _context10.next = 9;\n            return connector.getChainId();\n\n          case 9:\n            activeChainId = _context10.sent;\n\n            if (!(chainId !== activeChainId)) {\n              _context10.next = 18;\n              break;\n            }\n\n            if (!connector.switchChain) {\n              _context10.next = 17;\n              break;\n            }\n\n            _context10.next = 14;\n            return connector.switchChain(chainId);\n\n          case 14:\n            chain = _context10.sent;\n            _context10.next = 18;\n            break;\n\n          case 17:\n            throw new ChainMismatchError({\n              activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(function (x) {\n                return x.id === activeChainId;\n              })) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n              targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(function (x) {\n                return x.id === chainId;\n              })) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n            });\n\n          case 18:\n            _context10.next = 20;\n            return connector.getSigner({\n              chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n            });\n\n          case 20:\n            signer = _context10.sent;\n            contract = getContract({\n              addressOrName: addressOrName,\n              contractInterface: contractInterface,\n              signerOrProvider: signerOrProvider\n            });\n            contractWithSigner = contract.connect(signer);\n            contractFunction = contractWithSigner[functionName];\n            if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" does not exist in interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n            _context10.next = 27;\n            return contractFunction.apply(void 0, _toConsumableArray(params));\n\n          case 27:\n            return _context10.abrupt(\"return\", _context10.sent);\n\n          case 30:\n            _context10.prev = 30;\n            _context10.t0 = _context10[\"catch\"](5);\n\n            if (!(_context10.t0.code === 4001)) {\n              _context10.next = 34;\n              break;\n            }\n\n            throw new UserRejectedRequestError(_context10.t0);\n\n          case 34:\n            throw _context10.t0;\n\n          case 35:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[5, 30]]);\n  }));\n  return _deprecatedWriteContract.apply(this, arguments);\n}\n\nfunction fetchToken(_x3) {\n  return _fetchToken.apply(this, arguments);\n}\n/**\n * @description Prepares the parameters required for a contract write transaction.\n *\n * Returns config to be passed through to `writeContract`.\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *  addressOrName: '0x...',\n *  contractInterface: wagmiAbi,\n *  functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\n\n\nfunction _fetchToken() {\n  _fetchToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref) {\n    var address, chainId, _ref$formatUnits, units, erc20Config, _yield$readContracts, _yield$readContracts2, decimals, name, symbol, totalSupply;\n\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            address = _ref.address, chainId = _ref.chainId, _ref$formatUnits = _ref.formatUnits, units = _ref$formatUnits === void 0 ? 'ether' : _ref$formatUnits;\n            erc20Config = {\n              addressOrName: address,\n              contractInterface: erc20ABI,\n              chainId: chainId\n            };\n            _context11.next = 4;\n            return readContracts({\n              allowFailure: false,\n              contracts: [_objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'decimals'\n              }), _objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'name'\n              }), _objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'symbol'\n              }), _objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'totalSupply'\n              })]\n            });\n\n          case 4:\n            _yield$readContracts = _context11.sent;\n            _yield$readContracts2 = _slicedToArray(_yield$readContracts, 4);\n            decimals = _yield$readContracts2[0];\n            name = _yield$readContracts2[1];\n            symbol = _yield$readContracts2[2];\n            totalSupply = _yield$readContracts2[3];\n            return _context11.abrupt(\"return\", {\n              address: address,\n              decimals: decimals,\n              name: name,\n              symbol: symbol,\n              totalSupply: {\n                formatted: formatUnits(totalSupply, units),\n                value: totalSupply\n              }\n            });\n\n          case 11:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _fetchToken.apply(this, arguments);\n}\n\nfunction prepareWriteContract(_x4) {\n  return _prepareWriteContract.apply(this, arguments);\n}\n\nfunction _prepareWriteContract() {\n  _prepareWriteContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref) {\n    var addressOrName, args, chainId, contractInterface_, functionName, overrides, signer_, signer, contract, populateTransactionFn, contractInterface, params, unsignedTransaction, gasLimit;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, args = _ref.args, chainId = _ref.chainId, contractInterface_ = _ref.contractInterface, functionName = _ref.functionName, overrides = _ref.overrides, signer_ = _ref.signer;\n\n            if (!(signer_ !== null && signer_ !== void 0)) {\n              _context12.next = 5;\n              break;\n            }\n\n            _context12.t0 = signer_;\n            _context12.next = 8;\n            break;\n\n          case 5:\n            _context12.next = 7;\n            return fetchSigner();\n\n          case 7:\n            _context12.t0 = _context12.sent;\n\n          case 8:\n            signer = _context12.t0;\n\n            if (signer) {\n              _context12.next = 11;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 11:\n            contract = getContract({\n              addressOrName: addressOrName,\n              contractInterface: contractInterface_,\n              signerOrProvider: signer\n            });\n            populateTransactionFn = contract.populateTransaction[functionName];\n\n            if (populateTransactionFn) {\n              _context12.next = 15;\n              break;\n            }\n\n            throw new ContractMethodDoesNotExistError({\n              addressOrName: addressOrName,\n              functionName: functionName\n            });\n\n          case 15:\n            contractInterface = minimizeContractInterface({\n              contractInterface: contract.interface,\n              functionName: functionName\n            });\n            params = [].concat(_toConsumableArray(Array.isArray(args) ? args : args ? [args] : []), _toConsumableArray(overrides ? [overrides] : []));\n            _context12.next = 19;\n            return populateTransactionFn.apply(void 0, _toConsumableArray(params));\n\n          case 19:\n            unsignedTransaction = _context12.sent;\n            _context12.t1 = unsignedTransaction.gasLimit;\n\n            if (_context12.t1) {\n              _context12.next = 25;\n              break;\n            }\n\n            _context12.next = 24;\n            return signer.estimateGas(unsignedTransaction);\n\n          case 24:\n            _context12.t1 = _context12.sent;\n\n          case 25:\n            gasLimit = _context12.t1;\n            return _context12.abrupt(\"return\", _objectSpread(_objectSpread({\n              addressOrName: addressOrName,\n              args: args\n            }, chainId ? {\n              chainId: chainId\n            } : {}), {}, {\n              contractInterface: contractInterface,\n              functionName: functionName,\n              overrides: overrides,\n              request: _objectSpread(_objectSpread({}, unsignedTransaction), {}, {\n                gasLimit: gasLimit\n              }),\n              mode: 'prepared'\n            }));\n\n          case 27:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return _prepareWriteContract.apply(this, arguments);\n}\n\nfunction getWebSocketProvider() {\n  var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref6.chainId;\n\n  var client = getClient();\n  if (chainId) return client.getWebSocketProvider({\n    chainId: chainId\n  }) || client.webSocketProvider;\n  return client.webSocketProvider;\n}\n\nfunction watchProvider(args, callback) {\n  var client = getClient();\n\n  var handleChange = /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", callback(getProvider(args)));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function handleChange() {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n\n  var unsubscribe = client.subscribe(function (_ref) {\n    var provider = _ref.provider;\n    return provider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nfunction watchWebSocketProvider(args, callback) {\n  var client = getClient();\n\n  var handleChange = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", callback(getWebSocketProvider(args)));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function handleChange() {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n\n  var unsubscribe = client.subscribe(function (_ref) {\n    var webSocketProvider = _ref.webSocketProvider;\n    return webSocketProvider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nfunction readContract(_x5) {\n  return _readContract.apply(this, arguments);\n}\n\nfunction _readContract() {\n  _readContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref) {\n    var addressOrName, args, chainId, contractInterface, functionName, overrides, provider, contract, params, contractFunction, response;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, args = _ref.args, chainId = _ref.chainId, contractInterface = _ref.contractInterface, functionName = _ref.functionName, overrides = _ref.overrides;\n            provider = getProvider({\n              chainId: chainId\n            });\n            contract = getContract({\n              addressOrName: addressOrName,\n              contractInterface: contractInterface,\n              signerOrProvider: provider\n            });\n            params = [].concat(_toConsumableArray(Array.isArray(args) ? args : args ? [args] : []), _toConsumableArray(overrides ? [overrides] : []));\n            contractFunction = contract[functionName];\n            if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n            _context13.next = 8;\n            return contractFunction === null || contractFunction === void 0 ? void 0 : contractFunction.apply(void 0, _toConsumableArray(params));\n\n          case 8:\n            response = _context13.sent;\n            return _context13.abrupt(\"return\", response);\n\n          case 10:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _readContract.apply(this, arguments);\n}\n\nfunction multicall(_x6) {\n  return _multicall.apply(this, arguments);\n}\n\nfunction _multicall() {\n  _multicall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref) {\n    var _ref$allowFailure, allowFailure, chainId, contracts, overrides, provider, chain, multicallContract, calls, params, results;\n\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _ref$allowFailure = _ref.allowFailure, allowFailure = _ref$allowFailure === void 0 ? true : _ref$allowFailure, chainId = _ref.chainId, contracts = _ref.contracts, overrides = _ref.overrides;\n            provider = getProvider({\n              chainId: chainId\n            });\n\n            if (provider.chains) {\n              _context14.next = 4;\n              break;\n            }\n\n            throw new ProviderChainsNotFound();\n\n          case 4:\n            chain = provider.chains.find(function (chain) {\n              return chain.id === chainId;\n            }) || provider.chains[0];\n\n            if (chain) {\n              _context14.next = 7;\n              break;\n            }\n\n            throw new ProviderChainsNotFound();\n\n          case 7:\n            if (chain !== null && chain !== void 0 && chain.multicall) {\n              _context14.next = 9;\n              break;\n            }\n\n            throw new ChainDoesNotSupportMulticallError({\n              chain: chain\n            });\n\n          case 9:\n            if (!(typeof (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) === 'number' && (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) < chain.multicall.blockCreated)) {\n              _context14.next = 11;\n              break;\n            }\n\n            throw new ChainDoesNotSupportMulticallError({\n              blockNumber: overrides === null || overrides === void 0 ? void 0 : overrides.blockTag,\n              chain: chain\n            });\n\n          case 11:\n            multicallContract = getContract({\n              addressOrName: chain.multicall.address,\n              contractInterface: multicallInterface,\n              signerOrProvider: provider\n            });\n            calls = contracts.map(function (_ref2) {\n              var addressOrName = _ref2.addressOrName,\n                  contractInterface = _ref2.contractInterface,\n                  functionName = _ref2.functionName,\n                  config = _objectWithoutProperties(_ref2, _excluded);\n\n              var _ref17 = config || {},\n                  args = _ref17.args;\n\n              var contract = getContract({\n                addressOrName: addressOrName,\n                contractInterface: contractInterface\n              });\n              var params = Array.isArray(args) ? args : args ? [args] : [];\n\n              try {\n                var callData = contract.interface.encodeFunctionData(functionName, params);\n                if (!contract[functionName]) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n                return {\n                  target: addressOrName,\n                  allowFailure: allowFailure,\n                  callData: callData\n                };\n              } catch (err) {\n                if (!allowFailure) throw err;\n                return {\n                  target: addressOrName,\n                  allowFailure: allowFailure,\n                  callData: '0x'\n                };\n              }\n            });\n            params = [calls].concat(_toConsumableArray(overrides ? [overrides] : []));\n            _context14.next = 16;\n            return multicallContract.aggregate3.apply(multicallContract, _toConsumableArray(params));\n\n          case 16:\n            results = _context14.sent;\n            return _context14.abrupt(\"return\", results.map(function (_ref3, i) {\n              var returnData = _ref3.returnData,\n                  success = _ref3.success;\n              var _contracts$i = contracts[i],\n                  addressOrName = _contracts$i.addressOrName,\n                  contractInterface = _contracts$i.contractInterface,\n                  functionName = _contracts$i.functionName,\n                  args = _contracts$i.args;\n              var contract = getContract({\n                addressOrName: addressOrName,\n                contractInterface: contractInterface\n              });\n\n              if (!success) {\n                var error;\n\n                try {\n                  contract.interface.decodeFunctionResult(functionName, returnData);\n                } catch (err) {\n                  error = new ContractMethodRevertedError({\n                    addressOrName: addressOrName,\n                    args: args,\n                    chainId: chain.id,\n                    functionName: functionName,\n                    errorMessage: err.message\n                  });\n                  if (!allowFailure) throw error;\n                  logWarn(error.message);\n                }\n\n                return null;\n              }\n\n              if (returnData === '0x') {\n                var _error2 = new ContractMethodNoResultError({\n                  addressOrName: addressOrName,\n                  args: args,\n                  chainId: chain.id,\n                  functionName: functionName\n                });\n\n                if (!allowFailure) throw _error2;\n                logWarn(_error2.message);\n                return null;\n              }\n\n              try {\n                var result = contract.interface.decodeFunctionResult(functionName, returnData);\n                return Array.isArray(result) && result.length === 1 ? result[0] : result;\n              } catch (err) {\n                var _error3 = new ContractResultDecodeError({\n                  addressOrName: addressOrName,\n                  args: args,\n                  chainId: chain.id,\n                  functionName: functionName,\n                  errorMessage: err.message\n                });\n\n                if (!allowFailure) throw _error3;\n                logWarn(_error3.message);\n                return null;\n              }\n            }));\n\n          case 18:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return _multicall.apply(this, arguments);\n}\n\nfunction readContracts(_x7) {\n  return _readContracts.apply(this, arguments);\n}\n\nfunction _readContracts() {\n  _readContracts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_ref) {\n    var _ref$allowFailure2, allowFailure, contracts, overrides, provider, contractsByChainId, promises, _promises;\n\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _ref$allowFailure2 = _ref.allowFailure, allowFailure = _ref$allowFailure2 === void 0 ? true : _ref$allowFailure2, contracts = _ref.contracts, overrides = _ref.overrides;\n            _context15.prev = 1;\n            provider = getProvider();\n            contractsByChainId = contracts.reduce(function (contracts, contract) {\n              var _contract$chainId;\n\n              var chainId = (_contract$chainId = contract.chainId) !== null && _contract$chainId !== void 0 ? _contract$chainId : provider.network.chainId;\n              return _objectSpread(_objectSpread({}, contracts), {}, _defineProperty({}, chainId, [].concat(_toConsumableArray(contracts[chainId] || []), [contract])));\n            }, {});\n\n            promises = function promises() {\n              return Object.entries(contractsByChainId).map(function (_ref2) {\n                var _ref18 = _slicedToArray(_ref2, 2),\n                    chainId = _ref18[0],\n                    contracts = _ref18[1];\n\n                return multicall({\n                  allowFailure: allowFailure,\n                  chainId: parseInt(chainId),\n                  contracts: contracts,\n                  overrides: overrides\n                });\n              });\n            };\n\n            if (!allowFailure) {\n              _context15.next = 9;\n              break;\n            }\n\n            _context15.next = 8;\n            return Promise.allSettled(promises());\n\n          case 8:\n            return _context15.abrupt(\"return\", _context15.sent.map(function (result) {\n              if (result.status === 'fulfilled') return result.value;\n\n              if (result.reason instanceof ChainDoesNotSupportMulticallError) {\n                logWarn(result.reason.message);\n                throw result.reason;\n              }\n\n              return null;\n            }).flat());\n\n          case 9:\n            _context15.next = 11;\n            return Promise.all(promises());\n\n          case 11:\n            return _context15.abrupt(\"return\", _context15.sent.flat());\n\n          case 14:\n            _context15.prev = 14;\n            _context15.t0 = _context15[\"catch\"](1);\n\n            if (!(_context15.t0 instanceof ContractResultDecodeError)) {\n              _context15.next = 18;\n              break;\n            }\n\n            throw _context15.t0;\n\n          case 18:\n            if (!(_context15.t0 instanceof ContractMethodNoResultError)) {\n              _context15.next = 20;\n              break;\n            }\n\n            throw _context15.t0;\n\n          case 20:\n            if (!(_context15.t0 instanceof ContractMethodRevertedError)) {\n              _context15.next = 22;\n              break;\n            }\n\n            throw _context15.t0;\n\n          case 22:\n            _promises = function _promises() {\n              return contracts.map(function (contract) {\n                return readContract(_objectSpread(_objectSpread({}, contract), {}, {\n                  overrides: overrides\n                }));\n              });\n            };\n\n            if (!allowFailure) {\n              _context15.next = 27;\n              break;\n            }\n\n            _context15.next = 26;\n            return Promise.allSettled(_promises());\n\n          case 26:\n            return _context15.abrupt(\"return\", _context15.sent.map(function (result, i) {\n              if (result.status === 'fulfilled') return result.value;\n              var _contracts$i2 = contracts[i],\n                  addressOrName = _contracts$i2.addressOrName,\n                  functionName = _contracts$i2.functionName,\n                  chainId = _contracts$i2.chainId,\n                  args = _contracts$i2.args;\n              var error = new ContractMethodRevertedError({\n                addressOrName: addressOrName,\n                functionName: functionName,\n                chainId: chainId !== null && chainId !== void 0 ? chainId : mainnet.id,\n                args: args,\n                errorMessage: result.reason\n              });\n              logWarn(error.message);\n              return null;\n            }));\n\n          case 27:\n            _context15.next = 29;\n            return Promise.all(_promises());\n\n          case 29:\n            return _context15.abrupt(\"return\", _context15.sent);\n\n          case 30:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15, null, [[1, 14]]);\n  }));\n  return _readContracts.apply(this, arguments);\n}\n\nfunction watchContractEvent(\n/** Contract configuration */\ncontractArgs,\n/** Event name to listen to */\neventName, callback) {\n  var _ref9 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      chainId = _ref9.chainId,\n      once = _ref9.once;\n\n  var contract;\n\n  var watchEvent = /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var _contract;\n\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (contract) {\n                (_contract = contract) === null || _contract === void 0 ? void 0 : _contract.off(eventName, callback);\n              }\n\n              contract = getContract(_objectSpread({\n                signerOrProvider: getWebSocketProvider({\n                  chainId: chainId\n                }) || getProvider({\n                  chainId: chainId\n                })\n              }, contractArgs));\n              if (once) contract.once(eventName, callback);else contract.on(eventName, callback);\n\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function watchEvent() {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n\n  watchEvent();\n  var client = getClient();\n  var unsubscribe = client.subscribe(function (_ref) {\n    var provider = _ref.provider,\n        webSocketProvider = _ref.webSocketProvider;\n    return {\n      provider: provider,\n      webSocketProvider: webSocketProvider\n    };\n  }, watchEvent, {\n    equalityFn: shallow\n  });\n  return function () {\n    var _contract2;\n\n    (_contract2 = contract) === null || _contract2 === void 0 ? void 0 : _contract2.off(eventName, callback);\n    unsubscribe();\n  };\n}\n\nfunction fetchBlockNumber() {\n  return _fetchBlockNumber.apply(this, arguments);\n}\n\nfunction _fetchBlockNumber() {\n  _fetchBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n    var _ref19,\n        chainId,\n        provider,\n        blockNumber,\n        _args16 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            _ref19 = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : {}, chainId = _ref19.chainId;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context16.next = 4;\n            return provider.getBlockNumber();\n\n          case 4:\n            blockNumber = _context16.sent;\n            return _context16.abrupt(\"return\", blockNumber);\n\n          case 6:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _fetchBlockNumber.apply(this, arguments);\n}\n\nfunction watchBlockNumber(args, callback) {\n  var _client$webSocketProv;\n\n  var previousProvider;\n\n  var createListener = function createListener(provider) {\n    // We need to debounce the listener as we want to opt-out\n    // of the behavior where ethers emits a \"block\" event for\n    // every block that was missed in between the `pollingInterval`.\n    // We are setting a wait time of 1 as emitting an event in\n    // ethers takes ~0.1ms.\n    var debouncedCallback = debounce(callback, 1);\n\n    if (previousProvider) {\n      var _previousProvider;\n\n      (_previousProvider = previousProvider) === null || _previousProvider === void 0 ? void 0 : _previousProvider.off('block', debouncedCallback);\n    }\n\n    provider.on('block', debouncedCallback);\n    previousProvider = provider;\n  };\n\n  var client = getClient();\n  var provider_ = (_client$webSocketProv = client.webSocketProvider) !== null && _client$webSocketProv !== void 0 ? _client$webSocketProv : client.provider;\n  if (args.listen) createListener(provider_);\n  var unsubscribe = client.subscribe(function (_ref) {\n    var provider = _ref.provider,\n        webSocketProvider = _ref.webSocketProvider;\n    return {\n      provider: provider,\n      webSocketProvider: webSocketProvider\n    };\n  }, /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref2) {\n      var provider, webSocketProvider, provider_;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              provider = _ref2.provider, webSocketProvider = _ref2.webSocketProvider;\n              provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n\n              if (args.listen && provider_) {\n                createListener(provider_);\n              }\n\n              _context4.t0 = callback;\n              _context4.next = 6;\n              return fetchBlockNumber();\n\n            case 6:\n              _context4.t1 = _context4.sent;\n              (0, _context4.t0)(_context4.t1);\n\n            case 8:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x8) {\n      return _ref11.apply(this, arguments);\n    };\n  }(), {\n    equalityFn: shallow\n  });\n  return function () {\n    unsubscribe();\n    provider_ === null || provider_ === void 0 ? void 0 : provider_.off('block', callback);\n  };\n}\n\nfunction watchReadContract(config, callback) {\n  var client = getClient();\n\n  var handleChange = /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.t0 = callback;\n              _context5.next = 3;\n              return readContract(config);\n\n            case 3:\n              _context5.t1 = _context5.sent;\n              return _context5.abrupt(\"return\", (0, _context5.t0)(_context5.t1));\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function handleChange() {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n\n  var unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  var unsubscribe = client.subscribe(function (_ref) {\n    var provider = _ref.provider;\n    return provider;\n  }, handleChange);\n  return function () {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nfunction watchReadContracts(config, callback) {\n  var client = getClient();\n\n  var handleChange = /*#__PURE__*/function () {\n    var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.t0 = callback;\n              _context6.next = 3;\n              return readContracts(config);\n\n            case 3:\n              _context6.t1 = _context6.sent;\n              return _context6.abrupt(\"return\", (0, _context6.t0)(_context6.t1));\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function handleChange() {\n      return _ref13.apply(this, arguments);\n    };\n  }();\n\n  var unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  var unsubscribe = client.subscribe(function (_ref) {\n    var provider = _ref.provider;\n    return provider;\n  }, handleChange);\n  return function () {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nfunction deprecatedSendTransaction(_x9) {\n  return _deprecatedSendTransaction.apply(this, arguments);\n}\n/**\n * @description Fetches transaction for hash\n *\n * @example\n * import { fetchTransaction } from '@wagmi/core'\n *\n * const transaction = await fetchTransaction({\n *  chainId: 1,\n *  hash: '0x...',\n * })\n */\n\n\nfunction _deprecatedSendTransaction() {\n  _deprecatedSendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref) {\n    var chainId, request, _getClient4, connector, _chain, chain, activeChainId, _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4, signer;\n\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            chainId = _ref.chainId, request = _ref.request;\n            _getClient4 = getClient(), connector = _getClient4.connector;\n\n            if (connector) {\n              _context17.next = 4;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 4:\n            _context17.prev = 4;\n\n            if (!chainId) {\n              _context17.next = 17;\n              break;\n            }\n\n            _context17.next = 8;\n            return connector.getChainId();\n\n          case 8:\n            activeChainId = _context17.sent;\n\n            if (!(chainId !== activeChainId)) {\n              _context17.next = 17;\n              break;\n            }\n\n            if (!connector.switchChain) {\n              _context17.next = 16;\n              break;\n            }\n\n            _context17.next = 13;\n            return connector.switchChain(chainId);\n\n          case 13:\n            chain = _context17.sent;\n            _context17.next = 17;\n            break;\n\n          case 16:\n            throw new ChainMismatchError({\n              activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(function (x) {\n                return x.id === activeChainId;\n              })) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n              targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(function (x) {\n                return x.id === chainId;\n              })) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n            });\n\n          case 17:\n            _context17.next = 19;\n            return connector.getSigner({\n              chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n            });\n\n          case 19:\n            signer = _context17.sent;\n            _context17.next = 22;\n            return signer.sendTransaction(request);\n\n          case 22:\n            return _context17.abrupt(\"return\", _context17.sent);\n\n          case 25:\n            _context17.prev = 25;\n            _context17.t0 = _context17[\"catch\"](4);\n\n            if (!(_context17.t0.code === 4001)) {\n              _context17.next = 29;\n              break;\n            }\n\n            throw new UserRejectedRequestError(_context17.t0);\n\n          case 29:\n            throw _context17.t0;\n\n          case 30:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17, null, [[4, 25]]);\n  }));\n  return _deprecatedSendTransaction.apply(this, arguments);\n}\n\nfunction fetchTransaction(_x10) {\n  return _fetchTransaction.apply(this, arguments);\n}\n\nfunction _fetchTransaction() {\n  _fetchTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(_ref) {\n    var chainId, hash, provider;\n    return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n      while (1) {\n        switch (_context18.prev = _context18.next) {\n          case 0:\n            chainId = _ref.chainId, hash = _ref.hash;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context18.next = 4;\n            return provider.getTransaction(hash);\n\n          case 4:\n            return _context18.abrupt(\"return\", _context18.sent);\n\n          case 5:\n          case \"end\":\n            return _context18.stop();\n        }\n      }\n    }, _callee18);\n  }));\n  return _fetchTransaction.apply(this, arguments);\n}\n\nfunction fetchEnsAddress(_x11) {\n  return _fetchEnsAddress.apply(this, arguments);\n}\n\nfunction _fetchEnsAddress() {\n  _fetchEnsAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(_ref) {\n    var chainId, name, provider, address;\n    return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            chainId = _ref.chainId, name = _ref.name;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context19.next = 4;\n            return provider.resolveName(name);\n\n          case 4:\n            address = _context19.sent;\n            _context19.prev = 5;\n            return _context19.abrupt(\"return\", address ? getAddress(address) : null);\n\n          case 9:\n            _context19.prev = 9;\n            _context19.t0 = _context19[\"catch\"](5);\n            return _context19.abrupt(\"return\", null);\n\n          case 12:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19, null, [[5, 9]]);\n  }));\n  return _fetchEnsAddress.apply(this, arguments);\n}\n\nfunction fetchEnsAvatar(_x12) {\n  return _fetchEnsAvatar.apply(this, arguments);\n}\n\nfunction _fetchEnsAvatar() {\n  _fetchEnsAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_ref) {\n    var addressOrName, chainId, provider, avatar;\n    return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n      while (1) {\n        switch (_context20.prev = _context20.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, chainId = _ref.chainId;\n            provider = getProvider({\n              chainId: chainId\n            }); // TODO: Update with more advanced logic\n            // https://github.com/ensdomains/ens-avatar\n\n            _context20.next = 4;\n            return provider.getAvatar(addressOrName);\n\n          case 4:\n            avatar = _context20.sent;\n            return _context20.abrupt(\"return\", avatar);\n\n          case 6:\n          case \"end\":\n            return _context20.stop();\n        }\n      }\n    }, _callee20);\n  }));\n  return _fetchEnsAvatar.apply(this, arguments);\n}\n\nfunction fetchEnsName(_x13) {\n  return _fetchEnsName.apply(this, arguments);\n}\n\nfunction _fetchEnsName() {\n  _fetchEnsName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_ref) {\n    var address, chainId, provider;\n    return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            address = _ref.address, chainId = _ref.chainId;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context21.next = 4;\n            return provider.lookupAddress(address);\n\n          case 4:\n            return _context21.abrupt(\"return\", _context21.sent);\n\n          case 5:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, _callee21);\n  }));\n  return _fetchEnsName.apply(this, arguments);\n}\n\nfunction fetchEnsResolver(_x14) {\n  return _fetchEnsResolver.apply(this, arguments);\n}\n/**\n * @description Prepares the parameters required for sending a transaction.\n *\n * Returns config to be passed through to `sendTransaction`.\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  request: {\n *    to: 'moxey.eth',\n *    value: parseEther('1'),\n *  }\n * })\n * const result = await sendTransaction(config)\n */\n\n\nfunction _fetchEnsResolver() {\n  _fetchEnsResolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(_ref) {\n    var chainId, name, provider, resolver;\n    return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n      while (1) {\n        switch (_context22.prev = _context22.next) {\n          case 0:\n            chainId = _ref.chainId, name = _ref.name;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context22.next = 4;\n            return provider.getResolver(name);\n\n          case 4:\n            resolver = _context22.sent;\n            return _context22.abrupt(\"return\", resolver);\n\n          case 6:\n          case \"end\":\n            return _context22.stop();\n        }\n      }\n    }, _callee22);\n  }));\n  return _fetchEnsResolver.apply(this, arguments);\n}\n\nfunction prepareSendTransaction(_x15) {\n  return _prepareSendTransaction.apply(this, arguments);\n}\n/**\n * @description Function to send a transaction.\n *\n * It is recommended to pair this with the `prepareSendTransaction` function to avoid\n * [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  to: 'moxey.eth',\n *  value: parseEther('1'),\n * })\n * const result = await sendTransaction(config)\n */\n\n\nfunction _prepareSendTransaction() {\n  _prepareSendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(_ref) {\n    var chainId, request, _ref$signerOrProvider, signerOrProvider, _yield$Promise$all, _yield$Promise$all2, to, gasLimit;\n\n    return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n      while (1) {\n        switch (_context23.prev = _context23.next) {\n          case 0:\n            chainId = _ref.chainId, request = _ref.request, _ref$signerOrProvider = _ref.signerOrProvider, signerOrProvider = _ref$signerOrProvider === void 0 ? getProvider({\n              chainId: chainId\n            }) : _ref$signerOrProvider;\n            _context23.next = 3;\n            return Promise.all([isAddress(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({\n              name: request.to\n            }), request.gasLimit ? Promise.resolve(request.gasLimit) : signerOrProvider.estimateGas(request)]);\n\n          case 3:\n            _yield$Promise$all = _context23.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            to = _yield$Promise$all2[0];\n            gasLimit = _yield$Promise$all2[1];\n\n            if (to) {\n              _context23.next = 9;\n              break;\n            }\n\n            throw new Error('Could not resolve ENS name');\n\n          case 9:\n            return _context23.abrupt(\"return\", _objectSpread(_objectSpread({}, chainId ? {\n              chainId: chainId\n            } : {}), {}, {\n              request: _objectSpread(_objectSpread({}, request), {}, {\n                gasLimit: gasLimit,\n                to: to\n              }),\n              mode: 'prepared'\n            }));\n\n          case 10:\n          case \"end\":\n            return _context23.stop();\n        }\n      }\n    }, _callee23);\n  }));\n  return _prepareSendTransaction.apply(this, arguments);\n}\n\nfunction sendTransaction(_x16) {\n  return _sendTransaction.apply(this, arguments);\n}\n\nfunction _sendTransaction() {\n  _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(_ref) {\n    var chainId, mode, request, signer, _getNetwork, activeChain, chains, activeChainId, _chains$find$name, _chains$find, _chains$find$name2, _chains$find2, _connectUnchecked, _ref2, uncheckedSigner, _yield$sendTransactio, hash, wait;\n\n    return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n      while (1) {\n        switch (_context24.prev = _context24.next) {\n          case 0:\n            chainId = _ref.chainId, mode = _ref.mode, request = _ref.request;\n            /********************************************************************/\n\n            /** START: iOS App Link cautious code.                              */\n\n            /** Do not perform any async operations in this block.              */\n\n            /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n            /********************************************************************/\n            // `fetchSigner` isn't really \"asynchronous\" as we have already\n            // initialized the provider upon user connection, so it will return\n            // immediately.\n\n            _context24.next = 3;\n            return fetchSigner();\n\n          case 3:\n            signer = _context24.sent;\n\n            if (signer) {\n              _context24.next = 6;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 6:\n            if (!(mode === 'prepared')) {\n              _context24.next = 11;\n              break;\n            }\n\n            if (request.gasLimit) {\n              _context24.next = 9;\n              break;\n            }\n\n            throw new Error('`gasLimit` is required');\n\n          case 9:\n            if (request.to) {\n              _context24.next = 11;\n              break;\n            }\n\n            throw new Error('`to` is required');\n\n          case 11:\n            _getNetwork = getNetwork(), activeChain = _getNetwork.chain, chains = _getNetwork.chains;\n            activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n            if (!(chainId && chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id))) {\n              _context24.next = 15;\n              break;\n            }\n\n            throw new ChainMismatchError({\n              activeChain: (_chains$find$name = (_chains$find = chains.find(function (x) {\n                return x.id === activeChainId;\n              })) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n              targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(function (x) {\n                return x.id === chainId;\n              })) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n            });\n\n          case 15:\n            _context24.prev = 15;\n            // Why don't we just use `signer.sendTransaction`?\n            // The `signer.sendTransaction` method performs async\n            // heavy operations (such as fetching block number)\n            // which is not really needed for our case.\n            // Having async heavy operations has side effects\n            // when using it in a click handler (iOS deep linking issues,\n            // delay to open wallet, etc).\n            uncheckedSigner = (_connectUnchecked = (_ref2 = signer).connectUnchecked) === null || _connectUnchecked === void 0 ? void 0 : _connectUnchecked.call(_ref2);\n            _context24.next = 19;\n            return (uncheckedSigner !== null && uncheckedSigner !== void 0 ? uncheckedSigner : signer).sendTransaction(request);\n\n          case 19:\n            _yield$sendTransactio = _context24.sent;\n            hash = _yield$sendTransactio.hash;\n            wait = _yield$sendTransactio.wait;\n            return _context24.abrupt(\"return\", {\n              hash: hash,\n              wait: wait\n            });\n\n          case 25:\n            _context24.prev = 25;\n            _context24.t0 = _context24[\"catch\"](15);\n\n            if (!(_context24.t0.code === 4001)) {\n              _context24.next = 29;\n              break;\n            }\n\n            throw new UserRejectedRequestError(_context24.t0);\n\n          case 29:\n            throw _context24.t0;\n\n          case 30:\n          case \"end\":\n            return _context24.stop();\n        }\n      }\n    }, _callee24, null, [[15, 25]]);\n  }));\n  return _sendTransaction.apply(this, arguments);\n}\n\nfunction waitForTransaction(_x17) {\n  return _waitForTransaction.apply(this, arguments);\n}\n/**\n * @description Function to call a contract write method.\n *\n * It is recommended to pair this with the {@link prepareWriteContract} function\n * to avoid [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *   addressOrName: '0x...',\n *   contractInterface: wagmiAbi,\n *   functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\n\n\nfunction _waitForTransaction() {\n  _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(_ref) {\n    var chainId, confirmations, hash, timeout, wait_, promise, provider;\n    return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n      while (1) {\n        switch (_context25.prev = _context25.next) {\n          case 0:\n            chainId = _ref.chainId, confirmations = _ref.confirmations, hash = _ref.hash, timeout = _ref.timeout, wait_ = _ref.wait;\n\n            if (!hash) {\n              _context25.next = 6;\n              break;\n            }\n\n            provider = getProvider({\n              chainId: chainId\n            });\n            promise = provider.waitForTransaction(hash, confirmations, timeout);\n            _context25.next = 11;\n            break;\n\n          case 6:\n            if (!wait_) {\n              _context25.next = 10;\n              break;\n            }\n\n            promise = wait_(confirmations);\n            _context25.next = 11;\n            break;\n\n          case 10:\n            throw new Error('hash or wait is required');\n\n          case 11:\n            _context25.next = 13;\n            return promise;\n\n          case 13:\n            return _context25.abrupt(\"return\", _context25.sent);\n\n          case 14:\n          case \"end\":\n            return _context25.stop();\n        }\n      }\n    }, _callee25);\n  }));\n  return _waitForTransaction.apply(this, arguments);\n}\n\nfunction writeContract(_x18) {\n  return _writeContract.apply(this, arguments);\n}\n\nfunction _writeContract() {\n  _writeContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(_ref) {\n    var addressOrName, args, chainId, contractInterface, functionName, mode, overrides, request_, signer, _getNetwork2, activeChain, chains, activeChainId, _chains$find$name, _chains$find, _chains$find$name2, _chains$find2, request, transaction;\n\n    return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n      while (1) {\n        switch (_context26.prev = _context26.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, args = _ref.args, chainId = _ref.chainId, contractInterface = _ref.contractInterface, functionName = _ref.functionName, mode = _ref.mode, overrides = _ref.overrides, request_ = _ref.request;\n            /********************************************************************/\n\n            /** START: iOS App Link cautious code.                              */\n\n            /** Do not perform any async operations in this block.              */\n\n            /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n            /********************************************************************/\n\n            _context26.next = 3;\n            return fetchSigner();\n\n          case 3:\n            signer = _context26.sent;\n\n            if (signer) {\n              _context26.next = 6;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 6:\n            _getNetwork2 = getNetwork(), activeChain = _getNetwork2.chain, chains = _getNetwork2.chains;\n            activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n            if (!(chainId && chainId !== activeChainId)) {\n              _context26.next = 10;\n              break;\n            }\n\n            throw new ChainMismatchError({\n              activeChain: (_chains$find$name = (_chains$find = chains.find(function (x) {\n                return x.id === activeChainId;\n              })) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n              targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(function (x) {\n                return x.id === chainId;\n              })) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n            });\n\n          case 10:\n            if (!(mode === 'prepared')) {\n              _context26.next = 13;\n              break;\n            }\n\n            if (request_) {\n              _context26.next = 13;\n              break;\n            }\n\n            throw new Error('`request` is required');\n\n          case 13:\n            if (!(mode === 'recklesslyUnprepared')) {\n              _context26.next = 19;\n              break;\n            }\n\n            _context26.next = 16;\n            return prepareWriteContract({\n              addressOrName: addressOrName,\n              args: args,\n              contractInterface: contractInterface,\n              functionName: functionName,\n              overrides: overrides\n            });\n\n          case 16:\n            _context26.t0 = _context26.sent.request;\n            _context26.next = 20;\n            break;\n\n          case 19:\n            _context26.t0 = request_;\n\n          case 20:\n            request = _context26.t0;\n            _context26.next = 23;\n            return sendTransaction({\n              request: request,\n              mode: 'prepared'\n            });\n\n          case 23:\n            transaction = _context26.sent;\n            return _context26.abrupt(\"return\", transaction);\n\n          case 25:\n          case \"end\":\n            return _context26.stop();\n        }\n      }\n    }, _callee26);\n  }));\n  return _writeContract.apply(this, arguments);\n}\n\nfunction fetchBalance(_x19) {\n  return _fetchBalance.apply(this, arguments);\n}\n\nfunction _fetchBalance() {\n  _fetchBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(_ref) {\n    var _client$chains, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4, addressOrName, chainId, unit, token, client, provider, erc20Config, resolvedAddress, address, _yield$readContracts3, _yield$readContracts4, _value, decimals, symbol, chains, value, chain;\n\n    return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n      while (1) {\n        switch (_context27.prev = _context27.next) {\n          case 0:\n            addressOrName = _ref.addressOrName, chainId = _ref.chainId, unit = _ref.formatUnits, token = _ref.token;\n            client = getClient();\n            provider = getProvider({\n              chainId: chainId\n            });\n\n            if (!token) {\n              _context27.next = 22;\n              break;\n            }\n\n            erc20Config = {\n              addressOrName: token,\n              contractInterface: erc20ABI,\n              chainId: chainId\n            }; // Convert ENS name to address if required\n\n            if (!isAddress(addressOrName)) {\n              _context27.next = 9;\n              break;\n            }\n\n            resolvedAddress = addressOrName;\n            _context27.next = 14;\n            break;\n\n          case 9:\n            _context27.next = 11;\n            return provider.resolveName(addressOrName);\n\n          case 11:\n            address = _context27.sent;\n            // Same error `provider.getBalance` throws for invalid ENS name\n            if (!address) logger.throwError('ENS name not configured', Logger.errors.UNSUPPORTED_OPERATION, {\n              operation: \"resolveName(\".concat(JSON.stringify(addressOrName), \")\")\n            });\n            resolvedAddress = address;\n\n          case 14:\n            _context27.next = 16;\n            return readContracts({\n              allowFailure: false,\n              contracts: [_objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'balanceOf',\n                args: resolvedAddress\n              }), _objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'decimals'\n              }), _objectSpread(_objectSpread({}, erc20Config), {}, {\n                functionName: 'symbol'\n              })]\n            });\n\n          case 16:\n            _yield$readContracts3 = _context27.sent;\n            _yield$readContracts4 = _slicedToArray(_yield$readContracts3, 3);\n            _value = _yield$readContracts4[0];\n            decimals = _yield$readContracts4[1];\n            symbol = _yield$readContracts4[2];\n            return _context27.abrupt(\"return\", {\n              decimals: decimals,\n              formatted: formatUnits(_value !== null && _value !== void 0 ? _value : '0', unit !== null && unit !== void 0 ? unit : decimals),\n              symbol: symbol,\n              value: _value\n            });\n\n          case 22:\n            chains = [].concat(_toConsumableArray(client.provider.chains || []), _toConsumableArray((_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : []));\n            _context27.next = 25;\n            return provider.getBalance(addressOrName);\n\n          case 25:\n            value = _context27.sent;\n            chain = chains.find(function (x) {\n              return x.id === provider.network.chainId;\n            });\n            return _context27.abrupt(\"return\", {\n              decimals: (_chain$nativeCurrency = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency2 = chain.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,\n              formatted: formatUnits(value !== null && value !== void 0 ? value : '0', unit !== null && unit !== void 0 ? unit : 'ether'),\n              symbol: (_chain$nativeCurrency3 = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency4 = chain.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : 'ETH',\n              value: value\n            });\n\n          case 28:\n          case \"end\":\n            return _context27.stop();\n        }\n      }\n    }, _callee27);\n  }));\n  return _fetchBalance.apply(this, arguments);\n}\n\nfunction fetchSigner() {\n  return _fetchSigner.apply(this, arguments);\n}\n\nfunction _fetchSigner() {\n  _fetchSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n    var _client$connector, _client$connector$get, client, signer;\n\n    return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n      while (1) {\n        switch (_context28.prev = _context28.next) {\n          case 0:\n            client = getClient();\n            _context28.next = 3;\n            return (_client$connector = client.connector) === null || _client$connector === void 0 ? void 0 : (_client$connector$get = _client$connector.getSigner) === null || _client$connector$get === void 0 ? void 0 : _client$connector$get.call(_client$connector);\n\n          case 3:\n            _context28.t0 = _context28.sent;\n\n            if (_context28.t0) {\n              _context28.next = 6;\n              break;\n            }\n\n            _context28.t0 = null;\n\n          case 6:\n            signer = _context28.t0;\n            return _context28.abrupt(\"return\", signer);\n\n          case 8:\n          case \"end\":\n            return _context28.stop();\n        }\n      }\n    }, _callee28);\n  }));\n  return _fetchSigner.apply(this, arguments);\n}\n\nfunction getAccount() {\n  var _getClient2 = getClient(),\n      data = _getClient2.data,\n      connector = _getClient2.connector,\n      status = _getClient2.status;\n\n  switch (status) {\n    case 'connected':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector: connector,\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n        status: status\n      };\n\n    case 'reconnecting':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector: connector,\n        isConnected: !!(data !== null && data !== void 0 && data.account),\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: true,\n        status: status\n      };\n\n    case 'connecting':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: true,\n        isDisconnected: false,\n        isReconnecting: false,\n        status: status\n      };\n\n    case 'disconnected':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n        status: status\n      };\n  }\n}\n\nfunction getNetwork() {\n  var _client$data, _client$data$chain, _client$chains, _find, _client$data2;\n\n  var client = getClient();\n  var chainId = (_client$data = client.data) === null || _client$data === void 0 ? void 0 : (_client$data$chain = _client$data.chain) === null || _client$data$chain === void 0 ? void 0 : _client$data$chain.id;\n  var activeChains = (_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [];\n  var activeChain = (_find = [].concat(_toConsumableArray(client.provider.chains || []), _toConsumableArray(activeChains)).find(function (x) {\n    return x.id === chainId;\n  })) !== null && _find !== void 0 ? _find : {\n    id: chainId,\n    name: \"Chain \".concat(chainId),\n    network: \"\".concat(chainId),\n    rpcUrls: {\n      default: ''\n    }\n  };\n  return {\n    chain: chainId ? _objectSpread(_objectSpread(_objectSpread({}, activeChain), (_client$data2 = client.data) === null || _client$data2 === void 0 ? void 0 : _client$data2.chain), {}, {\n      id: chainId\n    }) : undefined,\n    chains: activeChains\n  };\n}\n\nfunction signMessage(_x20) {\n  return _signMessage.apply(this, arguments);\n}\n\nfunction _signMessage() {\n  _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(args) {\n    var signer;\n    return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n      while (1) {\n        switch (_context29.prev = _context29.next) {\n          case 0:\n            _context29.prev = 0;\n            _context29.next = 3;\n            return fetchSigner();\n\n          case 3:\n            signer = _context29.sent;\n\n            if (signer) {\n              _context29.next = 6;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 6:\n            _context29.next = 8;\n            return signer.signMessage(args.message);\n\n          case 8:\n            return _context29.abrupt(\"return\", _context29.sent);\n\n          case 11:\n            _context29.prev = 11;\n            _context29.t0 = _context29[\"catch\"](0);\n\n            if (!(_context29.t0.code === 4001)) {\n              _context29.next = 15;\n              break;\n            }\n\n            throw new UserRejectedRequestError(_context29.t0);\n\n          case 15:\n            throw _context29.t0;\n\n          case 16:\n          case \"end\":\n            return _context29.stop();\n        }\n      }\n    }, _callee29, null, [[0, 11]]);\n  }));\n  return _signMessage.apply(this, arguments);\n}\n\nfunction signTypedData(_x21) {\n  return _signTypedData.apply(this, arguments);\n}\n\nfunction _signTypedData() {\n  _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(_ref) {\n    var domain, types, value, signer, _getNetwork3, activeChain, chains, chainId_, chainId, activeChainId, _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n    return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n      while (1) {\n        switch (_context30.prev = _context30.next) {\n          case 0:\n            domain = _ref.domain, types = _ref.types, value = _ref.value;\n            _context30.next = 3;\n            return fetchSigner();\n\n          case 3:\n            signer = _context30.sent;\n\n            if (signer) {\n              _context30.next = 6;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 6:\n            _getNetwork3 = getNetwork(), activeChain = _getNetwork3.chain, chains = _getNetwork3.chains;\n            chainId_ = domain.chainId;\n\n            if (!chainId_) {\n              _context30.next = 13;\n              break;\n            }\n\n            chainId = normalizeChainId(chainId_);\n            activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n            if (!(chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id))) {\n              _context30.next = 13;\n              break;\n            }\n\n            throw new ChainMismatchError({\n              activeChain: (_chains$find$name = (_chains$find = chains.find(function (x) {\n                return x.id === activeChainId;\n              })) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n              targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(function (x) {\n                return x.id === chainId;\n              })) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n            });\n\n          case 13:\n            _context30.next = 15;\n            return signer._signTypedData(domain, types, value);\n\n          case 15:\n            return _context30.abrupt(\"return\", _context30.sent);\n\n          case 16:\n          case \"end\":\n            return _context30.stop();\n        }\n      }\n    }, _callee30);\n  }));\n  return _signTypedData.apply(this, arguments);\n}\n\nfunction switchNetwork(_x22) {\n  return _switchNetwork.apply(this, arguments);\n}\n\nfunction _switchNetwork() {\n  _switchNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(_ref) {\n    var chainId, _getClient5, connector;\n\n    return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n      while (1) {\n        switch (_context31.prev = _context31.next) {\n          case 0:\n            chainId = _ref.chainId;\n            _getClient5 = getClient(), connector = _getClient5.connector;\n\n            if (connector) {\n              _context31.next = 4;\n              break;\n            }\n\n            throw new ConnectorNotFoundError();\n\n          case 4:\n            if (connector.switchChain) {\n              _context31.next = 6;\n              break;\n            }\n\n            throw new SwitchChainNotSupportedError({\n              connector: connector\n            });\n\n          case 6:\n            _context31.next = 8;\n            return connector.switchChain(chainId);\n\n          case 8:\n            return _context31.abrupt(\"return\", _context31.sent);\n\n          case 9:\n          case \"end\":\n            return _context31.stop();\n        }\n      }\n    }, _callee31);\n  }));\n  return _switchNetwork.apply(this, arguments);\n}\n\nfunction watchAccount(callback) {\n  var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref14$selector = _ref14.selector,\n      selector = _ref14$selector === void 0 ? function (x) {\n    return x;\n  } : _ref14$selector;\n\n  var client = getClient();\n\n  var handleChange = function handleChange() {\n    return callback(getAccount());\n  };\n\n  var unsubscribe = client.subscribe(function (_ref) {\n    var data = _ref.data,\n        connector = _ref.connector,\n        status = _ref.status;\n    return selector({\n      address: data === null || data === void 0 ? void 0 : data.account,\n      connector: connector,\n      status: status\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchNetwork(callback) {\n  var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref15$selector = _ref15.selector,\n      selector = _ref15$selector === void 0 ? function (x) {\n    return x;\n  } : _ref15$selector;\n\n  var client = getClient();\n\n  var handleChange = function handleChange() {\n    return callback(getNetwork());\n  };\n\n  var unsubscribe = client.subscribe(function (_ref) {\n    var _data$chain;\n\n    var data = _ref.data,\n        chains = _ref.chains;\n    return selector({\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      chains: chains\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchSigner(callback) {\n  var client = getClient();\n\n  var handleChange = /*#__PURE__*/function () {\n    var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.t0 = callback;\n              _context7.next = 3;\n              return fetchSigner();\n\n            case 3:\n              _context7.t1 = _context7.sent;\n              return _context7.abrupt(\"return\", (0, _context7.t0)(_context7.t1));\n\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function handleChange() {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n\n  var unsubscribe = client.subscribe(function (_ref) {\n    var _data$chain;\n\n    var data = _ref.data,\n        connector = _ref.connector;\n    return {\n      account: data === null || data === void 0 ? void 0 : data.account,\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      connector: connector\n    };\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction fetchFeeData() {\n  return _fetchFeeData.apply(this, arguments);\n}\n\nfunction _fetchFeeData() {\n  _fetchFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n    var _ref20,\n        chainId,\n        _ref20$formatUnits,\n        units,\n        provider,\n        feeData,\n        formatted,\n        _args32 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n      while (1) {\n        switch (_context32.prev = _context32.next) {\n          case 0:\n            _ref20 = _args32.length > 0 && _args32[0] !== undefined ? _args32[0] : {}, chainId = _ref20.chainId, _ref20$formatUnits = _ref20.formatUnits, units = _ref20$formatUnits === void 0 ? 'wei' : _ref20$formatUnits;\n            provider = getProvider({\n              chainId: chainId\n            });\n            _context32.next = 4;\n            return provider.getFeeData();\n\n          case 4:\n            feeData = _context32.sent;\n            formatted = {\n              gasPrice: feeData.gasPrice ? formatUnits(feeData.gasPrice, units) : null,\n              maxFeePerGas: feeData.maxFeePerGas ? formatUnits(feeData.maxFeePerGas, units) : null,\n              maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? formatUnits(feeData.maxPriorityFeePerGas, units) : null\n            };\n            return _context32.abrupt(\"return\", _objectSpread(_objectSpread({}, feeData), {}, {\n              formatted: formatted\n            }));\n\n          case 7:\n          case \"end\":\n            return _context32.stop();\n        }\n      }\n    }, _callee32);\n  }));\n  return _fetchFeeData.apply(this, arguments);\n}\n\nexport { configureChains, connect, deepEqual, deprecatedSendTransaction, deprecatedWriteContract, disconnect, erc20ABI, erc721ABI, fetchBalance, fetchBlockNumber, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, fetchFeeData, fetchSigner, fetchToken, fetchTransaction, getAccount, getContract, getNetwork, getWebSocketProvider, minimizeContractInterface, parseContractResult, prepareSendTransaction, prepareWriteContract, readContract, readContracts, sendTransaction, signMessage, signTypedData, switchNetwork, units, waitForTransaction, watchAccount, watchBlockNumber, watchContractEvent, watchNetwork, watchProvider, watchReadContract, watchReadContracts, watchSigner, watchWebSocketProvider, writeContract };","map":null,"metadata":{},"sourceType":"module"}