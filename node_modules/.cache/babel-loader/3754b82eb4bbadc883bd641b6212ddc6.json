{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { hydrate, dehydrate } from '@tanstack/query-core';\n/**\n * Restores persisted data to the QueryCache\n *  - data obtained from persister.restoreClient\n *  - data is hydrated using hydrateOptions\n * If data is expired, busted, empty, or throws, it runs persister.removeClient\n */\n\nfunction persistQueryClientRestore(_x) {\n  return _persistQueryClientRestore.apply(this, arguments);\n}\n/**\n * Persists data from the QueryCache\n *  - data dehydrated using dehydrateOptions\n *  - data is persisted using persister.persistClient\n */\n\n\nfunction _persistQueryClientRestore() {\n  _persistQueryClientRestore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var queryClient, persister, _ref$maxAge, maxAge, _ref$buster, buster, hydrateOptions, persistedClient, expired, busted;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            queryClient = _ref.queryClient, persister = _ref.persister, _ref$maxAge = _ref.maxAge, maxAge = _ref$maxAge === void 0 ? 1000 * 60 * 60 * 24 : _ref$maxAge, _ref$buster = _ref.buster, buster = _ref$buster === void 0 ? '' : _ref$buster, hydrateOptions = _ref.hydrateOptions;\n            _context.prev = 1;\n            _context.next = 4;\n            return persister.restoreClient();\n\n          case 4:\n            persistedClient = _context.sent;\n\n            if (persistedClient) {\n              if (persistedClient.timestamp) {\n                expired = Date.now() - persistedClient.timestamp > maxAge;\n                busted = persistedClient.buster !== buster;\n\n                if (expired || busted) {\n                  persister.removeClient();\n                } else {\n                  hydrate(queryClient, persistedClient.clientState, hydrateOptions);\n                }\n              } else {\n                persister.removeClient();\n              }\n            }\n\n            _context.next = 12;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](1);\n\n            if (process.env.NODE_ENV !== 'production') {\n              queryClient.getLogger().error(_context.t0);\n              queryClient.getLogger().warn('Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.');\n            }\n\n            persister.removeClient();\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 8]]);\n  }));\n  return _persistQueryClientRestore.apply(this, arguments);\n}\n\nfunction persistQueryClientSave(_x2) {\n  return _persistQueryClientSave.apply(this, arguments);\n}\n/**\n * Subscribe to QueryCache and MutationCache updates (for persisting)\n * @returns an unsubscribe function (to discontinue monitoring)\n */\n\n\nfunction _persistQueryClientSave() {\n  _persistQueryClientSave = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {\n    var queryClient, persister, _ref2$buster, buster, dehydrateOptions, persistClient;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            queryClient = _ref2.queryClient, persister = _ref2.persister, _ref2$buster = _ref2.buster, buster = _ref2$buster === void 0 ? '' : _ref2$buster, dehydrateOptions = _ref2.dehydrateOptions;\n            persistClient = {\n              buster: buster,\n              timestamp: Date.now(),\n              clientState: dehydrate(queryClient, dehydrateOptions)\n            };\n            _context2.next = 4;\n            return persister.persistClient(persistClient);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _persistQueryClientSave.apply(this, arguments);\n}\n\nfunction persistQueryClientSubscribe(props) {\n  var unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe(function () {\n    persistQueryClientSave(props);\n  });\n  var unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe(function () {\n    persistQueryClientSave(props);\n  });\n  return function () {\n    unsubscribeQueryCache();\n    unusbscribeMutationCache();\n  };\n}\n/**\n * Restores persisted data to QueryCache and persists further changes.\n */\n\n\nfunction persistQueryClient(props) {\n  var hasUnsubscribed = false;\n  var persistQueryClientUnsubscribe;\n\n  var unsubscribe = function unsubscribe() {\n    hasUnsubscribed = true;\n    persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();\n  }; // Attempt restore\n\n\n  var restorePromise = persistQueryClientRestore(props).then(function () {\n    if (!hasUnsubscribed) {\n      // Subscribe to changes in the query cache to trigger the save\n      persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);\n    }\n  });\n  return [unsubscribe, restorePromise];\n}\n\nexport { persistQueryClient, persistQueryClientRestore, persistQueryClientSave, persistQueryClientSubscribe }; //# sourceMappingURL=persist.mjs.map","map":null,"metadata":{},"sourceType":"module"}