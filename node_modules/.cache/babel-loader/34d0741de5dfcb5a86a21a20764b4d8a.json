{"ast":null,"code":"import _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty2 from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { l as Connector, _ as _classPrivateMethodInitSpec, t as _defineProperty, u as _classPrivateFieldInitSpec, n as normalizeChainId, g as getClient, x as _classPrivateMethodGet, U as UserRejectedRequestError, v as _classPrivateFieldGet, w as _classPrivateFieldSet, q as SwitchChainError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport { providers } from 'ethers';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n/**\n * Wallets that support chain switching through WalletConnect\n * - imToken (token.im)\n * - MetaMask (metamask.io)\n * - Rainbow (rainbow.me)\n */\n\nvar switchChainAllowedRegex = /(imtoken|metamask|rainbow)/i;\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchChain = /*#__PURE__*/new WeakSet();\n\nvar WalletConnectConnector = /*#__PURE__*/function (_Connector) {\n  _inherits(WalletConnectConnector, _Connector);\n\n  var _super = _createSuper(WalletConnectConnector);\n\n  function WalletConnectConnector(config) {\n    var _this;\n\n    _classCallCheck(this, WalletConnectConnector);\n\n    _this = _super.call(this, config);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _switchChain);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", 'walletConnect');\n\n    _defineProperty(_assertThisInitialized(_this), \"name\", 'WalletConnect');\n\n    _defineProperty(_assertThisInitialized(_this), \"ready\", true);\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onAccountsChanged\", function (accounts) {\n      if (accounts.length === 0) _this.emit('disconnect');else _this.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onChainChanged\", function (chainId) {\n      var id = normalizeChainId(chainId);\n\n      var unsupported = _this.isChainUnsupported(id);\n\n      _this.emit('change', {\n        chain: {\n          id: id,\n          unsupported: unsupported\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onDisconnect\", function () {\n      _this.emit('disconnect');\n    });\n\n    return _this;\n  }\n\n  _createClass(WalletConnectConnector, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var _ref,\n            chainId,\n            _provider$connector$p,\n            _provider$connector,\n            _provider$connector$p2,\n            targetChainId,\n            lastUsedChainId,\n            provider,\n            accounts,\n            account,\n            id,\n            unsupported,\n            walletName,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, chainId = _ref.chainId;\n                _context.prev = 1;\n                targetChainId = chainId;\n\n                if (!targetChainId) {\n                  lastUsedChainId = getClient().lastUsedChainId;\n                  if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;\n                }\n\n                _context.next = 6;\n                return this.getProvider({\n                  chainId: targetChainId,\n                  create: true\n                });\n\n              case 6:\n                provider = _context.sent;\n                provider.on('accountsChanged', this.onAccountsChanged);\n                provider.on('chainChanged', this.onChainChanged);\n                provider.on('disconnect', this.onDisconnect); // Defer message to the next tick to ensure wallet connect data (provided by `.enable()`) is available\n\n                setTimeout(function () {\n                  return _this2.emit('message', {\n                    type: 'connecting'\n                  });\n                }, 0);\n                _context.next = 13;\n                return provider.enable();\n\n              case 13:\n                accounts = _context.sent;\n                account = getAddress(accounts[0]);\n                _context.next = 17;\n                return this.getChainId();\n\n              case 17:\n                id = _context.sent;\n                unsupported = this.isChainUnsupported(id); // Not all WalletConnect options support programmatic chain switching\n                // Only enable for wallet options that do\n\n                walletName = (_provider$connector$p = (_provider$connector = provider.connector) === null || _provider$connector === void 0 ? void 0 : (_provider$connector$p2 = _provider$connector.peerMeta) === null || _provider$connector$p2 === void 0 ? void 0 : _provider$connector$p2.name) !== null && _provider$connector$p !== void 0 ? _provider$connector$p : '';\n                if (switchChainAllowedRegex.test(walletName)) this.switchChain = _classPrivateMethodGet(this, _switchChain, _switchChain2);\n                return _context.abrupt(\"return\", {\n                  account: account,\n                  chain: {\n                    id: id,\n                    unsupported: unsupported\n                  },\n                  provider: new providers.Web3Provider(provider)\n                });\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!/user closed modal/i.test(_context.t0.message)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                throw new UserRejectedRequestError(_context.t0);\n\n              case 28:\n                throw _context.t0;\n\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 24]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context2.sent;\n                _context2.next = 5;\n                return provider.disconnect();\n\n              case 5:\n                provider.removeListener('accountsChanged', this.onAccountsChanged);\n                provider.removeListener('chainChanged', this.onChainChanged);\n                provider.removeListener('disconnect', this.onDisconnect);\n                typeof localStorage !== 'undefined' && localStorage.removeItem('walletconnect');\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var provider, accounts;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context3.sent;\n                accounts = provider.accounts; // return checksum address\n\n                return _context3.abrupt(\"return\", getAddress(accounts[0]));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAccount() {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var provider, chainId;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context4.sent;\n                chainId = normalizeChainId(provider.chainId);\n                return _context4.abrupt(\"return\", chainId);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getProvider\",\n    value: function () {\n      var _getProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _ref2,\n            chainId,\n            create,\n            _this$options,\n            _this$options2,\n            rpc,\n            WalletConnectProvider,\n            _args5 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _ref2 = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {}, chainId = _ref2.chainId, create = _ref2.create; // Force create new provider\n\n                if (!(!_classPrivateFieldGet(this, _provider) || chainId || create)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                rpc = !((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.infuraId) ? this.chains.reduce(function (rpc, chain) {\n                  return _objectSpread(_objectSpread({}, rpc), {}, _defineProperty2({}, chain.id, chain.rpcUrls.default));\n                }, {}) : {};\n                _context5.next = 5;\n                return import('@walletconnect/ethereum-provider');\n\n              case 5:\n                WalletConnectProvider = _context5.sent.default;\n\n                _classPrivateFieldSet(this, _provider, new WalletConnectProvider(_objectSpread(_objectSpread({}, this.options), {}, {\n                  chainId: chainId,\n                  rpc: _objectSpread(_objectSpread({}, rpc), (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.rpc)\n                })));\n\n              case 7:\n                return _context5.abrupt(\"return\", _classPrivateFieldGet(this, _provider));\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getProvider() {\n        return _getProvider.apply(this, arguments);\n      }\n\n      return getProvider;\n    }()\n  }, {\n    key: \"getSigner\",\n    value: function () {\n      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _ref3,\n            chainId,\n            _yield$Promise$all,\n            _yield$Promise$all2,\n            provider,\n            account,\n            _args6 = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _ref3 = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : {}, chainId = _ref3.chainId;\n                _context6.next = 3;\n                return Promise.all([this.getProvider({\n                  chainId: chainId\n                }), this.getAccount()]);\n\n              case 3:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                provider = _yield$Promise$all2[0];\n                account = _yield$Promise$all2[1];\n                return _context6.abrupt(\"return\", new providers.Web3Provider(provider).getSigner(account));\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getSigner() {\n        return _getSigner.apply(this, arguments);\n      }\n\n      return getSigner;\n    }()\n  }, {\n    key: \"isAuthorized\",\n    value: function () {\n      var _isAuthorized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var account;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return this.getAccount();\n\n              case 3:\n                account = _context7.sent;\n                return _context7.abrupt(\"return\", !!account);\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", false);\n\n              case 10:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n\n      function isAuthorized() {\n        return _isAuthorized.apply(this, arguments);\n      }\n\n      return isAuthorized;\n    }()\n  }]);\n\n  return WalletConnectConnector;\n}(Connector);\n\nfunction _switchChain2(_x) {\n  return _switchChain3.apply(this, arguments);\n}\n\nfunction _switchChain3() {\n  _switchChain3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(chainId) {\n    var provider, id, _this$chains$find, message;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return this.getProvider();\n\n          case 2:\n            provider = _context8.sent;\n            id = hexValue(chainId);\n            _context8.prev = 4;\n            _context8.next = 7;\n            return provider.request({\n              method: 'wallet_switchEthereumChain',\n              params: [{\n                chainId: id\n              }]\n            });\n\n          case 7:\n            return _context8.abrupt(\"return\", (_this$chains$find = this.chains.find(function (x) {\n              return x.id === chainId;\n            })) !== null && _this$chains$find !== void 0 ? _this$chains$find : {\n              id: chainId,\n              name: \"Chain \".concat(id),\n              network: \"\".concat(id),\n              rpcUrls: {\n                default: ''\n              }\n            });\n\n          case 10:\n            _context8.prev = 10;\n            _context8.t0 = _context8[\"catch\"](4);\n            message = typeof _context8.t0 === 'string' ? _context8.t0 : _context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message;\n\n            if (!/user rejected request/i.test(message)) {\n              _context8.next = 15;\n              break;\n            }\n\n            throw new UserRejectedRequestError(_context8.t0);\n\n          case 15:\n            throw new SwitchChainError(_context8.t0);\n\n          case 16:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, this, [[4, 10]]);\n  }));\n  return _switchChain3.apply(this, arguments);\n}\n\nexport { WalletConnectConnector };","map":null,"metadata":{},"sourceType":"module"}