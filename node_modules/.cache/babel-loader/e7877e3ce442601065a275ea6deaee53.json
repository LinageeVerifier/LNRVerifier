{"ast":null,"code":"import _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { sleep } from './utils.mjs';\n\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1000 * Math.pow(2, failureCount), 30000);\n}\n\nfunction canFetch(networkMode) {\n  return (networkMode != null ? networkMode : 'online') === 'online' ? onlineManager.isOnline() : true;\n}\n\nvar CancelledError = /*#__PURE__*/_createClass(function CancelledError(options) {\n  _classCallCheck(this, CancelledError);\n\n  this.revert = options == null ? void 0 : options.revert;\n  this.silent = options == null ? void 0 : options.silent;\n});\n\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\n\nfunction createRetryer(config) {\n  var isRetryCancelled = false;\n  var failureCount = 0;\n  var isResolved = false;\n  var continueFn;\n  var promiseResolve;\n  var promiseReject;\n  var promise = new Promise(function (outerResolve, outerReject) {\n    promiseResolve = outerResolve;\n    promiseReject = outerReject;\n  });\n\n  var cancel = function cancel(cancelOptions) {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions));\n      config.abort == null ? void 0 : config.abort();\n    }\n  };\n\n  var cancelRetry = function cancelRetry() {\n    isRetryCancelled = true;\n  };\n\n  var continueRetry = function continueRetry() {\n    isRetryCancelled = false;\n  };\n\n  var shouldPause = function shouldPause() {\n    return !focusManager.isFocused() || config.networkMode !== 'always' && !onlineManager.isOnline();\n  };\n\n  var resolve = function resolve(value) {\n    if (!isResolved) {\n      isResolved = true;\n      config.onSuccess == null ? void 0 : config.onSuccess(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseResolve(value);\n    }\n  };\n\n  var reject = function reject(value) {\n    if (!isResolved) {\n      isResolved = true;\n      config.onError == null ? void 0 : config.onError(value);\n      continueFn == null ? void 0 : continueFn();\n      promiseReject(value);\n    }\n  };\n\n  var pause = function pause() {\n    return new Promise(function (continueResolve) {\n      continueFn = function continueFn(value) {\n        if (isResolved || !shouldPause()) {\n          return continueResolve(value);\n        }\n      };\n\n      config.onPause == null ? void 0 : config.onPause();\n    }).then(function () {\n      continueFn = undefined;\n\n      if (!isResolved) {\n        config.onContinue == null ? void 0 : config.onContinue();\n      }\n    });\n  }; // Create loop function\n\n\n  var run = function run() {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return;\n    }\n\n    var promiseOrValue; // Execute query\n\n    try {\n      promiseOrValue = config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n\n    Promise.resolve(promiseOrValue).then(resolve).catch(function (error) {\n      var _config$retry, _config$retryDelay; // Stop if the fetch is already resolved\n\n\n      if (isResolved) {\n        return;\n      } // Do we need to retry the request?\n\n\n      var retry = (_config$retry = config.retry) != null ? _config$retry : 3;\n      var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;\n      var delay = typeof retryDelay === 'function' ? retryDelay(failureCount, error) : retryDelay;\n      var shouldRetry = retry === true || typeof retry === 'number' && failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n      if (isRetryCancelled || !shouldRetry) {\n        // We are done if the query does not need to be retried\n        reject(error);\n        return;\n      }\n\n      failureCount++; // Notify on fail\n\n      config.onFail == null ? void 0 : config.onFail(failureCount, error); // Delay\n\n      sleep(delay) // Pause if the document is not visible or when the device is offline\n      .then(function () {\n        if (shouldPause()) {\n          return pause();\n        }\n      }).then(function () {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  }; // Start loop\n\n\n  if (canFetch(config.networkMode)) {\n    run();\n  } else {\n    pause().then(run);\n  }\n\n  return {\n    promise: promise,\n    cancel: cancel,\n    continue: function _continue() {\n      continueFn == null ? void 0 : continueFn();\n    },\n    cancelRetry: cancelRetry,\n    continueRetry: continueRetry\n  };\n}\n\nexport { CancelledError, canFetch, createRetryer, isCancelledError }; //# sourceMappingURL=retryer.mjs.map","map":null,"metadata":{},"sourceType":"module"}