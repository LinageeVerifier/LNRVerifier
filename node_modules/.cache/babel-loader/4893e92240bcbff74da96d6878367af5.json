{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { I as InjectedConnector, _ as _classPrivateMethodInitSpec, t as _defineProperty, x as _classPrivateMethodGet, u as _classPrivateFieldInitSpec, w as _classPrivateFieldSet, a as ConnectorNotFoundError, v as _classPrivateFieldGet, g as getClient, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'ethers';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\n\nvar _getReady = /*#__PURE__*/new WeakSet();\n\nvar _findProvider = /*#__PURE__*/new WeakSet();\n\nvar MetaMaskConnector = /*#__PURE__*/function (_InjectedConnector) {\n  _inherits(MetaMaskConnector, _InjectedConnector);\n\n  var _super = _createSuper(MetaMaskConnector);\n\n  function MetaMaskConnector() {\n    var _this;\n\n    _classCallCheck(this, MetaMaskConnector);\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        chains = _ref.chains,\n        options_ = _ref.options;\n\n    var options = _objectSpread({\n      name: 'MetaMask',\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true\n    }, options_);\n\n    _this = _super.call(this, {\n      chains: chains,\n      options: options\n    });\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _findProvider);\n\n    _classPrivateMethodInitSpec(_assertThisInitialized(_this), _getReady);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", 'metaMask');\n\n    _defineProperty(_assertThisInitialized(_this), \"ready\", typeof window != 'undefined' && !!_classPrivateMethodGet(_assertThisInitialized(_this), _findProvider, _findProvider2).call(_assertThisInitialized(_this), window.ethereum));\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(_assertThisInitialized(_this), _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n\n    return _this;\n  }\n\n  _createClass(MetaMaskConnector, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _ref2,\n            chainId,\n            _this$options,\n            _getClient$storage,\n            _this$options2,\n            _getClient$storage2,\n            provider,\n            accounts,\n            isConnected,\n            account,\n            id,\n            unsupported,\n            chain,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref2 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, chainId = _ref2.chainId;\n                _context.prev = 1;\n                _context.next = 4;\n                return this.getProvider();\n\n              case 4:\n                provider = _context.sent;\n\n                if (provider) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 7:\n                if (provider.on) {\n                  provider.on('accountsChanged', this.onAccountsChanged);\n                  provider.on('chainChanged', this.onChainChanged);\n                  provider.on('disconnect', this.onDisconnect);\n                }\n\n                this.emit('message', {\n                  type: 'connecting'\n                }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n                // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n\n                if (!(_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && (_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect && !((_getClient$storage = getClient().storage) !== null && _getClient$storage !== void 0 && _getClient$storage.getItem(this.shimDisconnectKey)))) {\n                  _context.next = 17;\n                  break;\n                }\n\n                _context.next = 12;\n                return provider.request({\n                  method: 'eth_accounts'\n                }).catch(function () {\n                  return [];\n                });\n\n              case 12:\n                accounts = _context.sent;\n                isConnected = !!accounts[0];\n\n                if (!isConnected) {\n                  _context.next = 17;\n                  break;\n                }\n\n                _context.next = 17;\n                return provider.request({\n                  method: 'wallet_requestPermissions',\n                  params: [{\n                    eth_accounts: {}\n                  }]\n                });\n\n              case 17:\n                _context.next = 19;\n                return this.getAccount();\n\n              case 19:\n                account = _context.sent;\n                _context.next = 22;\n                return this.getChainId();\n\n              case 22:\n                id = _context.sent;\n                unsupported = this.isChainUnsupported(id);\n\n                if (!(chainId && id !== chainId)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                _context.next = 27;\n                return this.switchChain(chainId);\n\n              case 27:\n                chain = _context.sent;\n                id = chain.id;\n                unsupported = this.isChainUnsupported(id);\n\n              case 30:\n                if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(this.shimDisconnectKey, true);\n                return _context.abrupt(\"return\", {\n                  account: account,\n                  chain: {\n                    id: id,\n                    unsupported: unsupported\n                  },\n                  provider: provider\n                });\n\n              case 34:\n                _context.prev = 34;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!this.isUserRejectedRequestError(_context.t0)) {\n                  _context.next = 38;\n                  break;\n                }\n\n                throw new UserRejectedRequestError(_context.t0);\n\n              case 38:\n                if (!(_context.t0.code === -32002)) {\n                  _context.next = 40;\n                  break;\n                }\n\n                throw new ResourceUnavailableError(_context.t0);\n\n              case 40:\n                throw _context.t0;\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 34]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"getProvider\",\n    value: function () {\n      var _getProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (typeof window !== 'undefined') {\n                  // TODO: Fallback to `ethereum#initialized` event for async injection\n                  // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=\n                  _classPrivateFieldSet(this, _provider, _classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));\n                }\n\n                return _context2.abrupt(\"return\", _classPrivateFieldGet(this, _provider));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getProvider() {\n        return _getProvider.apply(this, arguments);\n      }\n\n      return getProvider;\n    }()\n  }]);\n\n  return MetaMaskConnector;\n}(InjectedConnector);\n\nfunction _getReady2(ethereum) {\n  var isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);\n  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask\n  // Could also try RPC `web3_clientVersion` if following is unreliable\n\n  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;\n  if (ethereum.isTokenPocket) return;\n  if (ethereum.isTokenary) return;\n  return ethereum;\n}\n\nfunction _findProvider2(ethereum) {\n  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(_classPrivateMethodGet(this, _getReady, _getReady2));\n  return _classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);\n}\n\nexport { MetaMaskConnector };","map":null,"metadata":{},"sourceType":"module"}