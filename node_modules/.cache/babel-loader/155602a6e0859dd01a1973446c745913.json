{"ast":null,"code":"import { l as Connector, _ as _classPrivateMethodInitSpec, t as _defineProperty, u as _classPrivateFieldInitSpec, n as normalizeChainId, g as getClient, x as _classPrivateMethodGet, U as UserRejectedRequestError, v as _classPrivateFieldGet, w as _classPrivateFieldSet, q as SwitchChainError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport { providers } from 'ethers';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n/**\n * Wallets that support chain switching through WalletConnect\n * - imToken (token.im)\n * - MetaMask (metamask.io)\n * - Rainbow (rainbow.me)\n */\n\nconst switchChainAllowedRegex = /(imtoken|metamask|rainbow)/i;\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchChain = /*#__PURE__*/new WeakSet();\n\nclass WalletConnectConnector extends Connector {\n  constructor(config) {\n    super(config);\n\n    _classPrivateMethodInitSpec(this, _switchChain);\n\n    _defineProperty(this, \"id\", 'walletConnect');\n\n    _defineProperty(this, \"name\", 'WalletConnect');\n\n    _defineProperty(this, \"ready\", true);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", () => {\n      this.emit('disconnect');\n    });\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _provider$connector$p, _provider$connector, _provider$connector$p2;\n\n      let targetChainId = chainId;\n\n      if (!targetChainId) {\n        const lastUsedChainId = getClient().lastUsedChainId;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;\n      }\n\n      const provider = await this.getProvider({\n        chainId: targetChainId,\n        create: true\n      });\n      provider.on('accountsChanged', this.onAccountsChanged);\n      provider.on('chainChanged', this.onChainChanged);\n      provider.on('disconnect', this.onDisconnect); // Defer message to the next tick to ensure wallet connect data (provided by `.enable()`) is available\n\n      setTimeout(() => this.emit('message', {\n        type: 'connecting'\n      }), 0);\n      const accounts = await provider.enable();\n      const account = getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id); // Not all WalletConnect options support programmatic chain switching\n      // Only enable for wallet options that do\n\n      const walletName = (_provider$connector$p = (_provider$connector = provider.connector) === null || _provider$connector === void 0 ? void 0 : (_provider$connector$p2 = _provider$connector.peerMeta) === null || _provider$connector$p2 === void 0 ? void 0 : _provider$connector$p2.name) !== null && _provider$connector$p !== void 0 ? _provider$connector$p : '';\n      if (switchChainAllowedRegex.test(walletName)) this.switchChain = _classPrivateMethodGet(this, _switchChain, _switchChain2);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user closed modal/i.test(error.message)) throw new UserRejectedRequestError(error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    const provider = await this.getProvider();\n    await provider.disconnect();\n    provider.removeListener('accountsChanged', this.onAccountsChanged);\n    provider.removeListener('chainChanged', this.onChainChanged);\n    provider.removeListener('disconnect', this.onDisconnect);\n    typeof localStorage !== 'undefined' && localStorage.removeItem('walletconnect');\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    const accounts = provider.accounts; // return checksum address\n\n    return getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    const chainId = normalizeChainId(provider.chainId);\n    return chainId;\n  }\n\n  async getProvider() {\n    let {\n      chainId,\n      create\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Force create new provider\n\n    if (!_classPrivateFieldGet(this, _provider) || chainId || create) {\n      var _this$options, _this$options2;\n\n      const rpc = !((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.infuraId) ? this.chains.reduce((rpc, chain) => ({ ...rpc,\n        [chain.id]: chain.rpcUrls.default\n      }), {}) : {};\n      const WalletConnectProvider = (await import('@walletconnect/ethereum-provider')).default;\n\n      _classPrivateFieldSet(this, _provider, new WalletConnectProvider({ ...this.options,\n        chainId,\n        rpc: { ...rpc,\n          ...((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.rpc)\n        }\n      }));\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n}\n\nasync function _switchChain2(chainId) {\n  const provider = await this.getProvider();\n  const id = hexValue(chainId);\n\n  try {\n    var _this$chains$find;\n\n    await provider.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{\n        chainId: id\n      }]\n    });\n    return (_this$chains$find = this.chains.find(x => x.id === chainId)) !== null && _this$chains$find !== void 0 ? _this$chains$find : {\n      id: chainId,\n      name: \"Chain \".concat(id),\n      network: \"\".concat(id),\n      rpcUrls: {\n        default: ''\n      }\n    };\n  } catch (error) {\n    const message = typeof error === 'string' ? error : error === null || error === void 0 ? void 0 : error.message;\n    if (/user rejected request/i.test(message)) throw new UserRejectedRequestError(error);\n    throw new SwitchChainError(error);\n  }\n}\n\nexport { WalletConnectConnector };","map":{"version":3,"names":["l","Connector","_","_classPrivateMethodInitSpec","t","_defineProperty","u","_classPrivateFieldInitSpec","n","normalizeChainId","g","getClient","x","_classPrivateMethodGet","U","UserRejectedRequestError","v","_classPrivateFieldGet","w","_classPrivateFieldSet","q","SwitchChainError","providers","getAddress","hexValue","switchChainAllowedRegex","_provider","WeakMap","_switchChain","WeakSet","WalletConnectConnector","constructor","config","writable","value","accounts","length","emit","account","chainId","id","unsupported","isChainUnsupported","chain","connect","arguments","undefined","_provider$connector$p","_provider$connector","_provider$connector$p2","targetChainId","lastUsedChainId","provider","getProvider","create","on","onAccountsChanged","onChainChanged","onDisconnect","setTimeout","type","enable","getChainId","walletName","connector","peerMeta","name","test","switchChain","_switchChain2","Web3Provider","error","message","disconnect","removeListener","localStorage","removeItem","getAccount","_this$options","_this$options2","rpc","options","infuraId","chains","reduce","rpcUrls","default","WalletConnectProvider","getSigner","Promise","all","isAuthorized","_this$chains$find","request","method","params","find","concat","network"],"sources":["C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@wagmi/core/connectors/walletConnect/dist/wagmi-core-connectors-walletConnect.esm.js"],"sourcesContent":["import { l as Connector, _ as _classPrivateMethodInitSpec, t as _defineProperty, u as _classPrivateFieldInitSpec, n as normalizeChainId, g as getClient, x as _classPrivateMethodGet, U as UserRejectedRequestError, v as _classPrivateFieldGet, w as _classPrivateFieldSet, q as SwitchChainError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport { providers } from 'ethers';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n\n/**\n * Wallets that support chain switching through WalletConnect\n * - imToken (token.im)\n * - MetaMask (metamask.io)\n * - Rainbow (rainbow.me)\n */\n\nconst switchChainAllowedRegex = /(imtoken|metamask|rainbow)/i;\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchChain = /*#__PURE__*/new WeakSet();\n\nclass WalletConnectConnector extends Connector {\n  constructor(config) {\n    super(config);\n\n    _classPrivateMethodInitSpec(this, _switchChain);\n\n    _defineProperty(this, \"id\", 'walletConnect');\n\n    _defineProperty(this, \"name\", 'WalletConnect');\n\n    _defineProperty(this, \"ready\", true);\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(this, \"onAccountsChanged\", accounts => {\n      if (accounts.length === 0) this.emit('disconnect');else this.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit('change', {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n\n    _defineProperty(this, \"onDisconnect\", () => {\n      this.emit('disconnect');\n    });\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _provider$connector$p, _provider$connector, _provider$connector$p2;\n\n      let targetChainId = chainId;\n\n      if (!targetChainId) {\n        const lastUsedChainId = getClient().lastUsedChainId;\n        if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) targetChainId = lastUsedChainId;\n      }\n\n      const provider = await this.getProvider({\n        chainId: targetChainId,\n        create: true\n      });\n      provider.on('accountsChanged', this.onAccountsChanged);\n      provider.on('chainChanged', this.onChainChanged);\n      provider.on('disconnect', this.onDisconnect); // Defer message to the next tick to ensure wallet connect data (provided by `.enable()`) is available\n\n      setTimeout(() => this.emit('message', {\n        type: 'connecting'\n      }), 0);\n      const accounts = await provider.enable();\n      const account = getAddress(accounts[0]);\n      const id = await this.getChainId();\n      const unsupported = this.isChainUnsupported(id); // Not all WalletConnect options support programmatic chain switching\n      // Only enable for wallet options that do\n\n      const walletName = (_provider$connector$p = (_provider$connector = provider.connector) === null || _provider$connector === void 0 ? void 0 : (_provider$connector$p2 = _provider$connector.peerMeta) === null || _provider$connector$p2 === void 0 ? void 0 : _provider$connector$p2.name) !== null && _provider$connector$p !== void 0 ? _provider$connector$p : '';\n      if (switchChainAllowedRegex.test(walletName)) this.switchChain = _classPrivateMethodGet(this, _switchChain, _switchChain2);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider: new providers.Web3Provider(provider)\n      };\n    } catch (error) {\n      if (/user closed modal/i.test(error.message)) throw new UserRejectedRequestError(error);\n      throw error;\n    }\n  }\n\n  async disconnect() {\n    const provider = await this.getProvider();\n    await provider.disconnect();\n    provider.removeListener('accountsChanged', this.onAccountsChanged);\n    provider.removeListener('chainChanged', this.onChainChanged);\n    provider.removeListener('disconnect', this.onDisconnect);\n    typeof localStorage !== 'undefined' && localStorage.removeItem('walletconnect');\n  }\n\n  async getAccount() {\n    const provider = await this.getProvider();\n    const accounts = provider.accounts; // return checksum address\n\n    return getAddress(accounts[0]);\n  }\n\n  async getChainId() {\n    const provider = await this.getProvider();\n    const chainId = normalizeChainId(provider.chainId);\n    return chainId;\n  }\n\n  async getProvider() {\n    let {\n      chainId,\n      create\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Force create new provider\n    if (!_classPrivateFieldGet(this, _provider) || chainId || create) {\n      var _this$options, _this$options2;\n\n      const rpc = !((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.infuraId) ? this.chains.reduce((rpc, chain) => ({ ...rpc,\n        [chain.id]: chain.rpcUrls.default\n      }), {}) : {};\n      const WalletConnectProvider = (await import('@walletconnect/ethereum-provider')).default;\n\n      _classPrivateFieldSet(this, _provider, new WalletConnectProvider({ ...this.options,\n        chainId,\n        rpc: { ...rpc,\n          ...((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.rpc)\n        }\n      }));\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider({\n      chainId\n    }), this.getAccount()]);\n    return new providers.Web3Provider(provider).getSigner(account);\n  }\n\n  async isAuthorized() {\n    try {\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n\n}\n\nasync function _switchChain2(chainId) {\n  const provider = await this.getProvider();\n  const id = hexValue(chainId);\n\n  try {\n    var _this$chains$find;\n\n    await provider.request({\n      method: 'wallet_switchEthereumChain',\n      params: [{\n        chainId: id\n      }]\n    });\n    return (_this$chains$find = this.chains.find(x => x.id === chainId)) !== null && _this$chains$find !== void 0 ? _this$chains$find : {\n      id: chainId,\n      name: \"Chain \".concat(id),\n      network: \"\".concat(id),\n      rpcUrls: {\n        default: ''\n      }\n    };\n  } catch (error) {\n    const message = typeof error === 'string' ? error : error === null || error === void 0 ? void 0 : error.message;\n    if (/user rejected request/i.test(message)) throw new UserRejectedRequestError(error);\n    throw new SwitchChainError(error);\n  }\n}\n\nexport { WalletConnectConnector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}