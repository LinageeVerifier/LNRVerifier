{"ast":null,"code":"import { I as InjectedConnector, _ as _classPrivateMethodInitSpec, t as _defineProperty, x as _classPrivateMethodGet, u as _classPrivateFieldInitSpec, w as _classPrivateFieldSet, a as ConnectorNotFoundError, v as _classPrivateFieldGet, g as getClient, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'ethers';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\n\nvar _getReady = /*#__PURE__*/new WeakSet();\n\nvar _findProvider = /*#__PURE__*/new WeakSet();\n\nclass MetaMaskConnector extends InjectedConnector {\n  constructor() {\n    let {\n      chains,\n      options: options_\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      name: 'MetaMask',\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      ...options_\n    };\n    super({\n      chains,\n      options\n    });\n\n    _classPrivateMethodInitSpec(this, _findProvider);\n\n    _classPrivateMethodInitSpec(this, _getReady);\n\n    _defineProperty(this, \"id\", 'metaMask');\n\n    _defineProperty(this, \"ready\", typeof window != 'undefined' && !!_classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _this$options, _getClient$storage, _this$options2, _getClient$storage2;\n\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n\n      if (provider.on) {\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect);\n      }\n\n      this.emit('message', {\n        type: 'connecting'\n      }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && (_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect && !((_getClient$storage = getClient().storage) !== null && _getClient$storage !== void 0 && _getClient$storage.getItem(this.shimDisconnectKey))) {\n        const accounts = await provider.request({\n          method: 'eth_accounts'\n        }).catch(() => []);\n        const isConnected = !!accounts[0];\n        if (isConnected) await provider.request({\n          method: 'wallet_requestPermissions',\n          params: [{\n            eth_accounts: {}\n          }]\n        });\n      }\n\n      const account = await this.getAccount(); // Switch to chain if provided\n\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(this.shimDisconnectKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n\n  async getProvider() {\n    if (typeof window !== 'undefined') {\n      // TODO: Fallback to `ethereum#initialized` event for async injection\n      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=\n      _classPrivateFieldSet(this, _provider, _classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n}\n\nfunction _getReady2(ethereum) {\n  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);\n  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask\n  // Could also try RPC `web3_clientVersion` if following is unreliable\n\n  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;\n  if (ethereum.isTokenPocket) return;\n  if (ethereum.isTokenary) return;\n  return ethereum;\n}\n\nfunction _findProvider2(ethereum) {\n  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(_classPrivateMethodGet(this, _getReady, _getReady2));\n  return _classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);\n}\n\nexport { MetaMaskConnector };","map":{"version":3,"names":["I","InjectedConnector","_","_classPrivateMethodInitSpec","t","_defineProperty","x","_classPrivateMethodGet","u","_classPrivateFieldInitSpec","w","_classPrivateFieldSet","a","ConnectorNotFoundError","v","_classPrivateFieldGet","g","getClient","U","UserRejectedRequestError","R","ResourceUnavailableError","_provider","WeakMap","_UNSTABLE_shimOnConnectSelectAccount","_getReady","WeakSet","_findProvider","MetaMaskConnector","constructor","chains","options","options_","arguments","length","undefined","name","shimDisconnect","shimChainChangedDisconnect","window","_findProvider2","call","ethereum","writable","value","UNSTABLE_shimOnConnectSelectAccount","connect","chainId","_this$options","_getClient$storage","_this$options2","_getClient$storage2","provider","getProvider","on","onAccountsChanged","onChainChanged","onDisconnect","emit","type","storage","getItem","shimDisconnectKey","accounts","request","method","catch","isConnected","params","eth_accounts","account","getAccount","id","getChainId","unsupported","isChainUnsupported","chain","switchChain","setItem","error","isUserRejectedRequestError","code","_getReady2","isMetaMask","isBraveWallet","_events","_state","isTokenPocket","isTokenary","providers","find"],"sources":["C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@wagmi/core/connectors/metaMask/dist/wagmi-core-connectors-metaMask.esm.js"],"sourcesContent":["import { I as InjectedConnector, _ as _classPrivateMethodInitSpec, t as _defineProperty, x as _classPrivateMethodGet, u as _classPrivateFieldInitSpec, w as _classPrivateFieldSet, a as ConnectorNotFoundError, v as _classPrivateFieldGet, g as getClient, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../dist/getProvider-f1dfc7e3.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'ethers';\nimport 'ethers/lib/utils';\nimport 'eventemitter3';\nimport '../../../dist/chains-8c76af1b.esm.js';\nimport '../../../dist/rpcs-8d636858.esm.js';\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _UNSTABLE_shimOnConnectSelectAccount = /*#__PURE__*/new WeakMap();\n\nvar _getReady = /*#__PURE__*/new WeakSet();\n\nvar _findProvider = /*#__PURE__*/new WeakSet();\n\nclass MetaMaskConnector extends InjectedConnector {\n  constructor() {\n    let {\n      chains,\n      options: options_\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      name: 'MetaMask',\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      ...options_\n    };\n    super({\n      chains,\n      options\n    });\n\n    _classPrivateMethodInitSpec(this, _findProvider);\n\n    _classPrivateMethodInitSpec(this, _getReady);\n\n    _defineProperty(this, \"id\", 'metaMask');\n\n    _defineProperty(this, \"ready\", typeof window != 'undefined' && !!_classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));\n\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _UNSTABLE_shimOnConnectSelectAccount, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldSet(this, _UNSTABLE_shimOnConnectSelectAccount, options.UNSTABLE_shimOnConnectSelectAccount);\n  }\n\n  async connect() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      var _this$options, _getClient$storage, _this$options2, _getClient$storage2;\n\n      const provider = await this.getProvider();\n      if (!provider) throw new ConnectorNotFoundError();\n\n      if (provider.on) {\n        provider.on('accountsChanged', this.onAccountsChanged);\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect);\n      }\n\n      this.emit('message', {\n        type: 'connecting'\n      }); // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n\n      if (_classPrivateFieldGet(this, _UNSTABLE_shimOnConnectSelectAccount) && (_this$options = this.options) !== null && _this$options !== void 0 && _this$options.shimDisconnect && !((_getClient$storage = getClient().storage) !== null && _getClient$storage !== void 0 && _getClient$storage.getItem(this.shimDisconnectKey))) {\n        const accounts = await provider.request({\n          method: 'eth_accounts'\n        }).catch(() => []);\n        const isConnected = !!accounts[0];\n        if (isConnected) await provider.request({\n          method: 'wallet_requestPermissions',\n          params: [{\n            eth_accounts: {}\n          }]\n        });\n      }\n\n      const account = await this.getAccount(); // Switch to chain if provided\n\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n\n      if ((_this$options2 = this.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(this.shimDisconnectKey, true);\n      return {\n        account,\n        chain: {\n          id,\n          unsupported\n        },\n        provider\n      };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) throw new UserRejectedRequestError(error);\n      if (error.code === -32002) throw new ResourceUnavailableError(error);\n      throw error;\n    }\n  }\n\n  async getProvider() {\n    if (typeof window !== 'undefined') {\n      // TODO: Fallback to `ethereum#initialized` event for async injection\n      // https://github.com/MetaMask/detect-provider#synchronous-and-asynchronous-injection=\n      _classPrivateFieldSet(this, _provider, _classPrivateMethodGet(this, _findProvider, _findProvider2).call(this, window.ethereum));\n    }\n\n    return _classPrivateFieldGet(this, _provider);\n  }\n\n}\n\nfunction _getReady2(ethereum) {\n  const isMetaMask = !!(ethereum !== null && ethereum !== void 0 && ethereum.isMetaMask);\n  if (!isMetaMask) return; // Brave tries to make itself look like MetaMask\n  // Could also try RPC `web3_clientVersion` if following is unreliable\n\n  if (ethereum.isBraveWallet && !ethereum._events && !ethereum._state) return;\n  if (ethereum.isTokenPocket) return;\n  if (ethereum.isTokenary) return;\n  return ethereum;\n}\n\nfunction _findProvider2(ethereum) {\n  if (ethereum !== null && ethereum !== void 0 && ethereum.providers) return ethereum.providers.find(_classPrivateMethodGet(this, _getReady, _getReady2));\n  return _classPrivateMethodGet(this, _getReady, _getReady2).call(this, ethereum);\n}\n\nexport { MetaMaskConnector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}