{"ast":null,"code":"import _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { parseFilterArgs, functionalUpdate, parseQueryArgs, noop, hashQueryKey, partialMatchKey, hashQueryKeyByOptions } from './utils.mjs';\nimport { QueryCache } from './queryCache.mjs';\nimport { MutationCache } from './mutationCache.mjs';\nimport { focusManager } from './focusManager.mjs';\nimport { onlineManager } from './onlineManager.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior.mjs';\nimport { defaultLogger } from './logger.mjs'; // CLASS\n\nvar QueryClient = /*#__PURE__*/function () {\n  function QueryClient() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, QueryClient);\n\n    this.queryCache = config.queryCache || new QueryCache();\n    this.mutationCache = config.mutationCache || new MutationCache();\n    this.logger = config.logger || defaultLogger;\n    this.defaultOptions = config.defaultOptions || {};\n    this.queryDefaults = [];\n    this.mutationDefaults = [];\n  }\n\n  _createClass(QueryClient, [{\n    key: \"mount\",\n    value: function mount() {\n      var _this = this;\n\n      this.unsubscribeFocus = focusManager.subscribe(function () {\n        if (focusManager.isFocused()) {\n          _this.resumePausedMutations();\n\n          _this.queryCache.onFocus();\n        }\n      });\n      this.unsubscribeOnline = onlineManager.subscribe(function () {\n        if (onlineManager.isOnline()) {\n          _this.resumePausedMutations();\n\n          _this.queryCache.onOnline();\n        }\n      });\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      var _this$unsubscribeFocu, _this$unsubscribeOnli;\n\n      (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);\n      (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);\n    }\n  }, {\n    key: \"isFetching\",\n    value: function isFetching(arg1, arg2) {\n      var _parseFilterArgs = parseFilterArgs(arg1, arg2),\n          _parseFilterArgs2 = _slicedToArray(_parseFilterArgs, 1),\n          filters = _parseFilterArgs2[0];\n\n      filters.fetchStatus = 'fetching';\n      return this.queryCache.findAll(filters).length;\n    }\n  }, {\n    key: \"isMutating\",\n    value: function isMutating(filters) {\n      return this.mutationCache.findAll(_objectSpread(_objectSpread({}, filters), {}, {\n        fetching: true\n      })).length;\n    }\n  }, {\n    key: \"getQueryData\",\n    value: function getQueryData(queryKey, filters) {\n      var _this$queryCache$find;\n\n      return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;\n    }\n  }, {\n    key: \"getQueriesData\",\n    value: function getQueriesData(queryKeyOrFilters) {\n      return this.getQueryCache().findAll(queryKeyOrFilters).map(function (_ref2) {\n        var queryKey = _ref2.queryKey,\n            state = _ref2.state;\n        var data = state.data;\n        return [queryKey, data];\n      });\n    }\n  }, {\n    key: \"setQueryData\",\n    value: function setQueryData(queryKey, updater, options) {\n      var query = this.queryCache.find(queryKey);\n      var prevData = query == null ? void 0 : query.state.data;\n      var data = functionalUpdate(updater, prevData);\n\n      if (typeof data === 'undefined') {\n        return undefined;\n      }\n\n      var parsedOptions = parseQueryArgs(queryKey);\n      var defaultedOptions = this.defaultQueryOptions(parsedOptions);\n      return this.queryCache.build(this, defaultedOptions).setData(data, _objectSpread(_objectSpread({}, options), {}, {\n        manual: true\n      }));\n    }\n  }, {\n    key: \"setQueriesData\",\n    value: function setQueriesData(queryKeyOrFilters, updater, options) {\n      var _this2 = this;\n\n      return notifyManager.batch(function () {\n        return _this2.getQueryCache().findAll(queryKeyOrFilters).map(function (_ref3) {\n          var queryKey = _ref3.queryKey;\n          return [queryKey, _this2.setQueryData(queryKey, updater, options)];\n        });\n      });\n    }\n  }, {\n    key: \"getQueryState\",\n    value: function getQueryState(queryKey, filters) {\n      var _this$queryCache$find2;\n\n      return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;\n    }\n  }, {\n    key: \"removeQueries\",\n    value: function removeQueries(arg1, arg2) {\n      var _parseFilterArgs3 = parseFilterArgs(arg1, arg2),\n          _parseFilterArgs4 = _slicedToArray(_parseFilterArgs3, 1),\n          filters = _parseFilterArgs4[0];\n\n      var queryCache = this.queryCache;\n      notifyManager.batch(function () {\n        queryCache.findAll(filters).forEach(function (query) {\n          queryCache.remove(query);\n        });\n      });\n    }\n  }, {\n    key: \"resetQueries\",\n    value: function resetQueries(arg1, arg2, arg3) {\n      var _this3 = this;\n\n      var _parseFilterArgs5 = parseFilterArgs(arg1, arg2, arg3),\n          _parseFilterArgs6 = _slicedToArray(_parseFilterArgs5, 2),\n          filters = _parseFilterArgs6[0],\n          options = _parseFilterArgs6[1];\n\n      var queryCache = this.queryCache;\n\n      var refetchFilters = _objectSpread({\n        type: 'active'\n      }, filters);\n\n      return notifyManager.batch(function () {\n        queryCache.findAll(filters).forEach(function (query) {\n          query.reset();\n        });\n        return _this3.refetchQueries(refetchFilters, options);\n      });\n    }\n  }, {\n    key: \"cancelQueries\",\n    value: function cancelQueries(arg1, arg2, arg3) {\n      var _this4 = this;\n\n      var _parseFilterArgs7 = parseFilterArgs(arg1, arg2, arg3),\n          _parseFilterArgs8 = _slicedToArray(_parseFilterArgs7, 2),\n          filters = _parseFilterArgs8[0],\n          _parseFilterArgs8$ = _parseFilterArgs8[1],\n          cancelOptions = _parseFilterArgs8$ === void 0 ? {} : _parseFilterArgs8$;\n\n      if (typeof cancelOptions.revert === 'undefined') {\n        cancelOptions.revert = true;\n      }\n\n      var promises = notifyManager.batch(function () {\n        return _this4.queryCache.findAll(filters).map(function (query) {\n          return query.cancel(cancelOptions);\n        });\n      });\n      return Promise.all(promises).then(noop).catch(noop);\n    }\n  }, {\n    key: \"invalidateQueries\",\n    value: function invalidateQueries(arg1, arg2, arg3) {\n      var _this5 = this;\n\n      var _parseFilterArgs9 = parseFilterArgs(arg1, arg2, arg3),\n          _parseFilterArgs10 = _slicedToArray(_parseFilterArgs9, 2),\n          filters = _parseFilterArgs10[0],\n          options = _parseFilterArgs10[1];\n\n      return notifyManager.batch(function () {\n        var _ref, _filters$refetchType;\n\n        _this5.queryCache.findAll(filters).forEach(function (query) {\n          query.invalidate();\n        });\n\n        if (filters.refetchType === 'none') {\n          return Promise.resolve();\n        }\n\n        var refetchFilters = _objectSpread(_objectSpread({}, filters), {}, {\n          type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : 'active'\n        });\n\n        return _this5.refetchQueries(refetchFilters, options);\n      });\n    }\n  }, {\n    key: \"refetchQueries\",\n    value: function refetchQueries(arg1, arg2, arg3) {\n      var _this6 = this;\n\n      var _parseFilterArgs11 = parseFilterArgs(arg1, arg2, arg3),\n          _parseFilterArgs12 = _slicedToArray(_parseFilterArgs11, 2),\n          filters = _parseFilterArgs12[0],\n          options = _parseFilterArgs12[1];\n\n      var promises = notifyManager.batch(function () {\n        return _this6.queryCache.findAll(filters).filter(function (query) {\n          return !query.isDisabled();\n        }).map(function (query) {\n          var _options$cancelRefetc;\n\n          return query.fetch(undefined, _objectSpread(_objectSpread({}, options), {}, {\n            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,\n            meta: {\n              refetchPage: filters.refetchPage\n            }\n          }));\n        });\n      });\n      var promise = Promise.all(promises).then(noop);\n\n      if (!(options != null && options.throwOnError)) {\n        promise = promise.catch(noop);\n      }\n\n      return promise;\n    }\n  }, {\n    key: \"fetchQuery\",\n    value: function fetchQuery(arg1, arg2, arg3) {\n      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n      var defaultedOptions = this.defaultQueryOptions(parsedOptions); // https://github.com/tannerlinsley/react-query/issues/652\n\n      if (typeof defaultedOptions.retry === 'undefined') {\n        defaultedOptions.retry = false;\n      }\n\n      var query = this.queryCache.build(this, defaultedOptions);\n      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n    }\n  }, {\n    key: \"prefetchQuery\",\n    value: function prefetchQuery(arg1, arg2, arg3) {\n      return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);\n    }\n  }, {\n    key: \"fetchInfiniteQuery\",\n    value: function fetchInfiniteQuery(arg1, arg2, arg3) {\n      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);\n      parsedOptions.behavior = infiniteQueryBehavior();\n      return this.fetchQuery(parsedOptions);\n    }\n  }, {\n    key: \"prefetchInfiniteQuery\",\n    value: function prefetchInfiniteQuery(arg1, arg2, arg3) {\n      return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);\n    }\n  }, {\n    key: \"resumePausedMutations\",\n    value: function resumePausedMutations() {\n      return this.mutationCache.resumePausedMutations();\n    }\n  }, {\n    key: \"getQueryCache\",\n    value: function getQueryCache() {\n      return this.queryCache;\n    }\n  }, {\n    key: \"getMutationCache\",\n    value: function getMutationCache() {\n      return this.mutationCache;\n    }\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.logger;\n    }\n  }, {\n    key: \"getDefaultOptions\",\n    value: function getDefaultOptions() {\n      return this.defaultOptions;\n    }\n  }, {\n    key: \"setDefaultOptions\",\n    value: function setDefaultOptions(options) {\n      this.defaultOptions = options;\n    }\n  }, {\n    key: \"setQueryDefaults\",\n    value: function setQueryDefaults(queryKey, options) {\n      var result = this.queryDefaults.find(function (x) {\n        return hashQueryKey(queryKey) === hashQueryKey(x.queryKey);\n      });\n\n      if (result) {\n        result.defaultOptions = options;\n      } else {\n        this.queryDefaults.push({\n          queryKey: queryKey,\n          defaultOptions: options\n        });\n      }\n    }\n  }, {\n    key: \"getQueryDefaults\",\n    value: function getQueryDefaults(queryKey) {\n      if (!queryKey) {\n        return undefined;\n      } // Get the first matching defaults\n\n\n      var firstMatchingDefaults = this.queryDefaults.find(function (x) {\n        return partialMatchKey(queryKey, x.queryKey);\n      }); // Additional checks and error in dev mode\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Retrieve all matching defaults for the given key\n        var matchingDefaults = this.queryDefaults.filter(function (x) {\n          return partialMatchKey(queryKey, x.queryKey);\n        }); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n        if (matchingDefaults.length > 1) {\n          this.logger.error(\"[QueryClient] Several query defaults match with key '\" + JSON.stringify(queryKey) + \"'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.\");\n        }\n      }\n\n      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n  }, {\n    key: \"setMutationDefaults\",\n    value: function setMutationDefaults(mutationKey, options) {\n      var result = this.mutationDefaults.find(function (x) {\n        return hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey);\n      });\n\n      if (result) {\n        result.defaultOptions = options;\n      } else {\n        this.mutationDefaults.push({\n          mutationKey: mutationKey,\n          defaultOptions: options\n        });\n      }\n    }\n  }, {\n    key: \"getMutationDefaults\",\n    value: function getMutationDefaults(mutationKey) {\n      if (!mutationKey) {\n        return undefined;\n      } // Get the first matching defaults\n\n\n      var firstMatchingDefaults = this.mutationDefaults.find(function (x) {\n        return partialMatchKey(mutationKey, x.mutationKey);\n      }); // Additional checks and error in dev mode\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Retrieve all matching defaults for the given key\n        var matchingDefaults = this.mutationDefaults.filter(function (x) {\n          return partialMatchKey(mutationKey, x.mutationKey);\n        }); // It is ok not having defaults, but it is error prone to have more than 1 default for a given key\n\n        if (matchingDefaults.length > 1) {\n          this.logger.error(\"[QueryClient] Several mutation defaults match with key '\" + JSON.stringify(mutationKey) + \"'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.\");\n        }\n      }\n\n      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;\n    }\n  }, {\n    key: \"defaultQueryOptions\",\n    value: function defaultQueryOptions(options) {\n      if (options != null && options._defaulted) {\n        return options;\n      }\n\n      var defaultedOptions = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.queries), this.getQueryDefaults(options == null ? void 0 : options.queryKey)), options), {}, {\n        _defaulted: true\n      });\n\n      if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {\n        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n      } // dependent default values\n\n\n      if (typeof defaultedOptions.refetchOnReconnect === 'undefined') {\n        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== 'always';\n      }\n\n      if (typeof defaultedOptions.useErrorBoundary === 'undefined') {\n        defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;\n      }\n\n      return defaultedOptions;\n    }\n  }, {\n    key: \"defaultMutationOptions\",\n    value: function defaultMutationOptions(options) {\n      if (options != null && options._defaulted) {\n        return options;\n      }\n\n      return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, this.defaultOptions.mutations), this.getMutationDefaults(options == null ? void 0 : options.mutationKey)), options), {}, {\n        _defaulted: true\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.queryCache.clear();\n      this.mutationCache.clear();\n    }\n  }]);\n\n  return QueryClient;\n}();\n\nexport { QueryClient }; //# sourceMappingURL=queryClient.mjs.map","map":null,"metadata":{},"sourceType":"module"}