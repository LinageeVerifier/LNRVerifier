{"ast":null,"code":"import _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectWithoutProperties from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _createForOfIteratorHelper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nvar _excluded = [\"default\"];\nimport { subscribeWithSelector, persist } from 'zustand/middleware';\nimport create from 'zustand/vanilla';\nimport { providers } from 'ethers';\nimport { getAddress, hexValue } from 'ethers/lib/utils';\nimport EventEmitter from 'eventemitter3';\nimport { d as defaultChains } from './chains-8c76af1b.esm.js';\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\n\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n\n  privateSet.add(obj);\n}\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n\n  privateMap.set(obj, value);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n\n  return descriptor.value;\n}\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n}\n\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\n\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return fn;\n}\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n\n    descriptor.value = value;\n  }\n}\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n\n  _classApplyDescriptorSet(receiver, descriptor, value);\n\n  return value;\n}\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n * @see https://eips.ethereum.org/EIPS/eip-1474\n */\n\n\nvar RpcError = /*#__PURE__*/function (_Error) {\n  _inherits(RpcError, _Error);\n\n  var _super = _createSuper(RpcError);\n\n  function RpcError(\n  /** Number error code */\n  code,\n  /** Human-readable string */\n  message,\n  /** Low-level error */\n  internal,\n  /** Other useful information about error */\n  data) {\n    var _this;\n\n    _classCallCheck(this, RpcError);\n\n    if (!Number.isInteger(code)) throw new Error('\"code\" must be an integer.');\n    if (!message || typeof message !== 'string') throw new Error('\"message\" must be a nonempty string.');\n    _this = _super.call(this, message);\n\n    _defineProperty(_assertThisInitialized(_this), \"code\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"internal\", void 0);\n\n    _this.code = code;\n    _this.data = data;\n    _this.internal = internal;\n    return _this;\n  }\n\n  return _createClass(RpcError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * @see https://eips.ethereum.org/EIPS/eip-1193\n */\n\n\nvar ProviderRpcError = /*#__PURE__*/function (_RpcError) {\n  _inherits(ProviderRpcError, _RpcError);\n\n  var _super2 = _createSuper(ProviderRpcError);\n\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the 1000 <= 4999 range.\n   */\n  function ProviderRpcError(\n  /**\n   * Number error code\n   * @see https://eips.ethereum.org/EIPS/eip-1193#error-standards\n   */\n  code,\n  /** Human-readable string */\n  message,\n  /** Low-level error */\n  internal,\n  /** Other useful information about error */\n  data) {\n    _classCallCheck(this, ProviderRpcError);\n\n    if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    return _super2.call(this, code, message, internal, data);\n  }\n\n  return _createClass(ProviderRpcError);\n}(RpcError);\n\nvar AddChainError = /*#__PURE__*/function (_Error2) {\n  _inherits(AddChainError, _Error2);\n\n  var _super3 = _createSuper(AddChainError);\n\n  function AddChainError() {\n    var _this2;\n\n    _classCallCheck(this, AddChainError);\n\n    _this2 = _super3.apply(this, arguments);\n\n    _defineProperty(_assertThisInitialized(_this2), \"name\", 'AddChainError');\n\n    _defineProperty(_assertThisInitialized(_this2), \"message\", 'Error adding chain');\n\n    return _this2;\n  }\n\n  return _createClass(AddChainError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ChainDoesNotSupportMulticallError = /*#__PURE__*/function (_Error3) {\n  _inherits(ChainDoesNotSupportMulticallError, _Error3);\n\n  var _super4 = _createSuper(ChainDoesNotSupportMulticallError);\n\n  function ChainDoesNotSupportMulticallError(_ref) {\n    var _this3;\n\n    _classCallCheck(this, ChainDoesNotSupportMulticallError);\n\n    var blockNumber = _ref.blockNumber,\n        chain = _ref.chain;\n    _this3 = _super4.call(this, \"Chain \\\"\".concat(chain.name, \"\\\" does not support multicall\").concat(blockNumber ? \" on block \".concat(blockNumber) : '', \".\"));\n\n    _defineProperty(_assertThisInitialized(_this3), \"name\", 'ChainDoesNotSupportMulticall');\n\n    return _this3;\n  }\n\n  return _createClass(ChainDoesNotSupportMulticallError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ChainMismatchError = /*#__PURE__*/function (_Error4) {\n  _inherits(ChainMismatchError, _Error4);\n\n  var _super5 = _createSuper(ChainMismatchError);\n\n  function ChainMismatchError(_ref2) {\n    var _this4;\n\n    _classCallCheck(this, ChainMismatchError);\n\n    var activeChain = _ref2.activeChain,\n        targetChain = _ref2.targetChain;\n    _this4 = _super5.call(this, \"Chain mismatch: Expected \\\"\".concat(targetChain, \"\\\", received \\\"\").concat(activeChain, \"\\\".\"));\n\n    _defineProperty(_assertThisInitialized(_this4), \"name\", 'ChainMismatchError');\n\n    return _this4;\n  }\n\n  return _createClass(ChainMismatchError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ChainNotConfiguredError = /*#__PURE__*/function (_Error5) {\n  _inherits(ChainNotConfiguredError, _Error5);\n\n  var _super6 = _createSuper(ChainNotConfiguredError);\n\n  function ChainNotConfiguredError() {\n    var _this5;\n\n    _classCallCheck(this, ChainNotConfiguredError);\n\n    _this5 = _super6.apply(this, arguments);\n\n    _defineProperty(_assertThisInitialized(_this5), \"name\", 'ChainNotConfigured');\n\n    _defineProperty(_assertThisInitialized(_this5), \"message\", 'Chain not configured');\n\n    return _this5;\n  }\n\n  return _createClass(ChainNotConfiguredError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ConnectorAlreadyConnectedError = /*#__PURE__*/function (_Error6) {\n  _inherits(ConnectorAlreadyConnectedError, _Error6);\n\n  var _super7 = _createSuper(ConnectorAlreadyConnectedError);\n\n  function ConnectorAlreadyConnectedError() {\n    var _this6;\n\n    _classCallCheck(this, ConnectorAlreadyConnectedError);\n\n    _this6 = _super7.apply(this, arguments);\n\n    _defineProperty(_assertThisInitialized(_this6), \"name\", 'ConnectorAlreadyConnectedError');\n\n    _defineProperty(_assertThisInitialized(_this6), \"message\", 'Connector already connected');\n\n    return _this6;\n  }\n\n  return _createClass(ConnectorAlreadyConnectedError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ConnectorNotFoundError = /*#__PURE__*/function (_Error7) {\n  _inherits(ConnectorNotFoundError, _Error7);\n\n  var _super8 = _createSuper(ConnectorNotFoundError);\n\n  function ConnectorNotFoundError() {\n    var _this7;\n\n    _classCallCheck(this, ConnectorNotFoundError);\n\n    _this7 = _super8.apply(this, arguments);\n\n    _defineProperty(_assertThisInitialized(_this7), \"name\", 'ConnectorNotFoundError');\n\n    _defineProperty(_assertThisInitialized(_this7), \"message\", 'Connector not found');\n\n    return _this7;\n  }\n\n  return _createClass(ConnectorNotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ContractMethodDoesNotExistError = /*#__PURE__*/function (_Error8) {\n  _inherits(ContractMethodDoesNotExistError, _Error8);\n\n  var _super9 = _createSuper(ContractMethodDoesNotExistError);\n\n  function ContractMethodDoesNotExistError(_ref3) {\n    var _this8;\n\n    _classCallCheck(this, ContractMethodDoesNotExistError);\n\n    var _chain$blockExplorers;\n\n    var addressOrName = _ref3.addressOrName,\n        chainId = _ref3.chainId,\n        functionName = _ref3.functionName;\n\n    var _getProvider = getProvider(),\n        chains = _getProvider.chains,\n        network = _getProvider.network;\n\n    var chain = chains === null || chains === void 0 ? void 0 : chains.find(function (_ref4) {\n      var id = _ref4.id;\n      return id === (chainId || network.chainId);\n    });\n    var blockExplorer = chain === null || chain === void 0 ? void 0 : (_chain$blockExplorers = chain.blockExplorers) === null || _chain$blockExplorers === void 0 ? void 0 : _chain$blockExplorers.default;\n    _this8 = _super9.call(this, [\"Function \\\"\".concat(functionName, \"\\\" on contract \\\"\").concat(addressOrName, \"\\\" does not exist.\")].concat(_toConsumableArray(blockExplorer ? ['', \"\".concat(blockExplorer === null || blockExplorer === void 0 ? void 0 : blockExplorer.name, \": \").concat(blockExplorer === null || blockExplorer === void 0 ? void 0 : blockExplorer.url, \"/address/\").concat(addressOrName, \"#readContract\")] : [])).join('\\n'));\n\n    _defineProperty(_assertThisInitialized(_this8), \"name\", 'ContractMethodDoesNotExistError');\n\n    return _this8;\n  }\n\n  return _createClass(ContractMethodDoesNotExistError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ContractMethodNoResultError = /*#__PURE__*/function (_Error9) {\n  _inherits(ContractMethodNoResultError, _Error9);\n\n  var _super10 = _createSuper(ContractMethodNoResultError);\n\n  function ContractMethodNoResultError(_ref5) {\n    var _this9;\n\n    _classCallCheck(this, ContractMethodNoResultError);\n\n    var addressOrName = _ref5.addressOrName,\n        args = _ref5.args,\n        chainId = _ref5.chainId,\n        functionName = _ref5.functionName;\n    _this9 = _super10.call(this, ['Contract read returned an empty response. This could be due to any of the following:', \"- The contract does not have the function \\\"\".concat(functionName, \"\\\",\"), '- The parameters passed to the contract function may be invalid, or', '- The address is not a contract.', '', \"Config:\", JSON.stringify({\n      addressOrName: addressOrName,\n      contractInterface: '...',\n      functionName: functionName,\n      chainId: chainId,\n      args: args\n    }, null, 2)].join('\\n'));\n\n    _defineProperty(_assertThisInitialized(_this9), \"name\", 'ContractMethodNoResultError');\n\n    return _this9;\n  }\n\n  return _createClass(ContractMethodNoResultError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ContractMethodRevertedError = /*#__PURE__*/function (_Error10) {\n  _inherits(ContractMethodRevertedError, _Error10);\n\n  var _super11 = _createSuper(ContractMethodRevertedError);\n\n  function ContractMethodRevertedError(_ref6) {\n    var _this10;\n\n    _classCallCheck(this, ContractMethodRevertedError);\n\n    var addressOrName = _ref6.addressOrName,\n        args = _ref6.args,\n        chainId = _ref6.chainId,\n        functionName = _ref6.functionName,\n        errorMessage = _ref6.errorMessage;\n    _this10 = _super11.call(this, ['Contract method reverted with an error.', '', \"Config:\", JSON.stringify({\n      addressOrName: addressOrName,\n      contractInterface: '...',\n      functionName: functionName,\n      chainId: chainId,\n      args: args\n    }, null, 2), '', \"Details: \".concat(errorMessage)].join('\\n'));\n\n    _defineProperty(_assertThisInitialized(_this10), \"name\", 'ContractMethodRevertedError');\n\n    return _this10;\n  }\n\n  return _createClass(ContractMethodRevertedError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ContractResultDecodeError = /*#__PURE__*/function (_Error11) {\n  _inherits(ContractResultDecodeError, _Error11);\n\n  var _super12 = _createSuper(ContractResultDecodeError);\n\n  function ContractResultDecodeError(_ref7) {\n    var _this11;\n\n    _classCallCheck(this, ContractResultDecodeError);\n\n    var addressOrName = _ref7.addressOrName,\n        args = _ref7.args,\n        chainId = _ref7.chainId,\n        functionName = _ref7.functionName,\n        errorMessage = _ref7.errorMessage;\n    _this11 = _super12.call(this, ['Failed to decode contract function result.', '', \"Config:\", JSON.stringify({\n      addressOrName: addressOrName,\n      contractInterface: '...',\n      functionName: functionName,\n      chainId: chainId,\n      args: args\n    }, null, 2), '', \"Details: \".concat(errorMessage)].join('\\n'));\n\n    _defineProperty(_assertThisInitialized(_this11), \"name\", 'ContractResultDecodeError');\n\n    return _this11;\n  }\n\n  return _createClass(ContractResultDecodeError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ProviderChainsNotFound = /*#__PURE__*/function (_Error12) {\n  _inherits(ProviderChainsNotFound, _Error12);\n\n  var _super13 = _createSuper(ProviderChainsNotFound);\n\n  function ProviderChainsNotFound() {\n    var _this12;\n\n    _classCallCheck(this, ProviderChainsNotFound);\n\n    _this12 = _super13.apply(this, arguments);\n\n    _defineProperty(_assertThisInitialized(_this12), \"name\", 'ProviderChainsNotFound');\n\n    _defineProperty(_assertThisInitialized(_this12), \"message\", ['No chains were found on the wagmi provider. Some functions that require a chain may not work.', '', 'It is recommended to add a list of chains to the provider in `createClient`.', '', 'Example:', '', '```', \"import { getDefaultProvider } from 'ethers'\", \"import { chain, createClient } from 'wagmi'\", '', 'createClient({', '  provider: Object.assign(getDefaultProvider(), { chains: [chain.mainnet] })', '})', '```'].join('\\n'));\n\n    return _this12;\n  }\n\n  return _createClass(ProviderChainsNotFound);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ResourceUnavailableError = /*#__PURE__*/function (_RpcError2) {\n  _inherits(ResourceUnavailableError, _RpcError2);\n\n  var _super14 = _createSuper(ResourceUnavailableError);\n\n  function ResourceUnavailableError(error) {\n    var _this13;\n\n    _classCallCheck(this, ResourceUnavailableError);\n\n    _this13 = _super14.call(this, -32002, 'Resource unavailable', error);\n\n    _defineProperty(_assertThisInitialized(_this13), \"name\", 'ResourceUnavailable');\n\n    return _this13;\n  }\n\n  return _createClass(ResourceUnavailableError);\n}(RpcError);\n\nvar SwitchChainError = /*#__PURE__*/function (_ProviderRpcError) {\n  _inherits(SwitchChainError, _ProviderRpcError);\n\n  var _super15 = _createSuper(SwitchChainError);\n\n  function SwitchChainError(error) {\n    var _this14;\n\n    _classCallCheck(this, SwitchChainError);\n\n    _this14 = _super15.call(this, 4902, 'Error switching chain', error);\n\n    _defineProperty(_assertThisInitialized(_this14), \"name\", 'SwitchChainError');\n\n    return _this14;\n  }\n\n  return _createClass(SwitchChainError);\n}(ProviderRpcError);\n\nvar SwitchChainNotSupportedError = /*#__PURE__*/function (_Error13) {\n  _inherits(SwitchChainNotSupportedError, _Error13);\n\n  var _super16 = _createSuper(SwitchChainNotSupportedError);\n\n  function SwitchChainNotSupportedError(_ref8) {\n    var _this15;\n\n    _classCallCheck(this, SwitchChainNotSupportedError);\n\n    var connector = _ref8.connector;\n    _this15 = _super16.call(this, \"\\\"\".concat(connector.name, \"\\\" does not support programmatic chain switching.\"));\n\n    _defineProperty(_assertThisInitialized(_this15), \"name\", 'SwitchChainNotSupportedError');\n\n    return _this15;\n  }\n\n  return _createClass(SwitchChainNotSupportedError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar UserRejectedRequestError = /*#__PURE__*/function (_ProviderRpcError2) {\n  _inherits(UserRejectedRequestError, _ProviderRpcError2);\n\n  var _super17 = _createSuper(UserRejectedRequestError);\n\n  function UserRejectedRequestError(error) {\n    var _this16;\n\n    _classCallCheck(this, UserRejectedRequestError);\n\n    _this16 = _super17.call(this, 4001, 'User rejected request', error);\n\n    _defineProperty(_assertThisInitialized(_this16), \"name\", 'UserRejectedRequestError');\n\n    return _this16;\n  }\n\n  return _createClass(UserRejectedRequestError);\n}(ProviderRpcError);\n\nfunction getInjectedName(ethereum) {\n  var _ethereum$providers, _getName;\n\n  if (!ethereum) return 'Injected';\n\n  var getName = function getName(provider) {\n    if (provider.isBitKeep) return 'BitKeep';\n    if (provider.isBraveWallet) return 'Brave Wallet';\n    if (provider.isCoinbaseWallet) return 'Coinbase Wallet';\n    if (provider.isExodus) return 'Exodus';\n    if (provider.isFrame) return 'Frame';\n    if (provider.isMathWallet) return 'MathWallet';\n    if (provider.isOpera) return 'Opera';\n    if (provider.isTally) return 'Tally';\n    if (provider.isTokenPocket) return 'TokenPocket';\n    if (provider.isTokenary) return 'Tokenary';\n    if (provider.isTrust) return 'Trust Wallet';\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) return '1inch Wallet';\n    if (provider.isMetaMask) return 'MetaMask';\n  }; // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n\n\n  if ((_ethereum$providers = ethereum.providers) !== null && _ethereum$providers !== void 0 && _ethereum$providers.length) {\n    var _names$; // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n\n\n    var nameSet = new Set();\n    var unknownCount = 1;\n\n    var _iterator = _createForOfIteratorHelper(ethereum.providers),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var provider = _step.value;\n        var name = getName(provider);\n\n        if (!name) {\n          name = \"Unknown Wallet #\".concat(unknownCount);\n          unknownCount += 1;\n        }\n\n        nameSet.add(name);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var names = _toConsumableArray(nameSet);\n\n    if (names.length) return names;\n    return (_names$ = names[0]) !== null && _names$ !== void 0 ? _names$ : 'Injected';\n  }\n\n  return (_getName = getName(ethereum)) !== null && _getName !== void 0 ? _getName : 'Injected';\n}\n\nfunction normalizeChainId(chainId) {\n  if (typeof chainId === 'string') return Number.parseInt(chainId, chainId.trim().substring(0, 2) === '0x' ? 16 : 10);\n  if (typeof chainId === 'bigint') return Number(chainId);\n  return chainId;\n}\n\nvar Connector = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connector, _EventEmitter);\n\n  var _super18 = _createSuper(Connector);\n\n  /** Unique connector id */\n\n  /** Connector name */\n\n  /** Chains connector supports */\n\n  /** Options to use with connector */\n\n  /** Whether connector is usable */\n  function Connector(_ref) {\n    var _this17;\n\n    _classCallCheck(this, Connector);\n\n    var _ref$chains = _ref.chains,\n        chains = _ref$chains === void 0 ? defaultChains : _ref$chains,\n        options = _ref.options;\n    _this17 = _super18.call(this);\n\n    _defineProperty(_assertThisInitialized(_this17), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this17), \"name\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this17), \"chains\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this17), \"options\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this17), \"ready\", void 0);\n\n    _this17.chains = chains;\n    _this17.options = options;\n    return _this17;\n  }\n\n  _createClass(Connector, [{\n    key: \"getBlockExplorerUrls\",\n    value: function getBlockExplorerUrls(chain) {\n      var _chain$blockExplorers;\n\n      var _ref9 = (_chain$blockExplorers = chain.blockExplorers) !== null && _chain$blockExplorers !== void 0 ? _chain$blockExplorers : {},\n          blockExplorer = _ref9.default,\n          blockExplorers = _objectWithoutProperties(_ref9, _excluded);\n\n      if (blockExplorer) return [blockExplorer.url].concat(_toConsumableArray(Object.values(blockExplorers).map(function (x) {\n        return x.url;\n      })));\n      return [];\n    }\n  }, {\n    key: \"isChainUnsupported\",\n    value: function isChainUnsupported(chainId) {\n      return !this.chains.some(function (x) {\n        return x.id === chainId;\n      });\n    }\n  }]);\n\n  return Connector;\n}(EventEmitter);\n\nvar _provider = /*#__PURE__*/new WeakMap();\n\nvar _switchingChains = /*#__PURE__*/new WeakMap();\n\nvar InjectedConnector = /*#__PURE__*/function (_Connector) {\n  _inherits(InjectedConnector, _Connector);\n\n  var _super19 = _createSuper(InjectedConnector);\n\n  function InjectedConnector() {\n    var _this18;\n\n    _classCallCheck(this, InjectedConnector);\n\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        chains = _ref10.chains,\n        _ref10$options = _ref10.options,\n        options = _ref10$options === void 0 ? {\n      shimDisconnect: true\n    } : _ref10$options;\n\n    _this18 = _super19.call(this, {\n      chains: chains,\n      options: options\n    });\n\n    _defineProperty(_assertThisInitialized(_this18), \"id\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this18), \"name\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this18), \"ready\", typeof window != 'undefined' && !!window.ethereum);\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this18), _provider, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this18), _switchingChains, {\n      writable: true,\n      value: void 0\n    });\n\n    _defineProperty(_assertThisInitialized(_this18), \"shimDisconnectKey\", 'injected.shimDisconnect');\n\n    _defineProperty(_assertThisInitialized(_this18), \"onAccountsChanged\", function (accounts) {\n      if (accounts.length === 0) _this18.emit('disconnect');else _this18.emit('change', {\n        account: getAddress(accounts[0])\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this18), \"onChainChanged\", function (chainId) {\n      var id = normalizeChainId(chainId);\n\n      var unsupported = _this18.isChainUnsupported(id);\n\n      _this18.emit('change', {\n        chain: {\n          id: id,\n          unsupported: unsupported\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this18), \"onDisconnect\", function () {\n      var _this$options, _this$options2, _getClient$storage; // We need this as MetaMask can emit the \"disconnect\" event\n      // upon switching chains. This workaround ensures that the\n      // user currently isn't in the process of switching chains.\n\n\n      if ((_this$options = _this18.options) !== null && _this$options !== void 0 && _this$options.shimChainChangedDisconnect && _classPrivateFieldGet(_assertThisInitialized(_this18), _switchingChains)) {\n        _classPrivateFieldSet(_assertThisInitialized(_this18), _switchingChains, false);\n\n        return;\n      }\n\n      _this18.emit('disconnect'); // Remove shim signalling wallet is disconnected\n\n\n      if ((_this$options2 = _this18.options) !== null && _this$options2 !== void 0 && _this$options2.shimDisconnect) (_getClient$storage = getClient().storage) === null || _getClient$storage === void 0 ? void 0 : _getClient$storage.removeItem(_this18.shimDisconnectKey);\n    });\n\n    var name = 'Injected';\n    var overrideName = options.name;\n    if (typeof overrideName === 'string') name = overrideName;else if (typeof window !== 'undefined') {\n      var detectedName = getInjectedName(window.ethereum);\n      if (overrideName) name = overrideName(detectedName);else name = typeof detectedName === 'string' ? detectedName : detectedName[0];\n    }\n    _this18.id = 'injected';\n    _this18.name = name;\n    return _this18;\n  }\n\n  _createClass(InjectedConnector, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _ref11,\n            chainId,\n            _this$options3,\n            _getClient$storage2,\n            provider,\n            account,\n            id,\n            unsupported,\n            chain,\n            _args = arguments;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref11 = _args.length > 0 && _args[0] !== undefined ? _args[0] : {}, chainId = _ref11.chainId;\n                _context.prev = 1;\n                _context.next = 4;\n                return this.getProvider();\n\n              case 4:\n                provider = _context.sent;\n\n                if (provider) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 7:\n                if (provider.on) {\n                  provider.on('accountsChanged', this.onAccountsChanged);\n                  provider.on('chainChanged', this.onChainChanged);\n                  provider.on('disconnect', this.onDisconnect);\n                }\n\n                this.emit('message', {\n                  type: 'connecting'\n                });\n                _context.next = 11;\n                return this.getAccount();\n\n              case 11:\n                account = _context.sent;\n                _context.next = 14;\n                return this.getChainId();\n\n              case 14:\n                id = _context.sent;\n                unsupported = this.isChainUnsupported(id);\n\n                if (!(chainId && id !== chainId)) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _context.next = 19;\n                return this.switchChain(chainId);\n\n              case 19:\n                chain = _context.sent;\n                id = chain.id;\n                unsupported = this.isChainUnsupported(id);\n\n              case 22:\n                // Add shim to storage signalling wallet is connected\n                if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.shimDisconnect) (_getClient$storage2 = getClient().storage) === null || _getClient$storage2 === void 0 ? void 0 : _getClient$storage2.setItem(this.shimDisconnectKey, true);\n                return _context.abrupt(\"return\", {\n                  account: account,\n                  chain: {\n                    id: id,\n                    unsupported: unsupported\n                  },\n                  provider: provider\n                });\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (!this.isUserRejectedRequestError(_context.t0)) {\n                  _context.next = 30;\n                  break;\n                }\n\n                throw new UserRejectedRequestError(_context.t0);\n\n              case 30:\n                if (!(_context.t0.code === -32002)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                throw new ResourceUnavailableError(_context.t0);\n\n              case 32:\n                throw _context.t0;\n\n              case 33:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 26]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var _this$options4, _getClient$storage3, provider;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context2.sent;\n\n                if (provider !== null && provider !== void 0 && provider.removeListener) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                provider.removeListener('accountsChanged', this.onAccountsChanged);\n                provider.removeListener('chainChanged', this.onChainChanged);\n                provider.removeListener('disconnect', this.onDisconnect); // Remove shim signalling wallet is disconnected\n\n                if ((_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.shimDisconnect) (_getClient$storage3 = getClient().storage) === null || _getClient$storage3 === void 0 ? void 0 : _getClient$storage3.removeItem(this.shimDisconnectKey);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var provider, accounts;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context3.sent;\n\n                if (provider) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 5:\n                _context3.next = 7;\n                return provider.request({\n                  method: 'eth_requestAccounts'\n                });\n\n              case 7:\n                accounts = _context3.sent;\n                return _context3.abrupt(\"return\", getAddress(accounts[0]));\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getAccount() {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var provider;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.getProvider();\n\n              case 2:\n                provider = _context4.sent;\n\n                if (provider) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 5:\n                _context4.next = 7;\n                return provider.request({\n                  method: 'eth_chainId'\n                }).then(normalizeChainId);\n\n              case 7:\n                return _context4.abrupt(\"return\", _context4.sent);\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getProvider\",\n    value: function () {\n      var _getProvider2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (typeof window !== 'undefined' && !!window.ethereum) _classPrivateFieldSet(this, _provider, window.ethereum);\n                return _context5.abrupt(\"return\", _classPrivateFieldGet(this, _provider));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getProvider() {\n        return _getProvider2.apply(this, arguments);\n      }\n\n      return getProvider;\n    }()\n  }, {\n    key: \"getSigner\",\n    value: function () {\n      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _yield$Promise$all, _yield$Promise$all2, provider, account;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return Promise.all([this.getProvider(), this.getAccount()]);\n\n              case 2:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                provider = _yield$Promise$all2[0];\n                account = _yield$Promise$all2[1];\n                return _context6.abrupt(\"return\", new providers.Web3Provider(provider).getSigner(account));\n\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getSigner() {\n        return _getSigner.apply(this, arguments);\n      }\n\n      return getSigner;\n    }()\n  }, {\n    key: \"isAuthorized\",\n    value: function () {\n      var _isAuthorized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this$options5, _getClient$storage4, provider, accounts, account;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n\n                if (!((_this$options5 = this.options) !== null && _this$options5 !== void 0 && _this$options5.shimDisconnect && // If shim does not exist in storage, wallet is disconnected\n                !((_getClient$storage4 = getClient().storage) !== null && _getClient$storage4 !== void 0 && _getClient$storage4.getItem(this.shimDisconnectKey)))) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", false);\n\n              case 3:\n                _context7.next = 5;\n                return this.getProvider();\n\n              case 5:\n                provider = _context7.sent;\n\n                if (provider) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 8:\n                _context7.next = 10;\n                return provider.request({\n                  method: 'eth_accounts'\n                });\n\n              case 10:\n                accounts = _context7.sent;\n                account = accounts[0];\n                return _context7.abrupt(\"return\", !!account);\n\n              case 15:\n                _context7.prev = 15;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", false);\n\n              case 18:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 15]]);\n      }));\n\n      function isAuthorized() {\n        return _isAuthorized.apply(this, arguments);\n      }\n\n      return isAuthorized;\n    }()\n  }, {\n    key: \"switchChain\",\n    value: function () {\n      var _switchChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(chainId) {\n        var _this$options6, provider, id, _this$chains$find, _data, _data$originalError, chain, _chain$rpcUrls$public;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if ((_this$options6 = this.options) !== null && _this$options6 !== void 0 && _this$options6.shimChainChangedDisconnect) _classPrivateFieldSet(this, _switchingChains, true);\n                _context8.next = 3;\n                return this.getProvider();\n\n              case 3:\n                provider = _context8.sent;\n\n                if (provider) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 6:\n                id = hexValue(chainId);\n                _context8.prev = 7;\n                _context8.next = 10;\n                return provider.request({\n                  method: 'wallet_switchEthereumChain',\n                  params: [{\n                    chainId: id\n                  }]\n                });\n\n              case 10:\n                return _context8.abrupt(\"return\", (_this$chains$find = this.chains.find(function (x) {\n                  return x.id === chainId;\n                })) !== null && _this$chains$find !== void 0 ? _this$chains$find : {\n                  id: chainId,\n                  name: \"Chain \".concat(id),\n                  network: \"\".concat(id),\n                  rpcUrls: {\n                    default: ''\n                  }\n                });\n\n              case 13:\n                _context8.prev = 13;\n                _context8.t0 = _context8[\"catch\"](7);\n                chain = this.chains.find(function (x) {\n                  return x.id === chainId;\n                });\n\n                if (chain) {\n                  _context8.next = 18;\n                  break;\n                }\n\n                throw new ChainNotConfiguredError();\n\n              case 18:\n                if (!(_context8.t0.code === 4902 || // Unwrapping for MetaMask Mobile\n                // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n                (_context8.t0 === null || _context8.t0 === void 0 ? void 0 : (_data = _context8.t0.data) === null || _data === void 0 ? void 0 : (_data$originalError = _data.originalError) === null || _data$originalError === void 0 ? void 0 : _data$originalError.code) === 4902)) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                _context8.prev = 19;\n                _context8.next = 22;\n                return provider.request({\n                  method: 'wallet_addEthereumChain',\n                  params: [{\n                    chainId: id,\n                    chainName: chain.name,\n                    nativeCurrency: chain.nativeCurrency,\n                    rpcUrls: [(_chain$rpcUrls$public = chain.rpcUrls.public) !== null && _chain$rpcUrls$public !== void 0 ? _chain$rpcUrls$public : chain.rpcUrls.default],\n                    blockExplorerUrls: this.getBlockExplorerUrls(chain)\n                  }]\n                });\n\n              case 22:\n                return _context8.abrupt(\"return\", chain);\n\n              case 25:\n                _context8.prev = 25;\n                _context8.t1 = _context8[\"catch\"](19);\n\n                if (!this.isUserRejectedRequestError(_context8.t1)) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                throw new UserRejectedRequestError(_context8.t0);\n\n              case 29:\n                throw new AddChainError();\n\n              case 30:\n                if (!this.isUserRejectedRequestError(_context8.t0)) {\n                  _context8.next = 32;\n                  break;\n                }\n\n                throw new UserRejectedRequestError(_context8.t0);\n\n              case 32:\n                throw new SwitchChainError(_context8.t0);\n\n              case 33:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[7, 13], [19, 25]]);\n      }));\n\n      function switchChain(_x) {\n        return _switchChain.apply(this, arguments);\n      }\n\n      return switchChain;\n    }()\n  }, {\n    key: \"watchAsset\",\n    value: function () {\n      var _watchAsset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref) {\n        var address, _ref$decimals, decimals, image, symbol, provider;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                address = _ref.address, _ref$decimals = _ref.decimals, decimals = _ref$decimals === void 0 ? 18 : _ref$decimals, image = _ref.image, symbol = _ref.symbol;\n                _context9.next = 3;\n                return this.getProvider();\n\n              case 3:\n                provider = _context9.sent;\n\n                if (provider) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new ConnectorNotFoundError();\n\n              case 6:\n                _context9.next = 8;\n                return provider.request({\n                  method: 'wallet_watchAsset',\n                  params: {\n                    type: 'ERC20',\n                    options: {\n                      address: address,\n                      decimals: decimals,\n                      image: image,\n                      symbol: symbol\n                    }\n                  }\n                });\n\n              case 8:\n                return _context9.abrupt(\"return\", _context9.sent);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function watchAsset(_x2) {\n        return _watchAsset.apply(this, arguments);\n      }\n\n      return watchAsset;\n    }()\n  }, {\n    key: \"isUserRejectedRequestError\",\n    value: function isUserRejectedRequestError(error) {\n      return error.code === 4001;\n    }\n  }]);\n\n  return InjectedConnector;\n}(Connector);\n\nvar noopStorage = {\n  getItem: function getItem(_key) {\n    return '';\n  },\n  setItem: function setItem(_key, _value) {\n    return null;\n  },\n  removeItem: function removeItem(_key) {\n    return null;\n  }\n};\n\nfunction createStorage(_ref) {\n  var storage = _ref.storage,\n      _ref$key = _ref.key,\n      prefix = _ref$key === void 0 ? 'wagmi' : _ref$key;\n  return _objectSpread(_objectSpread({}, storage), {}, {\n    getItem: function getItem(key) {\n      var defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var value = storage.getItem(\"\".concat(prefix, \".\").concat(key));\n\n      try {\n        return value ? JSON.parse(value) : defaultState;\n      } catch (error) {\n        console.warn(error);\n        return defaultState;\n      }\n    },\n    setItem: function setItem(key, value) {\n      if (value === null) {\n        storage.removeItem(\"\".concat(prefix, \".\").concat(key));\n      } else {\n        try {\n          storage.setItem(\"\".concat(prefix, \".\").concat(key), JSON.stringify(value));\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    },\n    removeItem: function removeItem(key) {\n      return storage.removeItem(\"\".concat(prefix, \".\").concat(key));\n    }\n  });\n}\n\nvar storeKey = 'store';\n\nvar _isAutoConnecting = /*#__PURE__*/new WeakMap();\n\nvar _lastUsedConnector = /*#__PURE__*/new WeakMap();\n\nvar _addEffects = /*#__PURE__*/new WeakSet();\n\nvar Client = /*#__PURE__*/function () {\n  function Client(_ref) {\n    var _this19 = this;\n\n    _classCallCheck(this, Client);\n\n    var _ref$autoConnect = _ref.autoConnect,\n        autoConnect = _ref$autoConnect === void 0 ? false : _ref$autoConnect,\n        _ref$connectors = _ref.connectors,\n        connectors = _ref$connectors === void 0 ? [new InjectedConnector()] : _ref$connectors,\n        _provider = _ref.provider,\n        _ref$storage = _ref.storage,\n        storage = _ref$storage === void 0 ? createStorage({\n      storage: typeof window !== 'undefined' ? window.localStorage : noopStorage\n    }) : _ref$storage,\n        _ref$logger = _ref.logger,\n        logger = _ref$logger === void 0 ? {\n      warn: console.warn\n    } : _ref$logger,\n        _webSocketProvider = _ref.webSocketProvider;\n\n    _classPrivateMethodInitSpec(this, _addEffects);\n\n    _defineProperty(this, \"config\", void 0);\n\n    _defineProperty(this, \"providers\", new Map());\n\n    _defineProperty(this, \"storage\", void 0);\n\n    _defineProperty(this, \"store\", void 0);\n\n    _defineProperty(this, \"webSocketProviders\", new Map());\n\n    _classPrivateFieldInitSpec(this, _isAutoConnecting, {\n      writable: true,\n      value: void 0\n    });\n\n    _classPrivateFieldInitSpec(this, _lastUsedConnector, {\n      writable: true,\n      value: void 0\n    });\n\n    this.config = {\n      autoConnect: autoConnect,\n      connectors: connectors,\n      logger: logger,\n      provider: _provider,\n      storage: storage,\n      webSocketProvider: _webSocketProvider\n    }; // Check status for autoConnect flag\n\n    var status = 'disconnected';\n\n    var _chainId;\n\n    if (autoConnect) {\n      try {\n        var _JSON$parse, _JSON$parse$state, _data$chain;\n\n        var rawState = storage.getItem(storeKey, '');\n        var data = (_JSON$parse = JSON.parse(rawState || '{}')) === null || _JSON$parse === void 0 ? void 0 : (_JSON$parse$state = _JSON$parse.state) === null || _JSON$parse$state === void 0 ? void 0 : _JSON$parse$state.data; // If account exists in localStorage, set status to reconnecting\n\n        status = data !== null && data !== void 0 && data.account ? 'reconnecting' : 'connecting';\n        _chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id; // eslint-disable-next-line no-empty\n      } catch (_error) {}\n    } // Create store\n\n\n    this.store = create(subscribeWithSelector(persist(function () {\n      return {\n        connectors: typeof connectors === 'function' ? connectors() : connectors,\n        provider: _this19.getProvider({\n          chainId: _chainId\n        }),\n        status: status,\n        webSocketProvider: _this19.getWebSocketProvider({\n          chainId: _chainId\n        })\n      };\n    }, {\n      name: storeKey,\n      getStorage: function getStorage() {\n        return storage;\n      },\n      partialize: function partialize(state) {\n        var _state$data, _state$data2;\n\n        return _objectSpread(_objectSpread({}, autoConnect && {\n          data: {\n            account: state === null || state === void 0 ? void 0 : (_state$data = state.data) === null || _state$data === void 0 ? void 0 : _state$data.account,\n            chain: state === null || state === void 0 ? void 0 : (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : _state$data2.chain\n          }\n        }), {}, {\n          chains: state === null || state === void 0 ? void 0 : state.chains\n        });\n      },\n      version: 1\n    })));\n    this.storage = storage;\n\n    _classPrivateFieldSet(this, _lastUsedConnector, storage === null || storage === void 0 ? void 0 : storage.getItem('wallet'));\n\n    _classPrivateMethodGet(this, _addEffects, _addEffects2).call(this);\n\n    if (autoConnect && typeof window !== 'undefined') setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return _this19.autoConnect();\n\n            case 2:\n              return _context10.abrupt(\"return\", _context10.sent);\n\n            case 3:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    })), 0);\n  }\n\n  _createClass(Client, [{\n    key: \"chains\",\n    get: function get() {\n      return this.store.getState().chains;\n    }\n  }, {\n    key: \"connectors\",\n    get: function get() {\n      return this.store.getState().connectors;\n    }\n  }, {\n    key: \"connector\",\n    get: function get() {\n      return this.store.getState().connector;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.store.getState().data;\n    }\n  }, {\n    key: \"error\",\n    get: function get() {\n      return this.store.getState().error;\n    }\n  }, {\n    key: \"lastUsedChainId\",\n    get: function get() {\n      var _this$data, _this$data$chain;\n\n      return (_this$data = this.data) === null || _this$data === void 0 ? void 0 : (_this$data$chain = _this$data.chain) === null || _this$data$chain === void 0 ? void 0 : _this$data$chain.id;\n    }\n  }, {\n    key: \"provider\",\n    get: function get() {\n      return this.store.getState().provider;\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this.store.getState().status;\n    }\n  }, {\n    key: \"subscribe\",\n    get: function get() {\n      return this.store.subscribe;\n    }\n  }, {\n    key: \"webSocketProvider\",\n    get: function get() {\n      return this.store.getState().webSocketProvider;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updater) {\n      var newState = typeof updater === 'function' ? updater(this.store.getState()) : updater;\n      this.store.setState(newState, true);\n    }\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.setState(function (x) {\n        return _objectSpread(_objectSpread({}, x), {}, {\n          connector: undefined,\n          data: undefined,\n          error: undefined,\n          status: 'disconnected'\n        });\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function () {\n      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var _this$connector$disco, _this$connector;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!this.connector) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                _context11.next = 3;\n                return (_this$connector$disco = (_this$connector = this.connector).disconnect) === null || _this$connector$disco === void 0 ? void 0 : _this$connector$disco.call(_this$connector);\n\n              case 3:\n                _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n                this.clearState();\n                this.store.destroy();\n\n              case 6:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function destroy() {\n        return _destroy.apply(this, arguments);\n      }\n\n      return destroy;\n    }()\n  }, {\n    key: \"autoConnect\",\n    value: function () {\n      var _autoConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _this20 = this;\n\n        var sorted, connected, _iterator2, _step2, _loop, _ret;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!_classPrivateFieldGet(this, _isAutoConnecting)) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\");\n\n              case 2:\n                _classPrivateFieldSet(this, _isAutoConnecting, true);\n\n                this.setState(function (x) {\n                  var _x$data;\n\n                  return _objectSpread(_objectSpread({}, x), {}, {\n                    status: (_x$data = x.data) !== null && _x$data !== void 0 && _x$data.account ? 'reconnecting' : 'connecting'\n                  });\n                }); // Try last used connector first\n\n                sorted = _classPrivateFieldGet(this, _lastUsedConnector) ? _toConsumableArray(this.connectors).sort(function (x) {\n                  return x.id === _classPrivateFieldGet(_this20, _lastUsedConnector) ? -1 : 1;\n                }) : this.connectors;\n                connected = false;\n                _iterator2 = _createForOfIteratorHelper(sorted);\n                _context13.prev = 7;\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                  var connector, isAuthorized, data;\n                  return _regeneratorRuntime().wrap(function _loop$(_context12) {\n                    while (1) {\n                      switch (_context12.prev = _context12.next) {\n                        case 0:\n                          connector = _step2.value;\n\n                          if (!(!connector.ready || !connector.isAuthorized)) {\n                            _context12.next = 3;\n                            break;\n                          }\n\n                          return _context12.abrupt(\"return\", \"continue\");\n\n                        case 3:\n                          _context12.next = 5;\n                          return connector.isAuthorized();\n\n                        case 5:\n                          isAuthorized = _context12.sent;\n\n                          if (isAuthorized) {\n                            _context12.next = 8;\n                            break;\n                          }\n\n                          return _context12.abrupt(\"return\", \"continue\");\n\n                        case 8:\n                          _context12.next = 10;\n                          return connector.connect();\n\n                        case 10:\n                          data = _context12.sent;\n\n                          _this20.setState(function (x) {\n                            return _objectSpread(_objectSpread({}, x), {}, {\n                              connector: connector,\n                              chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n                              data: data,\n                              status: 'connected'\n                            });\n                          });\n\n                          connected = true;\n                          return _context12.abrupt(\"return\", \"break\");\n\n                        case 14:\n                        case \"end\":\n                          return _context12.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n\n                _iterator2.s();\n\n              case 10:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context13.next = 19;\n                  break;\n                }\n\n                return _context13.delegateYield(_loop(), \"t0\", 12);\n\n              case 12:\n                _ret = _context13.t0;\n\n                if (!(_ret === \"continue\")) {\n                  _context13.next = 15;\n                  break;\n                }\n\n                return _context13.abrupt(\"continue\", 17);\n\n              case 15:\n                if (!(_ret === \"break\")) {\n                  _context13.next = 17;\n                  break;\n                }\n\n                return _context13.abrupt(\"break\", 19);\n\n              case 17:\n                _context13.next = 10;\n                break;\n\n              case 19:\n                _context13.next = 24;\n                break;\n\n              case 21:\n                _context13.prev = 21;\n                _context13.t1 = _context13[\"catch\"](7);\n\n                _iterator2.e(_context13.t1);\n\n              case 24:\n                _context13.prev = 24;\n\n                _iterator2.f();\n\n                return _context13.finish(24);\n\n              case 27:\n                // If connecting didn't succeed, set to disconnected\n                if (!connected) this.setState(function (x) {\n                  return _objectSpread(_objectSpread({}, x), {}, {\n                    data: undefined,\n                    status: 'disconnected'\n                  });\n                });\n\n                _classPrivateFieldSet(this, _isAutoConnecting, false);\n\n                return _context13.abrupt(\"return\", this.data);\n\n              case 30:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee12, this, [[7, 21, 24, 27]]);\n      }));\n\n      function autoConnect() {\n        return _autoConnect.apply(this, arguments);\n      }\n\n      return autoConnect;\n    }()\n  }, {\n    key: \"getProvider\",\n    value: function getProvider() {\n      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          bust = _ref13.bust,\n          chainId = _ref13.chainId;\n\n      var provider_ = this.providers.get(chainId !== null && chainId !== void 0 ? chainId : -1);\n      if (provider_ && !bust) return provider_;\n      var provider = this.config.provider;\n      provider_ = typeof provider === 'function' ? provider({\n        chainId: chainId\n      }) : provider;\n      this.providers.set(chainId !== null && chainId !== void 0 ? chainId : -1, provider_);\n      return provider_;\n    }\n  }, {\n    key: \"getWebSocketProvider\",\n    value: function getWebSocketProvider() {\n      var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          bust = _ref14.bust,\n          chainId = _ref14.chainId;\n\n      var webSocketProvider_ = this.webSocketProviders.get(chainId !== null && chainId !== void 0 ? chainId : -1);\n      if (webSocketProvider_ && !bust) return webSocketProvider_;\n      var webSocketProvider = this.config.webSocketProvider;\n      webSocketProvider_ = typeof webSocketProvider === 'function' ? webSocketProvider({\n        chainId: chainId\n      }) : webSocketProvider;\n      if (webSocketProvider_) this.webSocketProviders.set(chainId !== null && chainId !== void 0 ? chainId : -1, webSocketProvider_);\n      return webSocketProvider_;\n    }\n  }, {\n    key: \"setLastUsedConnector\",\n    value: function setLastUsedConnector() {\n      var _this$storage;\n\n      var lastUsedConnector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      (_this$storage = this.storage) === null || _this$storage === void 0 ? void 0 : _this$storage.setItem('wallet', lastUsedConnector);\n    }\n  }]);\n\n  return Client;\n}();\n\nfunction _addEffects2() {\n  var _this21 = this;\n\n  var onChange = function onChange(data) {\n    _this21.setState(function (x) {\n      return _objectSpread(_objectSpread({}, x), {}, {\n        data: _objectSpread(_objectSpread({}, x.data), data)\n      });\n    });\n  };\n\n  var onDisconnect = function onDisconnect() {\n    _this21.clearState();\n  };\n\n  var onError = function onError(error) {\n    _this21.setState(function (x) {\n      return _objectSpread(_objectSpread({}, x), {}, {\n        error: error\n      });\n    });\n  };\n\n  this.store.subscribe(function (_ref2) {\n    var connector = _ref2.connector;\n    return connector;\n  }, function (connector, prevConnector) {\n    var _prevConnector$off, _prevConnector$off2, _prevConnector$off3, _connector$on, _connector$on2, _connector$on3;\n\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off = prevConnector.off) === null || _prevConnector$off === void 0 ? void 0 : _prevConnector$off.call(prevConnector, 'change', onChange);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off2 = prevConnector.off) === null || _prevConnector$off2 === void 0 ? void 0 : _prevConnector$off2.call(prevConnector, 'disconnect', onDisconnect);\n    prevConnector === null || prevConnector === void 0 ? void 0 : (_prevConnector$off3 = prevConnector.off) === null || _prevConnector$off3 === void 0 ? void 0 : _prevConnector$off3.call(prevConnector, 'error', onError);\n    if (!connector) return;\n    (_connector$on = connector.on) === null || _connector$on === void 0 ? void 0 : _connector$on.call(connector, 'change', onChange);\n    (_connector$on2 = connector.on) === null || _connector$on2 === void 0 ? void 0 : _connector$on2.call(connector, 'disconnect', onDisconnect);\n    (_connector$on3 = connector.on) === null || _connector$on3 === void 0 ? void 0 : _connector$on3.call(connector, 'error', onError);\n  });\n  var _this$config = this.config,\n      provider = _this$config.provider,\n      webSocketProvider = _this$config.webSocketProvider;\n  var subscribeProvider = typeof provider === 'function';\n  var subscribeWebSocketProvider = typeof webSocketProvider === 'function';\n  if (subscribeProvider || subscribeWebSocketProvider) this.store.subscribe(function (_ref3) {\n    var _data$chain2;\n\n    var data = _ref3.data;\n    return data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.id;\n  }, function (chainId) {\n    _this21.setState(function (x) {\n      return _objectSpread(_objectSpread({}, x), {}, {\n        provider: _this21.getProvider({\n          bust: true,\n          chainId: chainId\n        }),\n        webSocketProvider: _this21.getWebSocketProvider({\n          bust: true,\n          chainId: chainId\n        })\n      });\n    });\n  });\n}\n\nvar client;\n\nfunction createClient(config) {\n  var client_ = new Client(config);\n  client = client_;\n  return client_;\n}\n\nfunction getClient() {\n  if (!client) {\n    throw new Error('No wagmi client found. Ensure you have set up a client: https://wagmi.sh/docs/client');\n  }\n\n  return client;\n}\n\nfunction getProvider() {\n  var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      chainId = _ref15.chainId;\n\n  var client = getClient();\n  if (chainId) return client.getProvider({\n    chainId: chainId\n  }) || client.provider;\n  return client.provider;\n}\n\nexport { AddChainError as A, ConnectorAlreadyConnectedError as C, InjectedConnector as I, ProviderChainsNotFound as P, ResourceUnavailableError as R, SwitchChainNotSupportedError as S, UserRejectedRequestError as U, _classPrivateMethodInitSpec as _, ConnectorNotFoundError as a, ChainMismatchError as b, ContractMethodDoesNotExistError as c, getProvider as d, ChainDoesNotSupportMulticallError as e, ContractMethodRevertedError as f, getClient as g, ContractMethodNoResultError as h, ContractResultDecodeError as i, createClient as j, Client as k, Connector as l, ChainNotConfiguredError as m, normalizeChainId as n, ProviderRpcError as o, RpcError as p, SwitchChainError as q, createStorage as r, noopStorage as s, _defineProperty as t, _classPrivateFieldInitSpec as u, _classPrivateFieldGet as v, _classPrivateFieldSet as w, _classPrivateMethodGet as x };","map":null,"metadata":{},"sourceType":"module"}