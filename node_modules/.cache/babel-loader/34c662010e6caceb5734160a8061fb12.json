{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, NETWORK_FAILURE, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthUnknownError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse } from './lib/fetch';\nimport { decodeBase64URL, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS\n};\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n\n    this.stateChangeEmitters = new Map();\n    this.networkRetries = 0;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n\n      return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _yield$this$_getSessi, data, error, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.initializePromise) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.initializePromise);\n\n              case 2:\n                _context.prev = 2;\n\n                if (!(this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n                  _context.next = 19;\n                  break;\n                }\n\n                _context.next = 6;\n                return this._getSessionFromUrl();\n\n              case 6:\n                _yield$this$_getSessi = _context.sent;\n                data = _yield$this$_getSessi.data;\n                error = _yield$this$_getSessi.error;\n\n                if (!error) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 12;\n                return this._removeSession();\n\n              case 12:\n                return _context.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 13:\n                session = data.session, redirectType = data.redirectType;\n                _context.next = 16;\n                return this._saveSession(session);\n\n              case 16:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n                if (redirectType === 'recovery') {\n                  this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 19:\n                _context.next = 21;\n                return this._recoverAndRefresh();\n\n              case 21:\n                return _context.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](2);\n\n                if (!isAuthError(_context.t0)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  error: _context.t0\n                });\n\n              case 28:\n                return _context.abrupt(\"return\", {\n                  error: new AuthUnknownError('Unexpected error during initialization', _context.t0)\n                });\n\n              case 29:\n                _context.prev = 29;\n\n                this._handleVisibilityChange();\n\n                return _context.finish(29);\n\n              case 32:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 24, 29, 32]]);\n      }));\n    }\n    /**\n     * Creates a new user.\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var res, email, password, options, phone, _password, _options, _res, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context2.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                  body: {\n                    email: email,\n                    password: password,\n                    data: options === null || options === void 0 ? void 0 : options.data,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n                _context2.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password,\n                    data: _options === null || _options === void 0 ? void 0 : _options.data,\n                    gotrue_meta_security: {\n                      captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context2.sent;\n                _context2.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res = res, data = _res.data, error = _res.error;\n\n                if (!(error || !data)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                session = data.session;\n                user = data.user;\n\n                if (!data.session) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                _context2.next = 26;\n                return this._saveSession(data.session);\n\n              case 26:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 27:\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n                _context2.prev = 30;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!isAuthError(_context2.t0)) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context2.t0\n                });\n\n              case 34:\n                throw _context2.t0;\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 30]]);\n      }));\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     */\n\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                email = credentials.email, password = credentials.password, options = credentials.options;\n                _context3.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    password: password,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 7:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n                _context3.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    password: _password2,\n                    gotrue_meta_security: {\n                      captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                    }\n                  },\n                  xform: _sessionResponse\n                });\n\n              case 14:\n                res = _context3.sent;\n                _context3.next = 18;\n                break;\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n\n              case 18:\n                _res2 = res, data = _res2.data, error = _res2.error;\n\n                if (!(error || !data)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 21:\n                if (!data.session) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                _context3.next = 24;\n                return this._saveSession(data.session);\n\n              case 24:\n                this._notifyAllSubscribers('SIGNED_IN', data.session);\n\n              case 25:\n                return _context3.abrupt(\"return\", {\n                  data: data,\n                  error: error\n                });\n\n              case 28:\n                _context3.prev = 28;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                if (!isAuthError(_context3.t0)) {\n                  _context3.next = 32;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context3.t0\n                });\n\n              case 32:\n                throw _context3.t0;\n\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 28]]);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     */\n\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._removeSession();\n\n              case 2:\n                return _context4.abrupt(\"return\", this._handleProviderSignIn(credentials.provider, {\n                  redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                  scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                  queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     */\n\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var email, options, _yield$_request, error, phone, _options3, _yield$_request2, _error;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return this._removeSession();\n\n              case 3:\n                if (!('email' in credentials)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                email = credentials.email, options = credentials.options;\n                _context5.next = 7;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    email: email,\n                    data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                    create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                    gotrue_meta_security: {\n                      captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                  },\n                  redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n\n              case 7:\n                _yield$_request = _context5.sent;\n                error = _yield$_request.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 10:\n                if (!('phone' in credentials)) {\n                  _context5.next = 17;\n                  break;\n                }\n\n                phone = credentials.phone, _options3 = credentials.options;\n                _context5.next = 14;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                  headers: this.headers,\n                  body: {\n                    phone: phone,\n                    data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                    create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                    gotrue_meta_security: {\n                      captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                    }\n                  }\n                });\n\n              case 14:\n                _yield$_request2 = _context5.sent;\n                _error = _yield$_request2.error;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _error\n                });\n\n              case 17:\n                throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n\n              case 20:\n                _context5.prev = 20;\n                _context5.t0 = _context5[\"catch\"](0);\n\n                if (!isAuthError(_context5.t0)) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context5.t0\n                });\n\n              case 24:\n                throw _context5.t0;\n\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 20]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _yield$_request3, data, error, session, user;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return this._removeSession();\n\n              case 3:\n                _context6.next = 5;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                  headers: this.headers,\n                  body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                      captchaToken: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                    }\n                  }),\n                  redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                  xform: _sessionResponse\n                });\n\n              case 5:\n                _yield$_request3 = _context6.sent;\n                data = _yield$_request3.data;\n                error = _yield$_request3.error;\n\n                if (!error) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                throw 'An error occurred on token verification.';\n\n              case 12:\n                session = data.session;\n                user = data.user;\n\n                if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                _context6.next = 17;\n                return this._saveSession(session);\n\n              case 17:\n                this._notifyAllSubscribers('SIGNED_IN', session);\n\n              case 18:\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: user,\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 21:\n                _context6.prev = 21;\n                _context6.t0 = _context6[\"catch\"](0);\n\n                if (!isAuthError(_context6.t0)) {\n                  _context6.next = 25;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: {\n                    user: null,\n                    session: null\n                  },\n                  error: _context6.t0\n                });\n\n              case 25:\n                throw _context6.t0;\n\n              case 26:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 21]]);\n      }));\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.initializePromise;\n\n              case 2:\n                currentSession = null;\n\n                if (!this.persistSession) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                _context7.next = 6;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 6:\n                maybeSession = _context7.sent;\n\n                if (!(maybeSession !== null)) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                if (!this._isValidSession(maybeSession)) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                currentSession = maybeSession;\n                _context7.next = 14;\n                break;\n\n              case 12:\n                _context7.next = 14;\n                return this._removeSession();\n\n              case 14:\n                _context7.next = 17;\n                break;\n\n              case 16:\n                currentSession = this.inMemorySession;\n\n              case 17:\n                if (currentSession) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: null\n                });\n\n              case 19:\n                hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n\n                if (hasExpired) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    session: currentSession\n                  },\n                  error: null\n                });\n\n              case 22:\n                _context7.next = 24;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 24:\n                _yield$this$_callRefr = _context7.sent;\n                session = _yield$this$_callRefr.session;\n                error = _yield$this$_callRefr.error;\n\n                if (!error) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    session: null\n                  },\n                  error: error\n                });\n\n              case 29:\n                return _context7.abrupt(\"return\", {\n                  data: {\n                    session: session\n                  },\n                  error: null\n                });\n\n              case 30:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _yield$this$getSessio, data, error;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n\n                if (jwt) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                _context8.next = 4;\n                return this.getSession();\n\n              case 4:\n                _yield$this$getSessio = _context8.sent;\n                data = _yield$this$getSessio.data;\n                error = _yield$this$getSessio.error;\n\n                if (!error) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                // Default to Authorization header if there is no existing session\n                jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n\n              case 10:\n                _context8.next = 12;\n                return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  jwt: jwt,\n                  xform: _userResponse\n                });\n\n              case 12:\n                return _context8.abrupt(\"return\", _context8.sent);\n\n              case 15:\n                _context8.prev = 15;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!isAuthError(_context8.t0)) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context8.t0\n                });\n\n              case 19:\n                throw _context8.t0;\n\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _yield$this$getSessio2, sessionData, sessionError, session, _yield$_request4, data, userError;\n\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.getSession();\n\n              case 3:\n                _yield$this$getSessio2 = _context9.sent;\n                sessionData = _yield$this$getSessio2.data;\n                sessionError = _yield$this$getSessio2.error;\n\n                if (!sessionError) {\n                  _context9.next = 8;\n                  break;\n                }\n\n                throw sessionError;\n\n              case 8:\n                if (sessionData.session) {\n                  _context9.next = 10;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 10:\n                session = sessionData.session;\n                _context9.next = 13;\n                return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                  headers: this.headers,\n                  body: attributes,\n                  jwt: session.access_token,\n                  xform: _userResponse\n                });\n\n              case 13:\n                _yield$_request4 = _context9.sent;\n                data = _yield$_request4.data;\n                userError = _yield$_request4.error;\n\n                if (!userError) {\n                  _context9.next = 18;\n                  break;\n                }\n\n                throw userError;\n\n              case 18:\n                session.user = data.user;\n                _context9.next = 21;\n                return this._saveSession(session);\n\n              case 21:\n                this._notifyAllSubscribers('USER_UPDATED', session);\n\n                return _context9.abrupt(\"return\", {\n                  data: {\n                    user: session.user\n                  },\n                  error: null\n                });\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!isAuthError(_context9.t0)) {\n                  _context9.next = 29;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: {\n                    user: null\n                  },\n                  error: _context9.t0\n                });\n\n              case 29:\n                throw _context9.t0;\n\n              case 30:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token in the current session is invalid and the current session has expired, an error will be thrown.\n     * If the current session does not contain at expires_at field, setSession will use the exp claim defined in the access token.\n     * @param currentSession The current session that minimally contains an access token, refresh token and a user.\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_refreshA, data, error, _yield$this$getUser, _data, _error2;\n\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                timeNow = Date.now() / 1000;\n                expiresAt = timeNow;\n                hasExpired = true;\n                session = null;\n\n                if (currentSession.access_token && currentSession.access_token.split('.')[1]) {\n                  payload = JSON.parse(decodeBase64URL(currentSession.access_token.split('.')[1]));\n\n                  if (payload.exp) {\n                    expiresAt = payload.exp;\n                    hasExpired = expiresAt <= timeNow;\n                  }\n                }\n\n                if (!hasExpired) {\n                  _context10.next = 21;\n                  break;\n                }\n\n                if (currentSession.refresh_token) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 9:\n                _context10.next = 11;\n                return this._refreshAccessToken(currentSession.refresh_token);\n\n              case 11:\n                _yield$this$_refreshA = _context10.sent;\n                data = _yield$this$_refreshA.data;\n                error = _yield$this$_refreshA.error;\n\n                if (!error) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: error\n                });\n\n              case 16:\n                if (data.session) {\n                  _context10.next = 18;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: null\n                });\n\n              case 18:\n                session = data.session;\n                _context10.next = 29;\n                break;\n\n              case 21:\n                _context10.next = 23;\n                return this.getUser(currentSession.access_token);\n\n              case 23:\n                _yield$this$getUser = _context10.sent;\n                _data = _yield$this$getUser.data;\n                _error2 = _yield$this$getUser.error;\n\n                if (!_error2) {\n                  _context10.next = 28;\n                  break;\n                }\n\n                throw _error2;\n\n              case 28:\n                session = {\n                  access_token: currentSession.access_token,\n                  refresh_token: currentSession.refresh_token,\n                  user: _data.user,\n                  token_type: 'bearer',\n                  expires_in: expiresAt - timeNow,\n                  expires_at: expiresAt\n                };\n\n              case 29:\n                _context10.next = 31;\n                return this._saveSession(session);\n\n              case 31:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', session);\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    user: session.user\n                  },\n                  error: null\n                });\n\n              case 35:\n                _context10.prev = 35;\n                _context10.t0 = _context10[\"catch\"](0);\n\n                if (!isAuthError(_context10.t0)) {\n                  _context10.next = 39;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context10.t0\n                });\n\n              case 39:\n                throw _context10.t0;\n\n              case 40:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 35]]);\n      }));\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var error_description, error_code, _error3, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n\n                if (isBrowser()) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No browser detected.');\n\n              case 3:\n                if (this._isImplicitGrantFlow()) {\n                  _context11.next = 5;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n\n              case 5:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context11.next = 14;\n                  break;\n                }\n\n                error_code = getParameterByName('error_code');\n\n                if (error_code) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error_code detected.');\n\n              case 10:\n                _error3 = getParameterByName('error');\n\n                if (_error3) {\n                  _context11.next = 13;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No error detected.');\n\n              case 13:\n                throw new AuthImplicitGrantRedirectError(error_description, {\n                  error: _error3,\n                  code: error_code\n                });\n\n              case 14:\n                provider_token = getParameterByName('provider_token');\n                provider_refresh_token = getParameterByName('provider_refresh_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context11.next = 19;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No access_token detected.');\n\n              case 19:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context11.next = 22;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n\n              case 22:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context11.next = 25;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n\n              case 25:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context11.next = 28;\n                  break;\n                }\n\n                throw new AuthImplicitGrantRedirectError('No token_type detected.');\n\n              case 28:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context11.next = 32;\n                return this.getUser(access_token);\n\n              case 32:\n                _yield$this$getUser2 = _context11.sent;\n                data = _yield$this$getUser2.data;\n                error = _yield$this$getUser2.error;\n\n                if (!error) {\n                  _context11.next = 37;\n                  break;\n                }\n\n                throw error;\n\n              case 37:\n                user = data.user;\n                session = {\n                  provider_token: provider_token,\n                  provider_refresh_token: provider_refresh_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n                redirectType = getParameterByName('type'); // Remove tokens from URL\n\n                window.location.hash = '';\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    session: session,\n                    redirectType: redirectType\n                  },\n                  error: null\n                });\n\n              case 44:\n                _context11.prev = 44;\n                _context11.t0 = _context11[\"catch\"](0);\n\n                if (!isAuthError(_context11.t0)) {\n                  _context11.next = 48;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    redirectType: null\n                  },\n                  error: _context11.t0\n                });\n\n              case 48:\n                throw _context11.t0;\n\n              case 49:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 44]]);\n      }));\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio3, data, sessionError, accessToken, _yield$this$admin$sig, error;\n\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.getSession();\n\n              case 2:\n                _yield$this$getSessio3 = _context12.sent;\n                data = _yield$this$getSessio3.data;\n                sessionError = _yield$this$getSessio3.error;\n\n                if (!sessionError) {\n                  _context12.next = 7;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  error: sessionError\n                });\n\n              case 7:\n                accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                if (!accessToken) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                _context12.next = 11;\n                return this.admin.signOut(accessToken);\n\n              case 11:\n                _yield$this$admin$sig = _context12.sent;\n                error = _yield$this$admin$sig.error;\n\n                if (!error) {\n                  _context12.next = 15;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 15:\n                _context12.next = 17;\n                return this._removeSession();\n\n              case 17:\n                this._notifyAllSubscribers('SIGNED_OUT', null);\n\n                return _context12.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 19:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                  body: {\n                    email: email,\n                    gotrue_meta_security: {\n                      captcha_token: options.captchaToken\n                    }\n                  },\n                  headers: this.headers,\n                  redirectTo: options.redirectTo\n                });\n\n              case 3:\n                return _context13.abrupt(\"return\", _context13.sent);\n\n              case 6:\n                _context13.prev = 6;\n                _context13.t0 = _context13[\"catch\"](0);\n\n                if (!isAuthError(_context13.t0)) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", {\n                  data: null,\n                  error: _context13.t0\n                });\n\n              case 10:\n                throw _context13.t0;\n\n              case 11:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 6]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.prev = 0;\n                _context14.next = 3;\n                return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                  body: {\n                    refresh_token: refreshToken\n                  },\n                  headers: this.headers,\n                  xform: _sessionResponse\n                });\n\n              case 3:\n                return _context14.abrupt(\"return\", _context14.sent);\n\n              case 6:\n                _context14.prev = 6;\n                _context14.t0 = _context14[\"catch\"](0);\n\n                if (!isAuthError(_context14.t0)) {\n                  _context14.next = 10;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", {\n                  data: {\n                    session: null,\n                    user: null\n                  },\n                  error: _context14.t0\n                });\n\n              case 10:\n                throw _context14.t0;\n\n              case 11:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[0, 6]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var url = this._getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes,\n        queryParams: options.queryParams\n      }); // try to open on the browser\n\n\n      if (isBrowser()) {\n        window.location.href = url;\n      }\n\n      return {\n        data: {\n          provider: provider,\n          url: url\n        },\n        error: null\n      };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var _this2 = this;\n\n        var currentSession, timeNow, _yield$this$_callRefr2, error;\n\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.prev = 0;\n                _context15.next = 3;\n                return getItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                currentSession = _context15.sent;\n\n                if (this._isValidSession(currentSession)) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                if (!(currentSession !== null)) {\n                  _context15.next = 8;\n                  break;\n                }\n\n                _context15.next = 8;\n                return this._removeSession();\n\n              case 8:\n                return _context15.abrupt(\"return\");\n\n              case 9:\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                  _context15.next = 32;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context15.next = 28;\n                  break;\n                }\n\n                this.networkRetries++;\n                _context15.next = 15;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 15:\n                _yield$this$_callRefr2 = _context15.sent;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context15.next = 25;\n                  break;\n                }\n\n                console.log(error.message);\n\n                if (!(error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)) {\n                  _context15.next = 23;\n                  break;\n                }\n\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                this.refreshTokenTimer = setTimeout(function () {\n                  return _this2._recoverAndRefresh();\n                }, Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                );\n                return _context15.abrupt(\"return\");\n\n              case 23:\n                _context15.next = 25;\n                return this._removeSession();\n\n              case 25:\n                this.networkRetries = 0;\n                _context15.next = 30;\n                break;\n\n              case 28:\n                _context15.next = 30;\n                return this._removeSession();\n\n              case 30:\n                _context15.next = 36;\n                break;\n\n              case 32:\n                if (!this.persistSession) {\n                  _context15.next = 35;\n                  break;\n                }\n\n                _context15.next = 35;\n                return this._saveSession(currentSession);\n\n              case 35:\n                this._notifyAllSubscribers('SIGNED_IN', currentSession);\n\n              case 36:\n                _context15.next = 42;\n                break;\n\n              case 38:\n                _context15.prev = 38;\n                _context15.t0 = _context15[\"catch\"](0);\n                console.error(_context15.t0);\n                return _context15.abrupt(\"return\");\n\n              case 42:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this, [[0, 38]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _yield$this$_refreshA2, data, error, result, _result;\n\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!this.refreshingDeferred) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", this.refreshingDeferred.promise);\n\n              case 2:\n                _context16.prev = 2;\n                this.refreshingDeferred = new Deferred();\n\n                if (refreshToken) {\n                  _context16.next = 6;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 6:\n                _context16.next = 8;\n                return this._refreshAccessToken(refreshToken);\n\n              case 8:\n                _yield$this$_refreshA2 = _context16.sent;\n                data = _yield$this$_refreshA2.data;\n                error = _yield$this$_refreshA2.error;\n\n                if (!error) {\n                  _context16.next = 13;\n                  break;\n                }\n\n                throw error;\n\n              case 13:\n                if (data.session) {\n                  _context16.next = 15;\n                  break;\n                }\n\n                throw new AuthSessionMissingError();\n\n              case 15:\n                _context16.next = 17;\n                return this._saveSession(data.session);\n\n              case 17:\n                this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n\n                result = {\n                  session: data.session,\n                  error: null\n                };\n                this.refreshingDeferred.resolve(result);\n                return _context16.abrupt(\"return\", result);\n\n              case 23:\n                _context16.prev = 23;\n                _context16.t0 = _context16[\"catch\"](2);\n\n                if (!isAuthError(_context16.t0)) {\n                  _context16.next = 29;\n                  break;\n                }\n\n                _result = {\n                  session: null,\n                  error: _context16.t0\n                };\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n                return _context16.abrupt(\"return\", _result);\n\n              case 29:\n                (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context16.t0);\n                throw _context16.t0;\n\n              case 31:\n                _context16.prev = 31;\n                this.refreshingDeferred = null;\n                return _context16.finish(31);\n\n              case 34:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this, [[2, 23, 31, 34]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, session);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var expiresAt, timeNow, expiresIn, refreshDurationBeforeExpires;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!this.persistSession) {\n                  this.inMemorySession = session;\n                }\n\n                expiresAt = session.expires_at;\n\n                if (expiresAt) {\n                  timeNow = Math.round(Date.now() / 1000);\n                  expiresIn = expiresAt - timeNow;\n                  refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n\n                  this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n                }\n\n                if (!(this.persistSession && session.expires_at)) {\n                  _context17.next = 6;\n                  break;\n                }\n\n                _context17.next = 6;\n                return this._persistSession(session);\n\n              case 6:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (!this.persistSession) {\n                  _context18.next = 5;\n                  break;\n                }\n\n                _context18.next = 3;\n                return removeItemAsync(this.storage, this.storageKey);\n\n              case 3:\n                _context18.next = 6;\n                break;\n\n              case 5:\n                this.inMemorySession = null;\n\n              case 6:\n                if (this.refreshTokenTimer) {\n                  clearTimeout(this.refreshTokenTimer);\n                }\n\n              case 7:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds.\n     * @param session The current session.\n     */\n\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this3 = this;\n\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n          var _yield$this$getSessio4, session, sessionError, _yield$this$_callRefr3, error;\n\n          return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n            while (1) {\n              switch (_context19.prev = _context19.next) {\n                case 0:\n                  this.networkRetries++;\n                  _context19.next = 3;\n                  return this.getSession();\n\n                case 3:\n                  _yield$this$getSessio4 = _context19.sent;\n                  session = _yield$this$getSessio4.data.session;\n                  sessionError = _yield$this$getSessio4.error;\n\n                  if (!(!sessionError && session)) {\n                    _context19.next = 13;\n                    break;\n                  }\n\n                  _context19.next = 9;\n                  return this._callRefreshToken(session.refresh_token);\n\n                case 9:\n                  _yield$this$_callRefr3 = _context19.sent;\n                  error = _yield$this$_callRefr3.error;\n                  if (!error) this.networkRetries = 0;\n                  if (error instanceof AuthRetryableFetchError && this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n\n                case 13:\n                case \"end\":\n                  return _context19.stop();\n              }\n            }\n          }, _callee19, this);\n        }));\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      var _this4 = this;\n\n      if (!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return false;\n      }\n\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', function () {\n          return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n            return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n              while (1) {\n                switch (_context20.prev = _context20.next) {\n                  case 0:\n                    if (!(document.visibilityState === 'visible')) {\n                      _context20.next = 5;\n                      break;\n                    }\n\n                    _context20.next = 3;\n                    return this.initializePromise;\n\n                  case 3:\n                    _context20.next = 5;\n                    return this._recoverAndRefresh();\n\n                  case 5:\n                  case \"end\":\n                    return _context20.stop();\n                }\n              }\n            }, _callee20, this);\n          }));\n        });\n      } catch (error) {\n        console.error('_handleVisibilityChange', error);\n      }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      var urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n\n      if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.scopes) {\n        urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n      }\n\n      if (options === null || options === void 0 ? void 0 : options.queryParams) {\n        var query = new URLSearchParams(options.queryParams);\n        urlParams.push(query.toString());\n      }\n\n      return \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&'));\n    }\n  }]);\n\n  return GoTrueClient;\n}(); //# sourceMappingURL=GoTrueClient.js.map\n\n\nexport { GoTrueClient as default };","map":null,"metadata":{},"sourceType":"module"}