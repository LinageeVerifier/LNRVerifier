{"ast":null,"code":"import { g as getClient, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, b as ChainMismatchError, U as UserRejectedRequestError, c as ContractMethodDoesNotExistError, d as getProvider, P as ProviderChainsNotFound, e as ChainDoesNotSupportMulticallError, f as ContractMethodRevertedError, h as ContractMethodNoResultError, i as ContractResultDecodeError, n as normalizeChainId, S as SwitchChainNotSupportedError } from './getProvider-f1dfc7e3.esm.js';\nexport { A as AddChainError, e as ChainDoesNotSupportMulticallError, b as ChainMismatchError, m as ChainNotConfiguredError, k as Client, l as Connector, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, c as ContractMethodDoesNotExistError, h as ContractMethodNoResultError, f as ContractMethodRevertedError, i as ContractResultDecodeError, I as InjectedConnector, P as ProviderChainsNotFound, o as ProviderRpcError, R as ResourceUnavailableError, p as RpcError, q as SwitchChainError, S as SwitchChainNotSupportedError, U as UserRejectedRequestError, j as createClient, r as createStorage, d as getProvider, s as noopStorage, n as normalizeChainId } from './getProvider-f1dfc7e3.esm.js';\nimport { providers, Contract as Contract$1 } from 'ethers';\nimport { Contract, logger } from 'ethers/lib/ethers';\nimport { FormatTypes, formatUnits, getAddress, isAddress, Logger } from 'ethers/lib/utils';\nimport { m as mainnet } from './chains-8c76af1b.esm.js';\nexport { a as allChains, c as chain, b as chainId, d as defaultChains, e as defaultL2Chains, f as etherscanBlockExplorers } from './chains-8c76af1b.esm.js';\nimport shallow from 'zustand/shallow';\nimport { d as debounce } from './debounce-0862bf88.esm.js';\nexport { a as alchemyRpcUrls, i as infuraRpcUrls, p as publicRpcUrls } from './rpcs-8d636858.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\n\nfunction configureChains(defaultChains, providers) {\n  let {\n    minQuorum = 1,\n    pollingInterval = 4000,\n    targetQuorum = 1,\n    stallTimeout\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!defaultChains.length) throw new Error('must have at least one chain');\n  if (targetQuorum < minQuorum) throw new Error('quorum cannot be lower than minQuorum');\n  let chains = [];\n  const providers_ = {};\n  const webSocketProviders_ = {};\n\n  for (const chain of defaultChains) {\n    let configExists = false;\n\n    for (const provider of providers) {\n      const apiConfig = provider(chain); // If no API configuration was found (ie. no RPC URL) for\n      // this provider, then we skip and check the next one.\n\n      if (!apiConfig) continue;\n      configExists = true;\n\n      if (!chains.some(_ref => {\n        let {\n          id\n        } = _ref;\n        return id === chain.id;\n      })) {\n        chains = [...chains, apiConfig.chain];\n      }\n\n      providers_[chain.id] = [...(providers_[chain.id] || []), apiConfig.provider];\n\n      if (apiConfig.webSocketProvider) {\n        webSocketProviders_[chain.id] = [...(webSocketProviders_[chain.id] || []), apiConfig.webSocketProvider];\n      }\n    } // If no API configuration was found across the providers\n    // then we throw an error to the consumer.\n\n\n    if (!configExists) {\n      throw new Error([\"Could not find valid provider configuration for chain \\\"\".concat(chain.name, \"\\\".\\n\"), \"You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.\", 'Read more: https://wagmi.sh/docs/providers/jsonRpc'].join('\\n'));\n    }\n  }\n\n  return {\n    chains,\n    provider: _ref2 => {\n      var _defaultChains$;\n\n      let {\n        chainId\n      } = _ref2;\n      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$ = defaultChains[0]) === null || _defaultChains$ === void 0 ? void 0 : _defaultChains$.id;\n      const chainProviders = providers_[activeChainId];\n      if (!chainProviders || !chainProviders[0]) throw new Error(\"No providers configured for chain \\\"\".concat(activeChainId, \"\\\"\"));\n\n      if (chainProviders.length === 1) {\n        return Object.assign(chainProviders[0](), {\n          chains,\n          pollingInterval\n        });\n      }\n\n      return Object.assign(fallbackProvider(targetQuorum, minQuorum, chainProviders, {\n        stallTimeout\n      }), {\n        chains,\n        pollingInterval\n      });\n    },\n    webSocketProvider: _ref3 => {\n      var _defaultChains$2, _chainWebSocketProvid;\n\n      let {\n        chainId\n      } = _ref3;\n      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$2 = defaultChains[0]) === null || _defaultChains$2 === void 0 ? void 0 : _defaultChains$2.id;\n      const chainWebSocketProviders = webSocketProviders_[activeChainId];\n      if (!chainWebSocketProviders) return undefined; // WebSockets do not work with `fallbackProvider`\n      // Default to first available\n\n      return Object.assign(((_chainWebSocketProvid = chainWebSocketProviders[0]) === null || _chainWebSocketProvid === void 0 ? void 0 : _chainWebSocketProvid.call(chainWebSocketProviders)) || {}, {\n        chains\n      });\n    }\n  };\n}\n\nfunction fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {\n  let {\n    stallTimeout\n  } = _ref4;\n\n  try {\n    return new providers.FallbackProvider(providers_.map((chainProvider, index) => {\n      var _provider$priority, _provider$stallTimeou;\n\n      const provider = chainProvider();\n      return {\n        provider,\n        priority: (_provider$priority = provider.priority) !== null && _provider$priority !== void 0 ? _provider$priority : index,\n        stallTimeout: (_provider$stallTimeou = provider.stallTimeout) !== null && _provider$stallTimeou !== void 0 ? _provider$stallTimeou : stallTimeout,\n        weight: provider.weight\n      };\n    }), targetQuorum);\n  } catch (error) {\n    var _error$message;\n\n    if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('quorum will always fail; larger than total weight')) {\n      if (targetQuorum === minQuorum) throw error;\n      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {\n        stallTimeout\n      });\n    }\n\n    throw error;\n  }\n}\n/** Forked from https://github.com/epoberezkin/fast-deep-equal */\n\n\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    if (a.constructor !== b.constructor) return false;\n    let length;\n    let i;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n\n\n  return a !== a && b !== b;\n}\n\nfunction logWarn(message) {\n  var _getClient, _getClient$config$log, _getClient$config$log2;\n\n  (_getClient = getClient()) === null || _getClient === void 0 ? void 0 : (_getClient$config$log = _getClient.config.logger) === null || _getClient$config$log === void 0 ? void 0 : (_getClient$config$log2 = _getClient$config$log.warn) === null || _getClient$config$log2 === void 0 ? void 0 : _getClient$config$log2.call(_getClient$config$log, message);\n}\n\nfunction minimizeContractInterface(_ref) {\n  let {\n    contractInterface,\n    functionName\n  } = _ref;\n  const abi = Contract.getInterface(contractInterface).format(FormatTypes.full);\n  const minimizedInterface = Array.isArray(abi) ? abi : [abi];\n  return minimizedInterface.filter(i => i.includes(functionName));\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\n\nfunction parseContractResult(_ref) {\n  let {\n    contractInterface,\n    data,\n    functionName\n  } = _ref;\n\n  if (data && isPlainArray(data)) {\n    var _fragment$outputs;\n\n    const iface = Contract.getInterface(contractInterface);\n    const fragment = iface.getFunction(functionName);\n    const isTuple = (((_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : _fragment$outputs.length) || 0) > 1;\n    const data_ = isTuple ? data : [data];\n    const encodedResult = iface.encodeFunctionResult(functionName, data_);\n    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isTuple ? decodedResult : decodedResult[0];\n  }\n\n  return data;\n} // https://ethereum.org/en/developers/docs/standards/tokens/erc-20\n\n\nconst erc20ABI = ['event Approval(address indexed _owner, address indexed _spender, uint256 _value)', 'event Transfer(address indexed _from, address indexed _to, uint256 _value)', 'function allowance(address _owner, address _spender) public view returns (uint256 remaining)', 'function approve(address _spender, uint256 _value) public returns (bool success)', 'function balanceOf(address _owner) public view returns (uint256 balance)', 'function decimals() public view returns (uint8)', 'function name() public view returns (string)', 'function symbol() public view returns (string)', 'function totalSupply() public view returns (uint256)', 'function transfer(address _to, uint256 _value) public returns (bool success)', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)']; // https://ethereum.org/en/developers/docs/standards/tokens/erc-721\n\nconst erc721ABI = ['event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId)', 'event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)', 'event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)', 'function approve(address _approved, uint256 _tokenId) external payable', 'function balanceOf(address _owner) external view returns (uint256)', 'function getApproved(uint256 _tokenId) external view returns (address)', 'function isApprovedForAll(address _owner, address _operator) external view returns (bool)', 'function name() view returns (string memory)', 'function ownerOf(uint256 _tokenId) external view returns (address)', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable', 'function setApprovalForAll(address _operator, bool _approved) external', 'function symbol() view returns (string memory)', 'function tokenByIndex(uint256 _index) view returns (uint256)', 'function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256 tokenId)', 'function tokenURI(uint256 _tokenId) view returns (string memory)', 'function totalSupply() view returns (uint256)', 'function transferFrom(address _from, address _to, uint256 _tokenId) external payable'];\nconst multicallInterface = [{\n  inputs: [{\n    components: [{\n      internalType: 'address',\n      name: 'target',\n      type: 'address'\n    }, {\n      internalType: 'bool',\n      name: 'allowFailure',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'callData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Call3[]',\n    name: 'calls',\n    type: 'tuple[]'\n  }],\n  name: 'aggregate3',\n  outputs: [{\n    components: [{\n      internalType: 'bool',\n      name: 'success',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'returnData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Result[]',\n    name: 'returnData',\n    type: 'tuple[]'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}]; // https://github.com/ethers-io/ethers.js/blob/master/packages/units/src.ts/index.ts#L10-L18\n\nconst units = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];\n\nasync function connect(_ref) {\n  let {\n    chainId,\n    connector\n  } = _ref;\n  const client = getClient();\n  const activeConnector = client.connector;\n  if (connector.id === (activeConnector === null || activeConnector === void 0 ? void 0 : activeConnector.id)) throw new ConnectorAlreadyConnectedError();\n\n  try {\n    client.setState(x => ({ ...x,\n      status: 'connecting'\n    }));\n    const data = await connector.connect({\n      chainId\n    });\n    client.setLastUsedConnector(connector.id);\n    client.setState(x => ({ ...x,\n      connector,\n      chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n      data,\n      status: 'connected'\n    }));\n    client.storage.setItem('connected', true);\n    return { ...data,\n      connector\n    };\n  } catch (err) {\n    client.setState(x => {\n      return { ...x,\n        // Keep existing connector connected in case of error\n        status: x.connector ? 'connected' : 'disconnected'\n      };\n    });\n    throw err;\n  }\n}\n\nasync function disconnect() {\n  const client = getClient();\n  if (client.connector) await client.connector.disconnect();\n  client.clearState();\n  client.storage.removeItem('connected');\n}\n\nfunction getContract(_ref) {\n  let {\n    addressOrName,\n    contractInterface,\n    signerOrProvider\n  } = _ref;\n  return new Contract$1(addressOrName, contractInterface, signerOrProvider);\n}\n\nasync function deprecatedWriteContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    overrides,\n    signerOrProvider\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n\n  try {\n    var _chain;\n\n    let chain;\n\n    if (chainId) {\n      const activeChainId = await connector.getChainId(); // Try to switch chain to provided `chainId`\n\n      if (chainId !== activeChainId) {\n        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;\n\n        if (connector.switchChain) chain = await connector.switchChain(chainId);else throw new ChainMismatchError({\n          activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(x => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n          targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(x => x.id === chainId)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n        });\n      }\n    }\n\n    const signer = await connector.getSigner({\n      chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n    });\n    const contract = getContract({\n      addressOrName,\n      contractInterface,\n      signerOrProvider\n    });\n    const contractWithSigner = contract.connect(signer);\n    const contractFunction = contractWithSigner[functionName];\n    if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" does not exist in interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n    return await contractFunction(...params);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function fetchToken(_ref) {\n  let {\n    address,\n    chainId,\n    formatUnits: units = 'ether'\n  } = _ref;\n  const erc20Config = {\n    addressOrName: address,\n    contractInterface: erc20ABI,\n    chainId\n  };\n  const [decimals, name, symbol, totalSupply] = await readContracts({\n    allowFailure: false,\n    contracts: [{ ...erc20Config,\n      functionName: 'decimals'\n    }, { ...erc20Config,\n      functionName: 'name'\n    }, { ...erc20Config,\n      functionName: 'symbol'\n    }, { ...erc20Config,\n      functionName: 'totalSupply'\n    }]\n  });\n  return {\n    address,\n    decimals,\n    name,\n    symbol,\n    totalSupply: {\n      formatted: formatUnits(totalSupply, units),\n      value: totalSupply\n    }\n  };\n}\n/**\n * @description Prepares the parameters required for a contract write transaction.\n *\n * Returns config to be passed through to `writeContract`.\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *  addressOrName: '0x...',\n *  contractInterface: wagmiAbi,\n *  functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\n\n\nasync function prepareWriteContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface: contractInterface_,\n    functionName,\n    overrides,\n    signer: signer_\n  } = _ref;\n  const signer = signer_ !== null && signer_ !== void 0 ? signer_ : await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const contract = getContract({\n    addressOrName,\n    contractInterface: contractInterface_,\n    signerOrProvider: signer\n  });\n  const populateTransactionFn = contract.populateTransaction[functionName];\n\n  if (!populateTransactionFn) {\n    throw new ContractMethodDoesNotExistError({\n      addressOrName,\n      functionName\n    });\n  }\n\n  const contractInterface = minimizeContractInterface({\n    contractInterface: contract.interface,\n    functionName\n  });\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n  const unsignedTransaction = await populateTransactionFn(...params);\n  const gasLimit = unsignedTransaction.gasLimit || (await signer.estimateGas(unsignedTransaction));\n  return {\n    addressOrName,\n    args,\n    ...(chainId ? {\n      chainId\n    } : {}),\n    contractInterface,\n    functionName,\n    overrides,\n    request: { ...unsignedTransaction,\n      gasLimit\n    },\n    mode: 'prepared'\n  };\n}\n\nfunction getWebSocketProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client = getClient();\n  if (chainId) return client.getWebSocketProvider({\n    chainId\n  }) || client.webSocketProvider;\n  return client.webSocketProvider;\n}\n\nfunction watchProvider(args, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(getProvider(args));\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nfunction watchWebSocketProvider(args, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(getWebSocketProvider(args));\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      webSocketProvider\n    } = _ref;\n    return webSocketProvider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nasync function readContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    overrides\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const contract = getContract({\n    addressOrName,\n    contractInterface,\n    signerOrProvider: provider\n  });\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n  const contractFunction = contract[functionName];\n  if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n  const response = await (contractFunction === null || contractFunction === void 0 ? void 0 : contractFunction(...params));\n  return response;\n}\n\nasync function multicall(_ref) {\n  let {\n    allowFailure = true,\n    chainId,\n    contracts,\n    overrides\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  if (!provider.chains) throw new ProviderChainsNotFound();\n  const chain = provider.chains.find(chain => chain.id === chainId) || provider.chains[0];\n  if (!chain) throw new ProviderChainsNotFound();\n  if (!(chain !== null && chain !== void 0 && chain.multicall)) throw new ChainDoesNotSupportMulticallError({\n    chain\n  });\n  if (typeof (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) === 'number' && (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) < chain.multicall.blockCreated) throw new ChainDoesNotSupportMulticallError({\n    blockNumber: overrides === null || overrides === void 0 ? void 0 : overrides.blockTag,\n    chain\n  });\n  const multicallContract = getContract({\n    addressOrName: chain.multicall.address,\n    contractInterface: multicallInterface,\n    signerOrProvider: provider\n  });\n  const calls = contracts.map(_ref2 => {\n    let {\n      addressOrName,\n      contractInterface,\n      functionName,\n      ...config\n    } = _ref2;\n    const {\n      args\n    } = config || {};\n    const contract = getContract({\n      addressOrName,\n      contractInterface\n    });\n    const params = Array.isArray(args) ? args : args ? [args] : [];\n\n    try {\n      const callData = contract.interface.encodeFunctionData(functionName, params);\n      if (!contract[functionName]) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n      return {\n        target: addressOrName,\n        allowFailure,\n        callData\n      };\n    } catch (err) {\n      if (!allowFailure) throw err;\n      return {\n        target: addressOrName,\n        allowFailure,\n        callData: '0x'\n      };\n    }\n  });\n  const params = [...[calls], ...(overrides ? [overrides] : [])];\n  const results = await multicallContract.aggregate3(...params);\n  return results.map((_ref3, i) => {\n    let {\n      returnData,\n      success\n    } = _ref3;\n    const {\n      addressOrName,\n      contractInterface,\n      functionName,\n      args\n    } = contracts[i];\n    const contract = getContract({\n      addressOrName,\n      contractInterface\n    });\n\n    if (!success) {\n      let error;\n\n      try {\n        contract.interface.decodeFunctionResult(functionName, returnData);\n      } catch (err) {\n        error = new ContractMethodRevertedError({\n          addressOrName,\n          args,\n          chainId: chain.id,\n          functionName,\n          errorMessage: err.message\n        });\n        if (!allowFailure) throw error;\n        logWarn(error.message);\n      }\n\n      return null;\n    }\n\n    if (returnData === '0x') {\n      const error = new ContractMethodNoResultError({\n        addressOrName,\n        args,\n        chainId: chain.id,\n        functionName\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n\n    try {\n      const result = contract.interface.decodeFunctionResult(functionName, returnData);\n      return Array.isArray(result) && result.length === 1 ? result[0] : result;\n    } catch (err) {\n      const error = new ContractResultDecodeError({\n        addressOrName,\n        args,\n        chainId: chain.id,\n        functionName,\n        errorMessage: err.message\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n  });\n}\n\nasync function readContracts(_ref) {\n  let {\n    allowFailure = true,\n    contracts,\n    overrides\n  } = _ref;\n\n  try {\n    const provider = getProvider();\n    const contractsByChainId = contracts.reduce((contracts, contract) => {\n      var _contract$chainId;\n\n      const chainId = (_contract$chainId = contract.chainId) !== null && _contract$chainId !== void 0 ? _contract$chainId : provider.network.chainId;\n      return { ...contracts,\n        [chainId]: [...(contracts[chainId] || []), contract]\n      };\n    }, {});\n\n    const promises = () => Object.entries(contractsByChainId).map(_ref2 => {\n      let [chainId, contracts] = _ref2;\n      return multicall({\n        allowFailure,\n        chainId: parseInt(chainId),\n        contracts,\n        overrides\n      });\n    });\n\n    if (allowFailure) {\n      return (await Promise.allSettled(promises())).map(result => {\n        if (result.status === 'fulfilled') return result.value;\n\n        if (result.reason instanceof ChainDoesNotSupportMulticallError) {\n          logWarn(result.reason.message);\n          throw result.reason;\n        }\n\n        return null;\n      }).flat();\n    }\n\n    return (await Promise.all(promises())).flat();\n  } catch (err) {\n    if (err instanceof ContractResultDecodeError) throw err;\n    if (err instanceof ContractMethodNoResultError) throw err;\n    if (err instanceof ContractMethodRevertedError) throw err;\n\n    const promises = () => contracts.map(contract => readContract({ ...contract,\n      overrides\n    }));\n\n    if (allowFailure) {\n      return (await Promise.allSettled(promises())).map((result, i) => {\n        if (result.status === 'fulfilled') return result.value;\n        const {\n          addressOrName,\n          functionName,\n          chainId,\n          args\n        } = contracts[i];\n        const error = new ContractMethodRevertedError({\n          addressOrName,\n          functionName,\n          chainId: chainId !== null && chainId !== void 0 ? chainId : mainnet.id,\n          args,\n          errorMessage: result.reason\n        });\n        logWarn(error.message);\n        return null;\n      });\n    }\n\n    return await Promise.all(promises());\n  }\n}\n\nfunction watchContractEvent(\n/** Contract configuration */\ncontractArgs,\n/** Event name to listen to */\neventName, callback) {\n  let {\n    chainId,\n    once\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let contract;\n\n  const watchEvent = async () => {\n    if (contract) {\n      var _contract;\n\n      (_contract = contract) === null || _contract === void 0 ? void 0 : _contract.off(eventName, callback);\n    }\n\n    contract = getContract({\n      signerOrProvider: getWebSocketProvider({\n        chainId\n      }) || getProvider({\n        chainId\n      }),\n      ...contractArgs\n    });\n    if (once) contract.once(eventName, callback);else contract.on(eventName, callback);\n  };\n\n  watchEvent();\n  const client = getClient();\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, watchEvent, {\n    equalityFn: shallow\n  });\n  return () => {\n    var _contract2;\n\n    (_contract2 = contract) === null || _contract2 === void 0 ? void 0 : _contract2.off(eventName, callback);\n    unsubscribe();\n  };\n}\n\nasync function fetchBlockNumber() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const blockNumber = await provider.getBlockNumber();\n  return blockNumber;\n}\n\nfunction watchBlockNumber(args, callback) {\n  var _client$webSocketProv;\n\n  let previousProvider;\n\n  const createListener = provider => {\n    // We need to debounce the listener as we want to opt-out\n    // of the behavior where ethers emits a \"block\" event for\n    // every block that was missed in between the `pollingInterval`.\n    // We are setting a wait time of 1 as emitting an event in\n    // ethers takes ~0.1ms.\n    const debouncedCallback = debounce(callback, 1);\n\n    if (previousProvider) {\n      var _previousProvider;\n\n      (_previousProvider = previousProvider) === null || _previousProvider === void 0 ? void 0 : _previousProvider.off('block', debouncedCallback);\n    }\n\n    provider.on('block', debouncedCallback);\n    previousProvider = provider;\n  };\n\n  const client = getClient();\n  const provider_ = (_client$webSocketProv = client.webSocketProvider) !== null && _client$webSocketProv !== void 0 ? _client$webSocketProv : client.provider;\n  if (args.listen) createListener(provider_);\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, async _ref2 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref2;\n    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n\n    if (args.listen && provider_) {\n      createListener(provider_);\n    }\n\n    callback(await fetchBlockNumber());\n  }, {\n    equalityFn: shallow\n  });\n  return () => {\n    unsubscribe();\n    provider_ === null || provider_ === void 0 ? void 0 : provider_.off('block', callback);\n  };\n}\n\nfunction watchReadContract(config, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await readContract(config));\n\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nfunction watchReadContracts(config, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await readContracts(config));\n\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nasync function deprecatedSendTransaction(_ref) {\n  let {\n    chainId,\n    request\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n\n  try {\n    var _chain;\n\n    let chain;\n\n    if (chainId) {\n      const activeChainId = await connector.getChainId(); // Try to switch chain to provided `chainId`\n\n      if (chainId !== activeChainId) {\n        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;\n\n        if (connector.switchChain) chain = await connector.switchChain(chainId);else throw new ChainMismatchError({\n          activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(x => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n          targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(x => x.id === chainId)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n        });\n      }\n    }\n\n    const signer = await connector.getSigner({\n      chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n    });\n    return await signer.sendTransaction(request);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n/**\n * @description Fetches transaction for hash\n *\n * @example\n * import { fetchTransaction } from '@wagmi/core'\n *\n * const transaction = await fetchTransaction({\n *  chainId: 1,\n *  hash: '0x...',\n * })\n */\n\n\nasync function fetchTransaction(_ref) {\n  let {\n    chainId,\n    hash\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  return await provider.getTransaction(hash);\n}\n\nasync function fetchEnsAddress(_ref) {\n  let {\n    chainId,\n    name\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const address = await provider.resolveName(name);\n\n  try {\n    return address ? getAddress(address) : null;\n  } catch (_error) {\n    return null;\n  }\n}\n\nasync function fetchEnsAvatar(_ref) {\n  let {\n    addressOrName,\n    chainId\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  }); // TODO: Update with more advanced logic\n  // https://github.com/ensdomains/ens-avatar\n\n  const avatar = await provider.getAvatar(addressOrName);\n  return avatar;\n}\n\nasync function fetchEnsName(_ref) {\n  let {\n    address,\n    chainId\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  return await provider.lookupAddress(address);\n}\n\nasync function fetchEnsResolver(_ref) {\n  let {\n    chainId,\n    name\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const resolver = await provider.getResolver(name);\n  return resolver;\n}\n/**\n * @description Prepares the parameters required for sending a transaction.\n *\n * Returns config to be passed through to `sendTransaction`.\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  request: {\n *    to: 'moxey.eth',\n *    value: parseEther('1'),\n *  }\n * })\n * const result = await sendTransaction(config)\n */\n\n\nasync function prepareSendTransaction(_ref) {\n  let {\n    chainId,\n    request,\n    signerOrProvider = getProvider({\n      chainId\n    })\n  } = _ref;\n  const [to, gasLimit] = await Promise.all([isAddress(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({\n    name: request.to\n  }), request.gasLimit ? Promise.resolve(request.gasLimit) : signerOrProvider.estimateGas(request)]);\n  if (!to) throw new Error('Could not resolve ENS name');\n  return { ...(chainId ? {\n      chainId\n    } : {}),\n    request: { ...request,\n      gasLimit,\n      to\n    },\n    mode: 'prepared'\n  };\n}\n/**\n * @description Function to send a transaction.\n *\n * It is recommended to pair this with the `prepareSendTransaction` function to avoid\n * [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  to: 'moxey.eth',\n *  value: parseEther('1'),\n * })\n * const result = await sendTransaction(config)\n */\n\n\nasync function sendTransaction(_ref) {\n  let {\n    chainId,\n    mode,\n    request\n  } = _ref;\n  /********************************************************************/\n\n  /** START: iOS App Link cautious code.                              */\n\n  /** Do not perform any async operations in this block.              */\n\n  /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n  /********************************************************************/\n  // `fetchSigner` isn't really \"asynchronous\" as we have already\n  // initialized the provider upon user connection, so it will return\n  // immediately.\n\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n\n  if (mode === 'prepared') {\n    if (!request.gasLimit) throw new Error('`gasLimit` is required');\n    if (!request.to) throw new Error('`to` is required');\n  }\n\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n  if (chainId && chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id)) {\n    var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n    throw new ChainMismatchError({\n      activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n      targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n    });\n  }\n\n  try {\n    var _connectUnchecked, _ref2; // Why don't we just use `signer.sendTransaction`?\n    // The `signer.sendTransaction` method performs async\n    // heavy operations (such as fetching block number)\n    // which is not really needed for our case.\n    // Having async heavy operations has side effects\n    // when using it in a click handler (iOS deep linking issues,\n    // delay to open wallet, etc).\n\n\n    const uncheckedSigner = (_connectUnchecked = (_ref2 = signer).connectUnchecked) === null || _connectUnchecked === void 0 ? void 0 : _connectUnchecked.call(_ref2);\n    const {\n      hash,\n      wait\n    } = await (uncheckedSigner !== null && uncheckedSigner !== void 0 ? uncheckedSigner : signer).sendTransaction(request);\n    /********************************************************************/\n\n    /** END: iOS App Link cautious code.                                */\n\n    /** Go nuts!                                                        */\n\n    /********************************************************************/\n\n    return {\n      hash,\n      wait\n    };\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function waitForTransaction(_ref) {\n  let {\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait: wait_\n  } = _ref;\n  let promise;\n\n  if (hash) {\n    const provider = getProvider({\n      chainId\n    });\n    promise = provider.waitForTransaction(hash, confirmations, timeout);\n  } else if (wait_) promise = wait_(confirmations);else throw new Error('hash or wait is required');\n\n  return await promise;\n}\n/**\n * @description Function to call a contract write method.\n *\n * It is recommended to pair this with the {@link prepareWriteContract} function\n * to avoid [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *   addressOrName: '0x...',\n *   contractInterface: wagmiAbi,\n *   functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\n\n\nasync function writeContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    mode,\n    overrides,\n    request: request_\n  } = _ref;\n  /********************************************************************/\n\n  /** START: iOS App Link cautious code.                              */\n\n  /** Do not perform any async operations in this block.              */\n\n  /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n  /********************************************************************/\n\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n  if (chainId && chainId !== activeChainId) {\n    var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n    throw new ChainMismatchError({\n      activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n      targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n    });\n  }\n\n  if (mode === 'prepared') {\n    if (!request_) throw new Error('`request` is required');\n  }\n\n  const request = mode === 'recklesslyUnprepared' ? (await prepareWriteContract({\n    addressOrName,\n    args,\n    contractInterface,\n    functionName,\n    overrides\n  })).request : request_;\n  const transaction = await sendTransaction({\n    request,\n    mode: 'prepared'\n  });\n  /********************************************************************/\n\n  /** END: iOS App Link cautious code.                                */\n\n  /** Go nuts!                                                        */\n\n  /********************************************************************/\n\n  return transaction;\n}\n\nasync function fetchBalance(_ref) {\n  var _client$chains, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4;\n\n  let {\n    addressOrName,\n    chainId,\n    formatUnits: unit,\n    token\n  } = _ref;\n  const client = getClient();\n  const provider = getProvider({\n    chainId\n  });\n\n  if (token) {\n    const erc20Config = {\n      addressOrName: token,\n      contractInterface: erc20ABI,\n      chainId\n    }; // Convert ENS name to address if required\n\n    let resolvedAddress;\n    if (isAddress(addressOrName)) resolvedAddress = addressOrName;else {\n      const address = await provider.resolveName(addressOrName); // Same error `provider.getBalance` throws for invalid ENS name\n\n      if (!address) logger.throwError('ENS name not configured', Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"resolveName(\".concat(JSON.stringify(addressOrName), \")\")\n      });\n      resolvedAddress = address;\n    }\n    const [value, decimals, symbol] = await readContracts({\n      allowFailure: false,\n      contracts: [{ ...erc20Config,\n        functionName: 'balanceOf',\n        args: resolvedAddress\n      }, { ...erc20Config,\n        functionName: 'decimals'\n      }, { ...erc20Config,\n        functionName: 'symbol'\n      }]\n    });\n    return {\n      decimals,\n      formatted: formatUnits(value !== null && value !== void 0 ? value : '0', unit !== null && unit !== void 0 ? unit : decimals),\n      symbol,\n      value\n    };\n  }\n\n  const chains = [...(client.provider.chains || []), ...((_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [])];\n  const value = await provider.getBalance(addressOrName);\n  const chain = chains.find(x => x.id === provider.network.chainId);\n  return {\n    decimals: (_chain$nativeCurrency = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency2 = chain.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,\n    formatted: formatUnits(value !== null && value !== void 0 ? value : '0', unit !== null && unit !== void 0 ? unit : 'ether'),\n    symbol: (_chain$nativeCurrency3 = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency4 = chain.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : 'ETH',\n    value\n  };\n}\n\nasync function fetchSigner() {\n  var _client$connector, _client$connector$get;\n\n  const client = getClient();\n  const signer = (await ((_client$connector = client.connector) === null || _client$connector === void 0 ? void 0 : (_client$connector$get = _client$connector.getSigner) === null || _client$connector$get === void 0 ? void 0 : _client$connector$get.call(_client$connector))) || null;\n  return signer;\n}\n\nfunction getAccount() {\n  const {\n    data,\n    connector,\n    status\n  } = getClient();\n\n  switch (status) {\n    case 'connected':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector: connector,\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n\n    case 'reconnecting':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector,\n        isConnected: !!(data !== null && data !== void 0 && data.account),\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: true,\n        status\n      };\n\n    case 'connecting':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: true,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n\n    case 'disconnected':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n        status\n      };\n  }\n}\n\nfunction getNetwork() {\n  var _client$data, _client$data$chain, _client$chains, _find, _client$data2;\n\n  const client = getClient();\n  const chainId = (_client$data = client.data) === null || _client$data === void 0 ? void 0 : (_client$data$chain = _client$data.chain) === null || _client$data$chain === void 0 ? void 0 : _client$data$chain.id;\n  const activeChains = (_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [];\n  const activeChain = (_find = [...(client.provider.chains || []), ...activeChains].find(x => x.id === chainId)) !== null && _find !== void 0 ? _find : {\n    id: chainId,\n    name: \"Chain \".concat(chainId),\n    network: \"\".concat(chainId),\n    rpcUrls: {\n      default: ''\n    }\n  };\n  return {\n    chain: chainId ? { ...activeChain,\n      ...((_client$data2 = client.data) === null || _client$data2 === void 0 ? void 0 : _client$data2.chain),\n      id: chainId\n    } : undefined,\n    chains: activeChains\n  };\n}\n\nasync function signMessage(args) {\n  try {\n    const signer = await fetchSigner();\n    if (!signer) throw new ConnectorNotFoundError();\n    return await signer.signMessage(args.message);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function signTypedData(_ref) {\n  let {\n    domain,\n    types,\n    value\n  } = _ref;\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const {\n    chainId: chainId_\n  } = domain;\n\n  if (chainId_) {\n    const chainId = normalizeChainId(chainId_);\n    const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n    if (chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id)) {\n      var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n      throw new ChainMismatchError({\n        activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n        targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n      });\n    }\n  } // Method name may be changed in the future, see https://docs.ethers.io/v5/api/signer/#Signer-signTypedData\n\n\n  return await signer._signTypedData(domain, types, value);\n}\n\nasync function switchNetwork(_ref) {\n  let {\n    chainId\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n  if (!connector.switchChain) throw new SwitchChainNotSupportedError({\n    connector\n  });\n  return await connector.switchChain(chainId);\n}\n\nfunction watchAccount(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = getClient();\n\n  const handleChange = () => callback(getAccount());\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      data,\n      connector,\n      status\n    } = _ref;\n    return selector({\n      address: data === null || data === void 0 ? void 0 : data.account,\n      connector,\n      status\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchNetwork(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = getClient();\n\n  const handleChange = () => callback(getNetwork());\n\n  const unsubscribe = client.subscribe(_ref => {\n    var _data$chain;\n\n    let {\n      data,\n      chains\n    } = _ref;\n    return selector({\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      chains\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchSigner(callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await fetchSigner());\n\n  const unsubscribe = client.subscribe(_ref => {\n    var _data$chain;\n\n    let {\n      data,\n      connector\n    } = _ref;\n    return {\n      account: data === null || data === void 0 ? void 0 : data.account,\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      connector\n    };\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nasync function fetchFeeData() {\n  let {\n    chainId,\n    formatUnits: units = 'wei'\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const feeData = await provider.getFeeData();\n  const formatted = {\n    gasPrice: feeData.gasPrice ? formatUnits(feeData.gasPrice, units) : null,\n    maxFeePerGas: feeData.maxFeePerGas ? formatUnits(feeData.maxFeePerGas, units) : null,\n    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? formatUnits(feeData.maxPriorityFeePerGas, units) : null\n  };\n  return { ...feeData,\n    formatted\n  };\n}\n\nexport { configureChains, connect, deepEqual, deprecatedSendTransaction, deprecatedWriteContract, disconnect, erc20ABI, erc721ABI, fetchBalance, fetchBlockNumber, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, fetchFeeData, fetchSigner, fetchToken, fetchTransaction, getAccount, getContract, getNetwork, getWebSocketProvider, minimizeContractInterface, parseContractResult, prepareSendTransaction, prepareWriteContract, readContract, readContracts, sendTransaction, signMessage, signTypedData, switchNetwork, units, waitForTransaction, watchAccount, watchBlockNumber, watchContractEvent, watchNetwork, watchProvider, watchReadContract, watchReadContracts, watchSigner, watchWebSocketProvider, writeContract };","map":{"version":3,"names":["g","getClient","C","ConnectorAlreadyConnectedError","a","ConnectorNotFoundError","b","ChainMismatchError","U","UserRejectedRequestError","c","ContractMethodDoesNotExistError","d","getProvider","P","ProviderChainsNotFound","e","ChainDoesNotSupportMulticallError","f","ContractMethodRevertedError","h","ContractMethodNoResultError","i","ContractResultDecodeError","n","normalizeChainId","S","SwitchChainNotSupportedError","A","AddChainError","m","ChainNotConfiguredError","k","Client","l","Connector","I","InjectedConnector","o","ProviderRpcError","R","ResourceUnavailableError","p","RpcError","q","SwitchChainError","j","createClient","r","createStorage","s","noopStorage","providers","Contract","Contract$1","logger","FormatTypes","formatUnits","getAddress","isAddress","Logger","mainnet","allChains","chain","chainId","defaultChains","defaultL2Chains","etherscanBlockExplorers","shallow","debounce","alchemyRpcUrls","infuraRpcUrls","publicRpcUrls","configureChains","minQuorum","pollingInterval","targetQuorum","stallTimeout","arguments","length","undefined","Error","chains","providers_","webSocketProviders_","configExists","provider","apiConfig","some","_ref","id","webSocketProvider","concat","name","join","_ref2","_defaultChains$","activeChainId","x","chainProviders","Object","assign","fallbackProvider","_ref3","_defaultChains$2","_chainWebSocketProvid","chainWebSocketProviders","call","_ref4","FallbackProvider","map","chainProvider","index","_provider$priority","_provider$stallTimeou","priority","weight","error","_error$message","message","includes","deepEqual","constructor","Array","isArray","valueOf","prototype","toString","keys","hasOwnProperty","key","logWarn","_getClient","_getClient$config$log","_getClient$config$log2","config","warn","minimizeContractInterface","contractInterface","functionName","abi","getInterface","format","full","minimizedInterface","filter","isPlainArray","value","parseContractResult","data","_fragment$outputs","iface","fragment","getFunction","isTuple","outputs","data_","encodedResult","encodeFunctionResult","decodedResult","decodeFunctionResult","erc20ABI","erc721ABI","multicallInterface","inputs","components","internalType","type","stateMutability","units","connect","connector","client","activeConnector","setState","status","setLastUsedConnector","storage","setItem","err","disconnect","clearState","removeItem","getContract","addressOrName","signerOrProvider","deprecatedWriteContract","args","overrides","params","_chain","getChainId","_connector$chains$fin","_connector$chains$fin2","_connector$chains$fin3","_connector$chains$fin4","switchChain","activeChain","find","targetChain","signer","getSigner","contract","contractWithSigner","contractFunction","code","fetchToken","address","erc20Config","decimals","symbol","totalSupply","readContracts","allowFailure","contracts","formatted","prepareWriteContract","contractInterface_","signer_","fetchSigner","populateTransactionFn","populateTransaction","interface","unsignedTransaction","gasLimit","estimateGas","request","mode","getWebSocketProvider","watchProvider","callback","handleChange","unsubscribe","subscribe","watchWebSocketProvider","readContract","response","multicall","blockTag","blockCreated","blockNumber","multicallContract","calls","callData","encodeFunctionData","target","results","aggregate3","returnData","success","errorMessage","result","contractsByChainId","reduce","_contract$chainId","network","promises","entries","parseInt","Promise","allSettled","reason","flat","all","watchContractEvent","contractArgs","eventName","once","watchEvent","_contract","off","on","equalityFn","_contract2","fetchBlockNumber","getBlockNumber","watchBlockNumber","_client$webSocketProv","previousProvider","createListener","debouncedCallback","_previousProvider","provider_","listen","watchReadContract","unwatch","listenToBlock","watchReadContracts","deprecatedSendTransaction","sendTransaction","fetchTransaction","hash","getTransaction","fetchEnsAddress","resolveName","_error","fetchEnsAvatar","avatar","getAvatar","fetchEnsName","lookupAddress","fetchEnsResolver","resolver","getResolver","prepareSendTransaction","to","resolve","getNetwork","_chains$find$name","_chains$find","_chains$find$name2","_chains$find2","_connectUnchecked","uncheckedSigner","connectUnchecked","wait","waitForTransaction","confirmations","timeout","wait_","promise","writeContract","request_","transaction","fetchBalance","_client$chains","_chain$nativeCurrency","_chain$nativeCurrency2","_chain$nativeCurrency3","_chain$nativeCurrency4","unit","token","resolvedAddress","throwError","errors","UNSUPPORTED_OPERATION","operation","JSON","stringify","getBalance","nativeCurrency","_client$connector","_client$connector$get","getAccount","account","isConnected","isConnecting","isDisconnected","isReconnecting","_client$data","_client$data$chain","_find","_client$data2","activeChains","rpcUrls","default","signMessage","signTypedData","domain","types","chainId_","_signTypedData","switchNetwork","watchAccount","selector","watchNetwork","_data$chain","watchSigner","fetchFeeData","feeData","getFeeData","gasPrice","maxFeePerGas","maxPriorityFeePerGas"],"sources":["C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@wagmi/core/dist/wagmi-core.esm.js"],"sourcesContent":["import { g as getClient, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, b as ChainMismatchError, U as UserRejectedRequestError, c as ContractMethodDoesNotExistError, d as getProvider, P as ProviderChainsNotFound, e as ChainDoesNotSupportMulticallError, f as ContractMethodRevertedError, h as ContractMethodNoResultError, i as ContractResultDecodeError, n as normalizeChainId, S as SwitchChainNotSupportedError } from './getProvider-f1dfc7e3.esm.js';\nexport { A as AddChainError, e as ChainDoesNotSupportMulticallError, b as ChainMismatchError, m as ChainNotConfiguredError, k as Client, l as Connector, C as ConnectorAlreadyConnectedError, a as ConnectorNotFoundError, c as ContractMethodDoesNotExistError, h as ContractMethodNoResultError, f as ContractMethodRevertedError, i as ContractResultDecodeError, I as InjectedConnector, P as ProviderChainsNotFound, o as ProviderRpcError, R as ResourceUnavailableError, p as RpcError, q as SwitchChainError, S as SwitchChainNotSupportedError, U as UserRejectedRequestError, j as createClient, r as createStorage, d as getProvider, s as noopStorage, n as normalizeChainId } from './getProvider-f1dfc7e3.esm.js';\nimport { providers, Contract as Contract$1 } from 'ethers';\nimport { Contract, logger } from 'ethers/lib/ethers';\nimport { FormatTypes, formatUnits, getAddress, isAddress, Logger } from 'ethers/lib/utils';\nimport { m as mainnet } from './chains-8c76af1b.esm.js';\nexport { a as allChains, c as chain, b as chainId, d as defaultChains, e as defaultL2Chains, f as etherscanBlockExplorers } from './chains-8c76af1b.esm.js';\nimport shallow from 'zustand/shallow';\nimport { d as debounce } from './debounce-0862bf88.esm.js';\nexport { a as alchemyRpcUrls, i as infuraRpcUrls, p as publicRpcUrls } from './rpcs-8d636858.esm.js';\nimport 'zustand/middleware';\nimport 'zustand/vanilla';\nimport 'eventemitter3';\n\nfunction configureChains(defaultChains, providers) {\n  let {\n    minQuorum = 1,\n    pollingInterval = 4000,\n    targetQuorum = 1,\n    stallTimeout\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!defaultChains.length) throw new Error('must have at least one chain');\n  if (targetQuorum < minQuorum) throw new Error('quorum cannot be lower than minQuorum');\n  let chains = [];\n  const providers_ = {};\n  const webSocketProviders_ = {};\n\n  for (const chain of defaultChains) {\n    let configExists = false;\n\n    for (const provider of providers) {\n      const apiConfig = provider(chain); // If no API configuration was found (ie. no RPC URL) for\n      // this provider, then we skip and check the next one.\n\n      if (!apiConfig) continue;\n      configExists = true;\n\n      if (!chains.some(_ref => {\n        let {\n          id\n        } = _ref;\n        return id === chain.id;\n      })) {\n        chains = [...chains, apiConfig.chain];\n      }\n\n      providers_[chain.id] = [...(providers_[chain.id] || []), apiConfig.provider];\n\n      if (apiConfig.webSocketProvider) {\n        webSocketProviders_[chain.id] = [...(webSocketProviders_[chain.id] || []), apiConfig.webSocketProvider];\n      }\n    } // If no API configuration was found across the providers\n    // then we throw an error to the consumer.\n\n\n    if (!configExists) {\n      throw new Error([\"Could not find valid provider configuration for chain \\\"\".concat(chain.name, \"\\\".\\n\"), \"You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.\", 'Read more: https://wagmi.sh/docs/providers/jsonRpc'].join('\\n'));\n    }\n  }\n\n  return {\n    chains,\n    provider: _ref2 => {\n      var _defaultChains$;\n\n      let {\n        chainId\n      } = _ref2;\n      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$ = defaultChains[0]) === null || _defaultChains$ === void 0 ? void 0 : _defaultChains$.id;\n      const chainProviders = providers_[activeChainId];\n      if (!chainProviders || !chainProviders[0]) throw new Error(\"No providers configured for chain \\\"\".concat(activeChainId, \"\\\"\"));\n\n      if (chainProviders.length === 1) {\n        return Object.assign(chainProviders[0](), {\n          chains,\n          pollingInterval\n        });\n      }\n\n      return Object.assign(fallbackProvider(targetQuorum, minQuorum, chainProviders, {\n        stallTimeout\n      }), {\n        chains,\n        pollingInterval\n      });\n    },\n    webSocketProvider: _ref3 => {\n      var _defaultChains$2, _chainWebSocketProvid;\n\n      let {\n        chainId\n      } = _ref3;\n      const activeChainId = chainId && chains.some(x => x.id === chainId) ? chainId : (_defaultChains$2 = defaultChains[0]) === null || _defaultChains$2 === void 0 ? void 0 : _defaultChains$2.id;\n      const chainWebSocketProviders = webSocketProviders_[activeChainId];\n      if (!chainWebSocketProviders) return undefined; // WebSockets do not work with `fallbackProvider`\n      // Default to first available\n\n      return Object.assign(((_chainWebSocketProvid = chainWebSocketProviders[0]) === null || _chainWebSocketProvid === void 0 ? void 0 : _chainWebSocketProvid.call(chainWebSocketProviders)) || {}, {\n        chains\n      });\n    }\n  };\n}\n\nfunction fallbackProvider(targetQuorum, minQuorum, providers_, _ref4) {\n  let {\n    stallTimeout\n  } = _ref4;\n\n  try {\n    return new providers.FallbackProvider(providers_.map((chainProvider, index) => {\n      var _provider$priority, _provider$stallTimeou;\n\n      const provider = chainProvider();\n      return {\n        provider,\n        priority: (_provider$priority = provider.priority) !== null && _provider$priority !== void 0 ? _provider$priority : index,\n        stallTimeout: (_provider$stallTimeou = provider.stallTimeout) !== null && _provider$stallTimeou !== void 0 ? _provider$stallTimeou : stallTimeout,\n        weight: provider.weight\n      };\n    }), targetQuorum);\n  } catch (error) {\n    var _error$message;\n\n    if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('quorum will always fail; larger than total weight')) {\n      if (targetQuorum === minQuorum) throw error;\n      return fallbackProvider(targetQuorum - 1, minQuorum, providers_, {\n        stallTimeout\n      });\n    }\n\n    throw error;\n  }\n}\n\n/** Forked from https://github.com/epoberezkin/fast-deep-equal */\nfunction deepEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    if (a.constructor !== b.constructor) return false;\n    let length;\n    let i;\n\n    if (Array.isArray(a) && Array.isArray(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n\n      for (i = length; i-- !== 0;) if (!deepEqual(a[i], b[i])) return false;\n\n      return true;\n    }\n\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key && !deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise\n\n\n  return a !== a && b !== b;\n}\n\nfunction logWarn(message) {\n  var _getClient, _getClient$config$log, _getClient$config$log2;\n\n  (_getClient = getClient()) === null || _getClient === void 0 ? void 0 : (_getClient$config$log = _getClient.config.logger) === null || _getClient$config$log === void 0 ? void 0 : (_getClient$config$log2 = _getClient$config$log.warn) === null || _getClient$config$log2 === void 0 ? void 0 : _getClient$config$log2.call(_getClient$config$log, message);\n}\n\nfunction minimizeContractInterface(_ref) {\n  let {\n    contractInterface,\n    functionName\n  } = _ref;\n  const abi = Contract.getInterface(contractInterface).format(FormatTypes.full);\n  const minimizedInterface = Array.isArray(abi) ? abi : [abi];\n  return minimizedInterface.filter(i => i.includes(functionName));\n}\n\nfunction isPlainArray(value) {\n  return Array.isArray(value) && Object.keys(value).length === value.length;\n}\n\nfunction parseContractResult(_ref) {\n  let {\n    contractInterface,\n    data,\n    functionName\n  } = _ref;\n\n  if (data && isPlainArray(data)) {\n    var _fragment$outputs;\n\n    const iface = Contract.getInterface(contractInterface);\n    const fragment = iface.getFunction(functionName);\n    const isTuple = (((_fragment$outputs = fragment.outputs) === null || _fragment$outputs === void 0 ? void 0 : _fragment$outputs.length) || 0) > 1;\n    const data_ = isTuple ? data : [data];\n    const encodedResult = iface.encodeFunctionResult(functionName, data_);\n    const decodedResult = iface.decodeFunctionResult(functionName, encodedResult);\n    return isTuple ? decodedResult : decodedResult[0];\n  }\n\n  return data;\n}\n\n// https://ethereum.org/en/developers/docs/standards/tokens/erc-20\nconst erc20ABI = ['event Approval(address indexed _owner, address indexed _spender, uint256 _value)', 'event Transfer(address indexed _from, address indexed _to, uint256 _value)', 'function allowance(address _owner, address _spender) public view returns (uint256 remaining)', 'function approve(address _spender, uint256 _value) public returns (bool success)', 'function balanceOf(address _owner) public view returns (uint256 balance)', 'function decimals() public view returns (uint8)', 'function name() public view returns (string)', 'function symbol() public view returns (string)', 'function totalSupply() public view returns (uint256)', 'function transfer(address _to, uint256 _value) public returns (bool success)', 'function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)']; // https://ethereum.org/en/developers/docs/standards/tokens/erc-721\n\nconst erc721ABI = ['event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId)', 'event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved)', 'event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)', 'function approve(address _approved, uint256 _tokenId) external payable', 'function balanceOf(address _owner) external view returns (uint256)', 'function getApproved(uint256 _tokenId) external view returns (address)', 'function isApprovedForAll(address _owner, address _operator) external view returns (bool)', 'function name() view returns (string memory)', 'function ownerOf(uint256 _tokenId) external view returns (address)', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable', 'function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable', 'function setApprovalForAll(address _operator, bool _approved) external', 'function symbol() view returns (string memory)', 'function tokenByIndex(uint256 _index) view returns (uint256)', 'function tokenOfOwnerByIndex(address _owner, uint256 _index) view returns (uint256 tokenId)', 'function tokenURI(uint256 _tokenId) view returns (string memory)', 'function totalSupply() view returns (uint256)', 'function transferFrom(address _from, address _to, uint256 _tokenId) external payable'];\n\nconst multicallInterface = [{\n  inputs: [{\n    components: [{\n      internalType: 'address',\n      name: 'target',\n      type: 'address'\n    }, {\n      internalType: 'bool',\n      name: 'allowFailure',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'callData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Call3[]',\n    name: 'calls',\n    type: 'tuple[]'\n  }],\n  name: 'aggregate3',\n  outputs: [{\n    components: [{\n      internalType: 'bool',\n      name: 'success',\n      type: 'bool'\n    }, {\n      internalType: 'bytes',\n      name: 'returnData',\n      type: 'bytes'\n    }],\n    internalType: 'struct Multicall3.Result[]',\n    name: 'returnData',\n    type: 'tuple[]'\n  }],\n  stateMutability: 'view',\n  type: 'function'\n}];\n\n// https://github.com/ethers-io/ethers.js/blob/master/packages/units/src.ts/index.ts#L10-L18\nconst units = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];\n\nasync function connect(_ref) {\n  let {\n    chainId,\n    connector\n  } = _ref;\n  const client = getClient();\n  const activeConnector = client.connector;\n  if (connector.id === (activeConnector === null || activeConnector === void 0 ? void 0 : activeConnector.id)) throw new ConnectorAlreadyConnectedError();\n\n  try {\n    client.setState(x => ({ ...x,\n      status: 'connecting'\n    }));\n    const data = await connector.connect({\n      chainId\n    });\n    client.setLastUsedConnector(connector.id);\n    client.setState(x => ({ ...x,\n      connector,\n      chains: connector === null || connector === void 0 ? void 0 : connector.chains,\n      data,\n      status: 'connected'\n    }));\n    client.storage.setItem('connected', true);\n    return { ...data,\n      connector\n    };\n  } catch (err) {\n    client.setState(x => {\n      return { ...x,\n        // Keep existing connector connected in case of error\n        status: x.connector ? 'connected' : 'disconnected'\n      };\n    });\n    throw err;\n  }\n}\n\nasync function disconnect() {\n  const client = getClient();\n  if (client.connector) await client.connector.disconnect();\n  client.clearState();\n  client.storage.removeItem('connected');\n}\n\nfunction getContract(_ref) {\n  let {\n    addressOrName,\n    contractInterface,\n    signerOrProvider\n  } = _ref;\n  return new Contract$1(addressOrName, contractInterface, signerOrProvider);\n}\n\nasync function deprecatedWriteContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    overrides,\n    signerOrProvider\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n\n  try {\n    var _chain;\n\n    let chain;\n\n    if (chainId) {\n      const activeChainId = await connector.getChainId(); // Try to switch chain to provided `chainId`\n\n      if (chainId !== activeChainId) {\n        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;\n\n        if (connector.switchChain) chain = await connector.switchChain(chainId);else throw new ChainMismatchError({\n          activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(x => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n          targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(x => x.id === chainId)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n        });\n      }\n    }\n\n    const signer = await connector.getSigner({\n      chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n    });\n    const contract = getContract({\n      addressOrName,\n      contractInterface,\n      signerOrProvider\n    });\n    const contractWithSigner = contract.connect(signer);\n    const contractFunction = contractWithSigner[functionName];\n    if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" does not exist in interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n    return await contractFunction(...params);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function fetchToken(_ref) {\n  let {\n    address,\n    chainId,\n    formatUnits: units = 'ether'\n  } = _ref;\n  const erc20Config = {\n    addressOrName: address,\n    contractInterface: erc20ABI,\n    chainId\n  };\n  const [decimals, name, symbol, totalSupply] = await readContracts({\n    allowFailure: false,\n    contracts: [{ ...erc20Config,\n      functionName: 'decimals'\n    }, { ...erc20Config,\n      functionName: 'name'\n    }, { ...erc20Config,\n      functionName: 'symbol'\n    }, { ...erc20Config,\n      functionName: 'totalSupply'\n    }]\n  });\n  return {\n    address,\n    decimals,\n    name,\n    symbol,\n    totalSupply: {\n      formatted: formatUnits(totalSupply, units),\n      value: totalSupply\n    }\n  };\n}\n\n/**\n * @description Prepares the parameters required for a contract write transaction.\n *\n * Returns config to be passed through to `writeContract`.\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *  addressOrName: '0x...',\n *  contractInterface: wagmiAbi,\n *  functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\nasync function prepareWriteContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface: contractInterface_,\n    functionName,\n    overrides,\n    signer: signer_\n  } = _ref;\n  const signer = signer_ !== null && signer_ !== void 0 ? signer_ : await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const contract = getContract({\n    addressOrName,\n    contractInterface: contractInterface_,\n    signerOrProvider: signer\n  });\n  const populateTransactionFn = contract.populateTransaction[functionName];\n\n  if (!populateTransactionFn) {\n    throw new ContractMethodDoesNotExistError({\n      addressOrName,\n      functionName\n    });\n  }\n\n  const contractInterface = minimizeContractInterface({\n    contractInterface: contract.interface,\n    functionName\n  });\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n  const unsignedTransaction = await populateTransactionFn(...params);\n  const gasLimit = unsignedTransaction.gasLimit || (await signer.estimateGas(unsignedTransaction));\n  return {\n    addressOrName,\n    args,\n    ...(chainId ? {\n      chainId\n    } : {}),\n    contractInterface,\n    functionName,\n    overrides,\n    request: { ...unsignedTransaction,\n      gasLimit\n    },\n    mode: 'prepared'\n  };\n}\n\nfunction getWebSocketProvider() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const client = getClient();\n  if (chainId) return client.getWebSocketProvider({\n    chainId\n  }) || client.webSocketProvider;\n  return client.webSocketProvider;\n}\n\nfunction watchProvider(args, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(getProvider(args));\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nfunction watchWebSocketProvider(args, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(getWebSocketProvider(args));\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      webSocketProvider\n    } = _ref;\n    return webSocketProvider;\n  }, handleChange);\n  return unsubscribe;\n}\n\nasync function readContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    overrides\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const contract = getContract({\n    addressOrName,\n    contractInterface,\n    signerOrProvider: provider\n  });\n  const params = [...(Array.isArray(args) ? args : args ? [args] : []), ...(overrides ? [overrides] : [])];\n  const contractFunction = contract[functionName];\n  if (!contractFunction) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n  const response = await (contractFunction === null || contractFunction === void 0 ? void 0 : contractFunction(...params));\n  return response;\n}\n\nasync function multicall(_ref) {\n  let {\n    allowFailure = true,\n    chainId,\n    contracts,\n    overrides\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  if (!provider.chains) throw new ProviderChainsNotFound();\n  const chain = provider.chains.find(chain => chain.id === chainId) || provider.chains[0];\n  if (!chain) throw new ProviderChainsNotFound();\n  if (!(chain !== null && chain !== void 0 && chain.multicall)) throw new ChainDoesNotSupportMulticallError({\n    chain\n  });\n  if (typeof (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) === 'number' && (overrides === null || overrides === void 0 ? void 0 : overrides.blockTag) < chain.multicall.blockCreated) throw new ChainDoesNotSupportMulticallError({\n    blockNumber: overrides === null || overrides === void 0 ? void 0 : overrides.blockTag,\n    chain\n  });\n  const multicallContract = getContract({\n    addressOrName: chain.multicall.address,\n    contractInterface: multicallInterface,\n    signerOrProvider: provider\n  });\n  const calls = contracts.map(_ref2 => {\n    let {\n      addressOrName,\n      contractInterface,\n      functionName,\n      ...config\n    } = _ref2;\n    const {\n      args\n    } = config || {};\n    const contract = getContract({\n      addressOrName,\n      contractInterface\n    });\n    const params = Array.isArray(args) ? args : args ? [args] : [];\n\n    try {\n      const callData = contract.interface.encodeFunctionData(functionName, params);\n      if (!contract[functionName]) logWarn(\"\\\"\".concat(functionName, \"\\\" is not in the interface for contract \\\"\").concat(addressOrName, \"\\\"\"));\n      return {\n        target: addressOrName,\n        allowFailure,\n        callData\n      };\n    } catch (err) {\n      if (!allowFailure) throw err;\n      return {\n        target: addressOrName,\n        allowFailure,\n        callData: '0x'\n      };\n    }\n  });\n  const params = [...[calls], ...(overrides ? [overrides] : [])];\n  const results = await multicallContract.aggregate3(...params);\n  return results.map((_ref3, i) => {\n    let {\n      returnData,\n      success\n    } = _ref3;\n    const {\n      addressOrName,\n      contractInterface,\n      functionName,\n      args\n    } = contracts[i];\n    const contract = getContract({\n      addressOrName,\n      contractInterface\n    });\n\n    if (!success) {\n      let error;\n\n      try {\n        contract.interface.decodeFunctionResult(functionName, returnData);\n      } catch (err) {\n        error = new ContractMethodRevertedError({\n          addressOrName,\n          args,\n          chainId: chain.id,\n          functionName,\n          errorMessage: err.message\n        });\n        if (!allowFailure) throw error;\n        logWarn(error.message);\n      }\n\n      return null;\n    }\n\n    if (returnData === '0x') {\n      const error = new ContractMethodNoResultError({\n        addressOrName,\n        args,\n        chainId: chain.id,\n        functionName\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n\n    try {\n      const result = contract.interface.decodeFunctionResult(functionName, returnData);\n      return Array.isArray(result) && result.length === 1 ? result[0] : result;\n    } catch (err) {\n      const error = new ContractResultDecodeError({\n        addressOrName,\n        args,\n        chainId: chain.id,\n        functionName,\n        errorMessage: err.message\n      });\n      if (!allowFailure) throw error;\n      logWarn(error.message);\n      return null;\n    }\n  });\n}\n\nasync function readContracts(_ref) {\n  let {\n    allowFailure = true,\n    contracts,\n    overrides\n  } = _ref;\n\n  try {\n    const provider = getProvider();\n    const contractsByChainId = contracts.reduce((contracts, contract) => {\n      var _contract$chainId;\n\n      const chainId = (_contract$chainId = contract.chainId) !== null && _contract$chainId !== void 0 ? _contract$chainId : provider.network.chainId;\n      return { ...contracts,\n        [chainId]: [...(contracts[chainId] || []), contract]\n      };\n    }, {});\n\n    const promises = () => Object.entries(contractsByChainId).map(_ref2 => {\n      let [chainId, contracts] = _ref2;\n      return multicall({\n        allowFailure,\n        chainId: parseInt(chainId),\n        contracts,\n        overrides\n      });\n    });\n\n    if (allowFailure) {\n      return (await Promise.allSettled(promises())).map(result => {\n        if (result.status === 'fulfilled') return result.value;\n\n        if (result.reason instanceof ChainDoesNotSupportMulticallError) {\n          logWarn(result.reason.message);\n          throw result.reason;\n        }\n\n        return null;\n      }).flat();\n    }\n\n    return (await Promise.all(promises())).flat();\n  } catch (err) {\n    if (err instanceof ContractResultDecodeError) throw err;\n    if (err instanceof ContractMethodNoResultError) throw err;\n    if (err instanceof ContractMethodRevertedError) throw err;\n\n    const promises = () => contracts.map(contract => readContract({ ...contract,\n      overrides\n    }));\n\n    if (allowFailure) {\n      return (await Promise.allSettled(promises())).map((result, i) => {\n        if (result.status === 'fulfilled') return result.value;\n        const {\n          addressOrName,\n          functionName,\n          chainId,\n          args\n        } = contracts[i];\n        const error = new ContractMethodRevertedError({\n          addressOrName,\n          functionName,\n          chainId: chainId !== null && chainId !== void 0 ? chainId : mainnet.id,\n          args,\n          errorMessage: result.reason\n        });\n        logWarn(error.message);\n        return null;\n      });\n    }\n\n    return await Promise.all(promises());\n  }\n}\n\nfunction watchContractEvent(\n/** Contract configuration */\ncontractArgs,\n/** Event name to listen to */\neventName, callback) {\n  let {\n    chainId,\n    once\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let contract;\n\n  const watchEvent = async () => {\n    if (contract) {\n      var _contract;\n\n      (_contract = contract) === null || _contract === void 0 ? void 0 : _contract.off(eventName, callback);\n    }\n\n    contract = getContract({\n      signerOrProvider: getWebSocketProvider({\n        chainId\n      }) || getProvider({\n        chainId\n      }),\n      ...contractArgs\n    });\n    if (once) contract.once(eventName, callback);else contract.on(eventName, callback);\n  };\n\n  watchEvent();\n  const client = getClient();\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, watchEvent, {\n    equalityFn: shallow\n  });\n  return () => {\n    var _contract2;\n\n    (_contract2 = contract) === null || _contract2 === void 0 ? void 0 : _contract2.off(eventName, callback);\n    unsubscribe();\n  };\n}\n\nasync function fetchBlockNumber() {\n  let {\n    chainId\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const blockNumber = await provider.getBlockNumber();\n  return blockNumber;\n}\n\nfunction watchBlockNumber(args, callback) {\n  var _client$webSocketProv;\n\n  let previousProvider;\n\n  const createListener = provider => {\n    // We need to debounce the listener as we want to opt-out\n    // of the behavior where ethers emits a \"block\" event for\n    // every block that was missed in between the `pollingInterval`.\n    // We are setting a wait time of 1 as emitting an event in\n    // ethers takes ~0.1ms.\n    const debouncedCallback = debounce(callback, 1);\n\n    if (previousProvider) {\n      var _previousProvider;\n\n      (_previousProvider = previousProvider) === null || _previousProvider === void 0 ? void 0 : _previousProvider.off('block', debouncedCallback);\n    }\n\n    provider.on('block', debouncedCallback);\n    previousProvider = provider;\n  };\n\n  const client = getClient();\n  const provider_ = (_client$webSocketProv = client.webSocketProvider) !== null && _client$webSocketProv !== void 0 ? _client$webSocketProv : client.provider;\n  if (args.listen) createListener(provider_);\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref;\n    return {\n      provider,\n      webSocketProvider\n    };\n  }, async _ref2 => {\n    let {\n      provider,\n      webSocketProvider\n    } = _ref2;\n    const provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;\n\n    if (args.listen && provider_) {\n      createListener(provider_);\n    }\n\n    callback(await fetchBlockNumber());\n  }, {\n    equalityFn: shallow\n  });\n  return () => {\n    unsubscribe();\n    provider_ === null || provider_ === void 0 ? void 0 : provider_.off('block', callback);\n  };\n}\n\nfunction watchReadContract(config, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await readContract(config));\n\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nfunction watchReadContracts(config, callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await readContracts(config));\n\n  const unwatch = config.listenToBlock ? watchBlockNumber({\n    listen: true\n  }, handleChange) : undefined;\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      provider\n    } = _ref;\n    return provider;\n  }, handleChange);\n  return () => {\n    unsubscribe();\n    unwatch === null || unwatch === void 0 ? void 0 : unwatch();\n  };\n}\n\nasync function deprecatedSendTransaction(_ref) {\n  let {\n    chainId,\n    request\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n\n  try {\n    var _chain;\n\n    let chain;\n\n    if (chainId) {\n      const activeChainId = await connector.getChainId(); // Try to switch chain to provided `chainId`\n\n      if (chainId !== activeChainId) {\n        var _connector$chains$fin, _connector$chains$fin2, _connector$chains$fin3, _connector$chains$fin4;\n\n        if (connector.switchChain) chain = await connector.switchChain(chainId);else throw new ChainMismatchError({\n          activeChain: (_connector$chains$fin = (_connector$chains$fin2 = connector.chains.find(x => x.id === activeChainId)) === null || _connector$chains$fin2 === void 0 ? void 0 : _connector$chains$fin2.name) !== null && _connector$chains$fin !== void 0 ? _connector$chains$fin : \"Chain \".concat(activeChainId),\n          targetChain: (_connector$chains$fin3 = (_connector$chains$fin4 = connector.chains.find(x => x.id === chainId)) === null || _connector$chains$fin4 === void 0 ? void 0 : _connector$chains$fin4.name) !== null && _connector$chains$fin3 !== void 0 ? _connector$chains$fin3 : \"Chain \".concat(chainId)\n        });\n      }\n    }\n\n    const signer = await connector.getSigner({\n      chainId: (_chain = chain) === null || _chain === void 0 ? void 0 : _chain.id\n    });\n    return await signer.sendTransaction(request);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\n/**\n * @description Fetches transaction for hash\n *\n * @example\n * import { fetchTransaction } from '@wagmi/core'\n *\n * const transaction = await fetchTransaction({\n *  chainId: 1,\n *  hash: '0x...',\n * })\n */\nasync function fetchTransaction(_ref) {\n  let {\n    chainId,\n    hash\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  return await provider.getTransaction(hash);\n}\n\nasync function fetchEnsAddress(_ref) {\n  let {\n    chainId,\n    name\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const address = await provider.resolveName(name);\n\n  try {\n    return address ? getAddress(address) : null;\n  } catch (_error) {\n    return null;\n  }\n}\n\nasync function fetchEnsAvatar(_ref) {\n  let {\n    addressOrName,\n    chainId\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  }); // TODO: Update with more advanced logic\n  // https://github.com/ensdomains/ens-avatar\n\n  const avatar = await provider.getAvatar(addressOrName);\n  return avatar;\n}\n\nasync function fetchEnsName(_ref) {\n  let {\n    address,\n    chainId\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  return await provider.lookupAddress(address);\n}\n\nasync function fetchEnsResolver(_ref) {\n  let {\n    chainId,\n    name\n  } = _ref;\n  const provider = getProvider({\n    chainId\n  });\n  const resolver = await provider.getResolver(name);\n  return resolver;\n}\n\n/**\n * @description Prepares the parameters required for sending a transaction.\n *\n * Returns config to be passed through to `sendTransaction`.\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  request: {\n *    to: 'moxey.eth',\n *    value: parseEther('1'),\n *  }\n * })\n * const result = await sendTransaction(config)\n */\nasync function prepareSendTransaction(_ref) {\n  let {\n    chainId,\n    request,\n    signerOrProvider = getProvider({\n      chainId\n    })\n  } = _ref;\n  const [to, gasLimit] = await Promise.all([isAddress(request.to) ? Promise.resolve(request.to) : fetchEnsAddress({\n    name: request.to\n  }), request.gasLimit ? Promise.resolve(request.gasLimit) : signerOrProvider.estimateGas(request)]);\n  if (!to) throw new Error('Could not resolve ENS name');\n  return { ...(chainId ? {\n      chainId\n    } : {}),\n    request: { ...request,\n      gasLimit,\n      to\n    },\n    mode: 'prepared'\n  };\n}\n\n/**\n * @description Function to send a transaction.\n *\n * It is recommended to pair this with the `prepareSendTransaction` function to avoid\n * [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareSendTransaction, sendTransaction } from '@wagmi/core'\n *\n * const config = await prepareSendTransaction({\n *  to: 'moxey.eth',\n *  value: parseEther('1'),\n * })\n * const result = await sendTransaction(config)\n */\nasync function sendTransaction(_ref) {\n  let {\n    chainId,\n    mode,\n    request\n  } = _ref;\n\n  /********************************************************************/\n\n  /** START: iOS App Link cautious code.                              */\n\n  /** Do not perform any async operations in this block.              */\n\n  /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n  /********************************************************************/\n  // `fetchSigner` isn't really \"asynchronous\" as we have already\n  // initialized the provider upon user connection, so it will return\n  // immediately.\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n\n  if (mode === 'prepared') {\n    if (!request.gasLimit) throw new Error('`gasLimit` is required');\n    if (!request.to) throw new Error('`to` is required');\n  }\n\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n  if (chainId && chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id)) {\n    var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n    throw new ChainMismatchError({\n      activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n      targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n    });\n  }\n\n  try {\n    var _connectUnchecked, _ref2;\n\n    // Why don't we just use `signer.sendTransaction`?\n    // The `signer.sendTransaction` method performs async\n    // heavy operations (such as fetching block number)\n    // which is not really needed for our case.\n    // Having async heavy operations has side effects\n    // when using it in a click handler (iOS deep linking issues,\n    // delay to open wallet, etc).\n    const uncheckedSigner = (_connectUnchecked = (_ref2 = signer).connectUnchecked) === null || _connectUnchecked === void 0 ? void 0 : _connectUnchecked.call(_ref2);\n    const {\n      hash,\n      wait\n    } = await (uncheckedSigner !== null && uncheckedSigner !== void 0 ? uncheckedSigner : signer).sendTransaction(request);\n    /********************************************************************/\n\n    /** END: iOS App Link cautious code.                                */\n\n    /** Go nuts!                                                        */\n\n    /********************************************************************/\n\n    return {\n      hash,\n      wait\n    };\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function waitForTransaction(_ref) {\n  let {\n    chainId,\n    confirmations,\n    hash,\n    timeout,\n    wait: wait_\n  } = _ref;\n  let promise;\n\n  if (hash) {\n    const provider = getProvider({\n      chainId\n    });\n    promise = provider.waitForTransaction(hash, confirmations, timeout);\n  } else if (wait_) promise = wait_(confirmations);else throw new Error('hash or wait is required');\n\n  return await promise;\n}\n\n/**\n * @description Function to call a contract write method.\n *\n * It is recommended to pair this with the {@link prepareWriteContract} function\n * to avoid [UX pitfalls](https://wagmi.sh/docs/prepare-hooks/intro#ux-pitfalls-without-prepare-hooks).\n *\n * @example\n * import { prepareWriteContract, writeContract } from '@wagmi/core'\n *\n * const config = await prepareWriteContract({\n *   addressOrName: '0x...',\n *   contractInterface: wagmiAbi,\n *   functionName: 'mint',\n * })\n * const result = await writeContract(config)\n */\nasync function writeContract(_ref) {\n  let {\n    addressOrName,\n    args,\n    chainId,\n    contractInterface,\n    functionName,\n    mode,\n    overrides,\n    request: request_\n  } = _ref;\n\n  /********************************************************************/\n\n  /** START: iOS App Link cautious code.                              */\n\n  /** Do not perform any async operations in this block.              */\n\n  /** Ref: wagmi.sh/docs/prepare-hooks/intro#ios-app-link-constraints */\n\n  /********************************************************************/\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n  if (chainId && chainId !== activeChainId) {\n    var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n    throw new ChainMismatchError({\n      activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n      targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n    });\n  }\n\n  if (mode === 'prepared') {\n    if (!request_) throw new Error('`request` is required');\n  }\n\n  const request = mode === 'recklesslyUnprepared' ? (await prepareWriteContract({\n    addressOrName,\n    args,\n    contractInterface,\n    functionName,\n    overrides\n  })).request : request_;\n  const transaction = await sendTransaction({\n    request,\n    mode: 'prepared'\n  });\n  /********************************************************************/\n\n  /** END: iOS App Link cautious code.                                */\n\n  /** Go nuts!                                                        */\n\n  /********************************************************************/\n\n  return transaction;\n}\n\nasync function fetchBalance(_ref) {\n  var _client$chains, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4;\n\n  let {\n    addressOrName,\n    chainId,\n    formatUnits: unit,\n    token\n  } = _ref;\n  const client = getClient();\n  const provider = getProvider({\n    chainId\n  });\n\n  if (token) {\n    const erc20Config = {\n      addressOrName: token,\n      contractInterface: erc20ABI,\n      chainId\n    }; // Convert ENS name to address if required\n\n    let resolvedAddress;\n    if (isAddress(addressOrName)) resolvedAddress = addressOrName;else {\n      const address = await provider.resolveName(addressOrName); // Same error `provider.getBalance` throws for invalid ENS name\n\n      if (!address) logger.throwError('ENS name not configured', Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"resolveName(\".concat(JSON.stringify(addressOrName), \")\")\n      });\n      resolvedAddress = address;\n    }\n    const [value, decimals, symbol] = await readContracts({\n      allowFailure: false,\n      contracts: [{ ...erc20Config,\n        functionName: 'balanceOf',\n        args: resolvedAddress\n      }, { ...erc20Config,\n        functionName: 'decimals'\n      }, { ...erc20Config,\n        functionName: 'symbol'\n      }]\n    });\n    return {\n      decimals,\n      formatted: formatUnits(value !== null && value !== void 0 ? value : '0', unit !== null && unit !== void 0 ? unit : decimals),\n      symbol,\n      value\n    };\n  }\n\n  const chains = [...(client.provider.chains || []), ...((_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [])];\n  const value = await provider.getBalance(addressOrName);\n  const chain = chains.find(x => x.id === provider.network.chainId);\n  return {\n    decimals: (_chain$nativeCurrency = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency2 = chain.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,\n    formatted: formatUnits(value !== null && value !== void 0 ? value : '0', unit !== null && unit !== void 0 ? unit : 'ether'),\n    symbol: (_chain$nativeCurrency3 = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency4 = chain.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : 'ETH',\n    value\n  };\n}\n\nasync function fetchSigner() {\n  var _client$connector, _client$connector$get;\n\n  const client = getClient();\n  const signer = (await ((_client$connector = client.connector) === null || _client$connector === void 0 ? void 0 : (_client$connector$get = _client$connector.getSigner) === null || _client$connector$get === void 0 ? void 0 : _client$connector$get.call(_client$connector))) || null;\n  return signer;\n}\n\nfunction getAccount() {\n  const {\n    data,\n    connector,\n    status\n  } = getClient();\n\n  switch (status) {\n    case 'connected':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector: connector,\n        isConnected: true,\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n\n    case 'reconnecting':\n      return {\n        address: data === null || data === void 0 ? void 0 : data.account,\n        connector,\n        isConnected: !!(data !== null && data !== void 0 && data.account),\n        isConnecting: false,\n        isDisconnected: false,\n        isReconnecting: true,\n        status\n      };\n\n    case 'connecting':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: true,\n        isDisconnected: false,\n        isReconnecting: false,\n        status\n      };\n\n    case 'disconnected':\n      return {\n        address: undefined,\n        connector: undefined,\n        isConnected: false,\n        isConnecting: false,\n        isDisconnected: true,\n        isReconnecting: false,\n        status\n      };\n  }\n}\n\nfunction getNetwork() {\n  var _client$data, _client$data$chain, _client$chains, _find, _client$data2;\n\n  const client = getClient();\n  const chainId = (_client$data = client.data) === null || _client$data === void 0 ? void 0 : (_client$data$chain = _client$data.chain) === null || _client$data$chain === void 0 ? void 0 : _client$data$chain.id;\n  const activeChains = (_client$chains = client.chains) !== null && _client$chains !== void 0 ? _client$chains : [];\n  const activeChain = (_find = [...(client.provider.chains || []), ...activeChains].find(x => x.id === chainId)) !== null && _find !== void 0 ? _find : {\n    id: chainId,\n    name: \"Chain \".concat(chainId),\n    network: \"\".concat(chainId),\n    rpcUrls: {\n      default: ''\n    }\n  };\n  return {\n    chain: chainId ? { ...activeChain,\n      ...((_client$data2 = client.data) === null || _client$data2 === void 0 ? void 0 : _client$data2.chain),\n      id: chainId\n    } : undefined,\n    chains: activeChains\n  };\n}\n\nasync function signMessage(args) {\n  try {\n    const signer = await fetchSigner();\n    if (!signer) throw new ConnectorNotFoundError();\n    return await signer.signMessage(args.message);\n  } catch (error) {\n    if (error.code === 4001) throw new UserRejectedRequestError(error);\n    throw error;\n  }\n}\n\nasync function signTypedData(_ref) {\n  let {\n    domain,\n    types,\n    value\n  } = _ref;\n  const signer = await fetchSigner();\n  if (!signer) throw new ConnectorNotFoundError();\n  const {\n    chain: activeChain,\n    chains\n  } = getNetwork();\n  const {\n    chainId: chainId_\n  } = domain;\n\n  if (chainId_) {\n    const chainId = normalizeChainId(chainId_);\n    const activeChainId = activeChain === null || activeChain === void 0 ? void 0 : activeChain.id;\n\n    if (chainId !== (activeChain === null || activeChain === void 0 ? void 0 : activeChain.id)) {\n      var _chains$find$name, _chains$find, _chains$find$name2, _chains$find2;\n\n      throw new ChainMismatchError({\n        activeChain: (_chains$find$name = (_chains$find = chains.find(x => x.id === activeChainId)) === null || _chains$find === void 0 ? void 0 : _chains$find.name) !== null && _chains$find$name !== void 0 ? _chains$find$name : \"Chain \".concat(activeChainId),\n        targetChain: (_chains$find$name2 = (_chains$find2 = chains.find(x => x.id === chainId)) === null || _chains$find2 === void 0 ? void 0 : _chains$find2.name) !== null && _chains$find$name2 !== void 0 ? _chains$find$name2 : \"Chain \".concat(chainId)\n      });\n    }\n  } // Method name may be changed in the future, see https://docs.ethers.io/v5/api/signer/#Signer-signTypedData\n\n\n  return await signer._signTypedData(domain, types, value);\n}\n\nasync function switchNetwork(_ref) {\n  let {\n    chainId\n  } = _ref;\n  const {\n    connector\n  } = getClient();\n  if (!connector) throw new ConnectorNotFoundError();\n  if (!connector.switchChain) throw new SwitchChainNotSupportedError({\n    connector\n  });\n  return await connector.switchChain(chainId);\n}\n\nfunction watchAccount(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = getClient();\n\n  const handleChange = () => callback(getAccount());\n\n  const unsubscribe = client.subscribe(_ref => {\n    let {\n      data,\n      connector,\n      status\n    } = _ref;\n    return selector({\n      address: data === null || data === void 0 ? void 0 : data.account,\n      connector,\n      status\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchNetwork(callback) {\n  let {\n    selector = x => x\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const client = getClient();\n\n  const handleChange = () => callback(getNetwork());\n\n  const unsubscribe = client.subscribe(_ref => {\n    var _data$chain;\n\n    let {\n      data,\n      chains\n    } = _ref;\n    return selector({\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      chains\n    });\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nfunction watchSigner(callback) {\n  const client = getClient();\n\n  const handleChange = async () => callback(await fetchSigner());\n\n  const unsubscribe = client.subscribe(_ref => {\n    var _data$chain;\n\n    let {\n      data,\n      connector\n    } = _ref;\n    return {\n      account: data === null || data === void 0 ? void 0 : data.account,\n      chainId: data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id,\n      connector\n    };\n  }, handleChange, {\n    equalityFn: shallow\n  });\n  return unsubscribe;\n}\n\nasync function fetchFeeData() {\n  let {\n    chainId,\n    formatUnits: units = 'wei'\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const provider = getProvider({\n    chainId\n  });\n  const feeData = await provider.getFeeData();\n  const formatted = {\n    gasPrice: feeData.gasPrice ? formatUnits(feeData.gasPrice, units) : null,\n    maxFeePerGas: feeData.maxFeePerGas ? formatUnits(feeData.maxFeePerGas, units) : null,\n    maxPriorityFeePerGas: feeData.maxPriorityFeePerGas ? formatUnits(feeData.maxPriorityFeePerGas, units) : null\n  };\n  return { ...feeData,\n    formatted\n  };\n}\n\nexport { configureChains, connect, deepEqual, deprecatedSendTransaction, deprecatedWriteContract, disconnect, erc20ABI, erc721ABI, fetchBalance, fetchBlockNumber, fetchEnsAddress, fetchEnsAvatar, fetchEnsName, fetchEnsResolver, fetchFeeData, fetchSigner, fetchToken, fetchTransaction, getAccount, getContract, getNetwork, getWebSocketProvider, minimizeContractInterface, parseContractResult, prepareSendTransaction, prepareWriteContract, readContract, readContracts, sendTransaction, signMessage, signTypedData, switchNetwork, units, waitForTransaction, watchAccount, watchBlockNumber, watchContractEvent, watchNetwork, watchProvider, watchReadContract, watchReadContracts, watchSigner, watchWebSocketProvider, writeContract };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}