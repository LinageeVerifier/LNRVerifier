{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { isStorageError } from '../lib/errors';\nimport { get, post, remove as _remove } from '../lib/fetch';\nimport { resolveFetch } from '../lib/helpers';\nvar DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc'\n  }\n};\nvar DEFAULT_FILE_OPTIONS = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false\n};\n\nvar StorageFileApi = /*#__PURE__*/function () {\n  function StorageFileApi(url) {\n    var headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var bucketId = arguments.length > 2 ? arguments[2] : undefined;\n    var fetch = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, StorageFileApi);\n\n    this.url = url;\n    this.headers = headers;\n    this.bucketId = bucketId;\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n\n\n  _createClass(StorageFileApi, [{\n    key: \"uploadOrUpdate\",\n    value: function uploadOrUpdate(method, path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var body, options, headers, cleanPath, _path, res, error;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {\n                  'x-upsert': String(options.upsert)\n                });\n\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                  body = new FormData();\n                  body.append('cacheControl', options.cacheControl);\n                  body.append('', fileBody);\n                } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                  body = fileBody;\n                  body.append('cacheControl', options.cacheControl);\n                } else {\n                  body = fileBody;\n                  headers['cache-control'] = \"max-age=\".concat(options.cacheControl);\n                  headers['content-type'] = options.contentType;\n                }\n\n                cleanPath = this._removeEmptyFolders(path);\n                _path = this._getFinalPath(cleanPath);\n                _context.next = 8;\n                return this.fetch(\"\".concat(this.url, \"/object/\").concat(_path), {\n                  method: method,\n                  body: body,\n                  headers: headers\n                });\n\n              case 8:\n                res = _context.sent;\n\n                if (!res.ok) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  data: {\n                    path: cleanPath\n                  },\n                  error: null\n                });\n\n              case 13:\n                _context.next = 15;\n                return res.json();\n\n              case 15:\n                error = _context.sent;\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: error\n                });\n\n              case 17:\n                _context.next = 24;\n                break;\n\n              case 19:\n                _context.prev = 19;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (!isStorageError(_context.t0)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  data: null,\n                  error: _context.t0\n                });\n\n              case 23:\n                throw _context.t0;\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 19]]);\n      }));\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload(path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.uploadOrUpdate('POST', path, fileBody, fileOptions));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(path, fileBody, fileOptions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.uploadOrUpdate('PUT', path, fileBody, fileOptions));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(fromPath, toPath) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/move\"), {\n                  bucketId: this.bucketId,\n                  sourceKey: fromPath,\n                  destinationKey: toPath\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context4.prev = 7;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                if (!isStorageError(_context4.t0)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  error: _context4.t0\n                });\n\n              case 11:\n                throw _context4.t0;\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     */\n\n  }, {\n    key: \"copy\",\n    value: function copy(fromPath, toPath) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n                _context5.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/copy\"), {\n                  bucketId: this.bucketId,\n                  sourceKey: fromPath,\n                  destinationKey: toPath\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context5.sent;\n                return _context5.abrupt(\"return\", {\n                  data: {\n                    path: data.Key\n                  },\n                  error: null\n                });\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](0);\n\n                if (!isStorageError(_context5.t0)) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  error: _context5.t0\n                });\n\n              case 11:\n                throw _context5.t0;\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     */\n\n  }, {\n    key: \"createSignedUrl\",\n    value: function createSignedUrl(path, expiresIn) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _path, data, signedUrl;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _path = this._getFinalPath(path);\n                _context6.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/object/sign/\").concat(_path), {\n                  expiresIn: expiresIn\n                }, {\n                  headers: this.headers\n                });\n\n              case 4:\n                data = _context6.sent;\n                signedUrl = encodeURI(\"\".concat(this.url).concat(data.signedURL));\n                data = {\n                  signedUrl: signedUrl\n                };\n                return _context6.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 10:\n                _context6.prev = 10;\n                _context6.t0 = _context6[\"catch\"](0);\n\n                if (!isStorageError(_context6.t0)) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  data: null,\n                  error: _context6.t0\n                });\n\n              case 14:\n                throw _context6.t0;\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 10]]);\n      }));\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     */\n\n  }, {\n    key: \"createSignedUrls\",\n    value: function createSignedUrls(paths, expiresIn) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this = this;\n\n        var data;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return post(this.fetch, \"\".concat(this.url, \"/object/sign/\").concat(this.bucketId), {\n                  expiresIn: expiresIn,\n                  paths: paths\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context7.sent;\n                return _context7.abrupt(\"return\", {\n                  data: data.map(function (datum) {\n                    return Object.assign(Object.assign({}, datum), {\n                      signedUrl: datum.signedURL ? encodeURI(\"\".concat(_this.url).concat(datum.signedURL)) : null\n                    });\n                  }),\n                  error: null\n                });\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n\n                if (!isStorageError(_context7.t0)) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 11:\n                throw _context7.t0;\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Downloads a file.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     */\n\n  }, {\n    key: \"download\",\n    value: function download(path) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var _path, res, data;\n\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _path = this._getFinalPath(path);\n                _context8.next = 4;\n                return get(this.fetch, \"\".concat(this.url, \"/object/\").concat(_path), {\n                  headers: this.headers,\n                  noResolveJson: true\n                });\n\n              case 4:\n                res = _context8.sent;\n                _context8.next = 7;\n                return res.blob();\n\n              case 7:\n                data = _context8.sent;\n                return _context8.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 11:\n                _context8.prev = 11;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!isStorageError(_context8.t0)) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  data: null,\n                  error: _context8.t0\n                });\n\n              case 15:\n                throw _context8.t0;\n\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 11]]);\n      }));\n    }\n    /**\n     * Retrieves the URL for an asset in a public bucket.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     */\n\n  }, {\n    key: \"getPublicUrl\",\n    value: function getPublicUrl(path) {\n      var _path = this._getFinalPath(path);\n\n      return {\n        data: {\n          publicUrl: encodeURI(\"\".concat(this.url, \"/object/public/\").concat(_path))\n        }\n      };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(paths) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var data;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return _remove(this.fetch, \"\".concat(this.url, \"/object/\").concat(this.bucketId), {\n                  prefixes: paths\n                }, {\n                  headers: this.headers\n                });\n\n              case 3:\n                data = _context9.sent;\n                return _context9.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 7:\n                _context9.prev = 7;\n                _context9.t0 = _context9[\"catch\"](0);\n\n                if (!isStorageError(_context9.t0)) {\n                  _context9.next = 11;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  error: _context9.t0\n                });\n\n              case 11:\n                throw _context9.t0;\n\n              case 12:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 7]]);\n      }));\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     */\n\n  }, {\n    key: \"list\",\n    value: function list(path, options, parameters) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var body, data;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {\n                  prefix: path || ''\n                });\n                _context10.next = 4;\n                return post(this.fetch, \"\".concat(this.url, \"/object/list/\").concat(this.bucketId), body, {\n                  headers: this.headers\n                }, parameters);\n\n              case 4:\n                data = _context10.sent;\n                return _context10.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 8:\n                _context10.prev = 8;\n                _context10.t0 = _context10[\"catch\"](0);\n\n                if (!isStorageError(_context10.t0)) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  error: _context10.t0\n                });\n\n              case 12:\n                throw _context10.t0;\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 8]]);\n      }));\n    }\n  }, {\n    key: \"_getFinalPath\",\n    value: function _getFinalPath(path) {\n      return \"\".concat(this.bucketId, \"/\").concat(path);\n    }\n  }, {\n    key: \"_removeEmptyFolders\",\n    value: function _removeEmptyFolders(path) {\n      return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n  }]);\n\n  return StorageFileApi;\n}(); //# sourceMappingURL=StorageFileApi.js.map\n\n\nexport { StorageFileApi as default };","map":null,"metadata":{},"sourceType":"module"}