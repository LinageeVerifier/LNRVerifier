{"ast":null,"code":"import _objectSpread from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { replaceData, noop, timeUntilStale, getAbortController } from './utils.mjs';\nimport { defaultLogger } from './logger.mjs';\nimport { notifyManager } from './notifyManager.mjs';\nimport { createRetryer, isCancelledError, canFetch } from './retryer.mjs';\nimport { Removable } from './removable.mjs'; // CLASS\n\nvar Query = /*#__PURE__*/function (_Removable) {\n  _inherits(Query, _Removable);\n\n  var _super = _createSuper(Query);\n\n  function Query(config) {\n    var _this;\n\n    _classCallCheck(this, Query);\n\n    _this = _super.call(this);\n    _this.abortSignalConsumed = false;\n    _this.defaultOptions = config.defaultOptions;\n\n    _this.setOptions(config.options);\n\n    _this.observers = [];\n    _this.cache = config.cache;\n    _this.logger = config.logger || defaultLogger;\n    _this.queryKey = config.queryKey;\n    _this.queryHash = config.queryHash;\n    _this.initialState = config.state || getDefaultState(_this.options);\n    _this.state = _this.initialState;\n    _this.meta = config.meta;\n    return _this;\n  }\n\n  _createClass(Query, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _objectSpread(_objectSpread({}, this.defaultOptions), options);\n      this.meta = options == null ? void 0 : options.meta;\n      this.updateCacheTime(this.options.cacheTime);\n    }\n  }, {\n    key: \"optionalRemove\",\n    value: function optionalRemove() {\n      if (!this.observers.length && this.state.fetchStatus === 'idle') {\n        this.cache.remove(this);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newData, options) {\n      var data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n      this.dispatch({\n        data: data,\n        type: 'success',\n        dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n        manual: options == null ? void 0 : options.manual\n      });\n      return data;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state, setStateOptions) {\n      this.dispatch({\n        type: 'setState',\n        state: state,\n        setStateOptions: setStateOptions\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(options) {\n      var _this$retryer;\n\n      var promise = this.promise;\n      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n      return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Query.prototype), \"destroy\", this).call(this);\n\n      this.cancel({\n        silent: true\n      });\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.destroy();\n      this.setState(this.initialState);\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.observers.some(function (observer) {\n        return observer.options.enabled !== false;\n      });\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n  }, {\n    key: \"isStale\",\n    value: function isStale() {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (observer) {\n        return observer.getCurrentResult().isStale;\n      });\n    }\n  }, {\n    key: \"isStaleByTime\",\n    value: function isStaleByTime() {\n      var staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n    }\n  }, {\n    key: \"onFocus\",\n    value: function onFocus() {\n      var _this$retryer2;\n\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnWindowFocus();\n      });\n\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n\n      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n    }\n  }, {\n    key: \"onOnline\",\n    value: function onOnline() {\n      var _this$retryer3;\n\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnReconnect();\n      });\n\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n\n      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      if (this.observers.indexOf(observer) === -1) {\n        this.observers.push(observer); // Stop the query from being garbage collected\n\n        this.clearGcTimeout();\n        this.cache.notify({\n          type: 'observerAdded',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      if (this.observers.indexOf(observer) !== -1) {\n        this.observers = this.observers.filter(function (x) {\n          return x !== observer;\n        });\n\n        if (!this.observers.length) {\n          // If the transport layer does not support cancellation\n          // we'll let the query continue so the result can be cached\n          if (this.retryer) {\n            if (this.abortSignalConsumed) {\n              this.retryer.cancel({\n                revert: true\n              });\n            } else {\n              this.retryer.cancelRetry();\n            }\n          }\n\n          this.scheduleGc();\n        }\n\n        this.cache.notify({\n          type: 'observerRemoved',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"getObserversCount\",\n    value: function getObserversCount() {\n      return this.observers.length;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      if (!this.state.isInvalidated) {\n        this.dispatch({\n          type: 'invalidate'\n        });\n      }\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(options, fetchOptions) {\n      var _this2 = this;\n\n      var _this$options$behavio, _context$fetchOptions;\n\n      if (this.state.fetchStatus !== 'idle') {\n        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n          // Silently cancel current fetch if the user wants to cancel refetches\n          this.cancel({\n            silent: true\n          });\n        } else if (this.promise) {\n          var _this$retryer4; // make sure that retries that were potentially cancelled due to unmounts can continue\n\n\n          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n          return this.promise;\n        }\n      } // Update config if passed, otherwise the config from the last execution is used\n\n\n      if (options) {\n        this.setOptions(options);\n      } // Use the options from the first observer with a query function if no function is found.\n      // This can happen when the query is hydrated or created with setQueryData.\n\n\n      if (!this.options.queryFn) {\n        var observer = this.observers.find(function (x) {\n          return x.options.queryFn;\n        });\n\n        if (observer) {\n          this.setOptions(observer.options);\n        }\n      }\n\n      if (!Array.isArray(this.options.queryKey)) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n        }\n      }\n\n      var abortController = getAbortController(); // Create query function context\n\n      var queryFnContext = {\n        queryKey: this.queryKey,\n        pageParam: undefined,\n        meta: this.meta\n      }; // Adds an enumerable signal property to the object that\n      // which sets abortSignalConsumed to true when the signal\n      // is read.\n\n      var addSignalProperty = function addSignalProperty(object) {\n        Object.defineProperty(object, 'signal', {\n          enumerable: true,\n          get: function get() {\n            if (abortController) {\n              _this2.abortSignalConsumed = true;\n              return abortController.signal;\n            }\n\n            return undefined;\n          }\n        });\n      };\n\n      addSignalProperty(queryFnContext); // Create fetch function\n\n      var fetchFn = function fetchFn() {\n        if (!_this2.options.queryFn) {\n          return Promise.reject('Missing queryFn');\n        }\n\n        _this2.abortSignalConsumed = false;\n        return _this2.options.queryFn(queryFnContext);\n      }; // Trigger behavior hook\n\n\n      var context = {\n        fetchOptions: fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: fetchFn,\n        meta: this.meta\n      };\n      addSignalProperty(context);\n      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n      this.revertState = this.state; // Set to fetching state if not already in it\n\n      if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n        var _context$fetchOptions2;\n\n        this.dispatch({\n          type: 'fetch',\n          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n        });\n      }\n\n      var onError = function onError(error) {\n        // Optimistically update state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          _this2.dispatch({\n            type: 'error',\n            error: error\n          });\n        }\n\n        if (!isCancelledError(error)) {\n          var _this$cache$config$on, _this$cache$config; // Notify cache callback\n\n\n          (_this$cache$config$on = (_this$cache$config = _this2.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, _this2);\n\n          if (process.env.NODE_ENV !== 'production') {\n            _this2.logger.error(error);\n          }\n        }\n\n        if (!_this2.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          _this2.scheduleGc();\n        }\n\n        _this2.isFetchingOptimistic = false;\n      }; // Try to fetch the data\n\n\n      this.retryer = createRetryer({\n        fn: context.fetchFn,\n        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n        onSuccess: function onSuccess(data) {\n          var _this$cache$config$on2, _this$cache$config2;\n\n          if (typeof data === 'undefined') {\n            if (process.env.NODE_ENV !== 'production') {\n              _this2.logger.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \" + _this2.queryHash);\n            }\n\n            onError(new Error('undefined'));\n            return;\n          }\n\n          _this2.setData(data); // Notify cache callback\n\n\n          (_this$cache$config$on2 = (_this$cache$config2 = _this2.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, _this2);\n\n          if (!_this2.isFetchingOptimistic) {\n            // Schedule query gc after fetching\n            _this2.scheduleGc();\n          }\n\n          _this2.isFetchingOptimistic = false;\n        },\n        onError: onError,\n        onFail: function onFail() {\n          _this2.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: function onPause() {\n          _this2.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: function onContinue() {\n          _this2.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode\n      });\n      this.promise = this.retryer.promise;\n      return this.promise;\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      var _this3 = this;\n\n      var reducer = function reducer(state) {\n        var _action$meta, _action$dataUpdatedAt;\n\n        switch (action.type) {\n          case 'failed':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: state.fetchFailureCount + 1\n            });\n\n          case 'pause':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'paused'\n            });\n\n          case 'continue':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'fetching'\n            });\n\n          case 'fetch':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: 0,\n              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n              fetchStatus: canFetch(_this3.options.networkMode) ? 'fetching' : 'paused'\n            }, !state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            });\n\n          case 'success':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              data: action.data,\n              dataUpdateCount: state.dataUpdateCount + 1,\n              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n              error: null,\n              isInvalidated: false,\n              status: 'success'\n            }, !action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            });\n\n          case 'error':\n            var error = action.error;\n\n            if (isCancelledError(error) && error.revert && _this3.revertState) {\n              return _objectSpread({}, _this3.revertState);\n            }\n\n            return _objectSpread(_objectSpread({}, state), {}, {\n              error: error,\n              errorUpdateCount: state.errorUpdateCount + 1,\n              errorUpdatedAt: Date.now(),\n              fetchFailureCount: state.fetchFailureCount + 1,\n              fetchStatus: 'idle',\n              status: 'error'\n            });\n\n          case 'invalidate':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isInvalidated: true\n            });\n\n          case 'setState':\n            return _objectSpread(_objectSpread({}, state), action.state);\n        }\n      };\n\n      this.state = reducer(this.state);\n      notifyManager.batch(function () {\n        _this3.observers.forEach(function (observer) {\n          observer.onQueryUpdate(action);\n        });\n\n        _this3.cache.notify({\n          query: _this3,\n          type: 'updated',\n          action: action\n        });\n      });\n    }\n  }]);\n\n  return Query;\n}(Removable);\n\nfunction getDefaultState(options) {\n  var data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  var hasInitialData = typeof options.initialData !== 'undefined';\n  var initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  var hasData = typeof data !== 'undefined';\n  return {\n    data: data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}\n\nexport { Query }; //# sourceMappingURL=query.mjs.map","map":null,"metadata":{},"sourceType":"module"}