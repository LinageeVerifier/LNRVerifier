{"ast":null,"code":"import _slicedToArray from \"C:/Users/danie/OneDrive/Desktop/work on this/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore.mjs';\nimport { QueriesObserver, notifyManager } from '@tanstack/query-core';\nimport { useQueryClient } from './QueryClientProvider.mjs';\nimport { useIsRestoring } from './isRestoring.mjs';\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary.mjs';\nimport { ensurePreventErrorBoundaryRetry, useClearResetErrorBoundary, getHasError } from './errorBoundaryUtils.mjs'; // - `context` is omitted as it is passed as a root-level option to `useQueries` instead.\n\nfunction useQueries(_ref) {\n  var queries = _ref.queries,\n      context = _ref.context;\n  var queryClient = useQueryClient({\n    context: context\n  });\n  var isRestoring = useIsRestoring();\n  var defaultedQueries = React.useMemo(function () {\n    return queries.map(function (options) {\n      var defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure the results are already in fetching state before subscribing or updating options\n\n      defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic';\n      return defaultedOptions;\n    });\n  }, [queries, queryClient, isRestoring]);\n\n  var _React$useState = React.useState(function () {\n    return new QueriesObserver(queryClient, defaultedQueries);\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 1),\n      observer = _React$useState2[0];\n\n  var result = observer.getOptimisticResult(defaultedQueries);\n  useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return undefined;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(defaultedQueries, {\n      listeners: false\n    });\n  }, [defaultedQueries, observer]);\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  defaultedQueries.forEach(function (query) {\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  var firstSingleResultWhichShouldThrow = result.find(function (singleResult, index) {\n    var _defaultedQueries$ind, _defaultedQueries$ind2;\n\n    return getHasError({\n      result: singleResult,\n      errorResetBoundary: errorResetBoundary,\n      useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,\n      query: observer.getQueries()[index]\n    });\n  });\n\n  if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n\n  return result;\n}\n\nexport { useQueries }; //# sourceMappingURL=useQueries.mjs.map","map":null,"metadata":{},"sourceType":"module"}